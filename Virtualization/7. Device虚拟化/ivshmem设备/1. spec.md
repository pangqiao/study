
# 概述

https://www.qemu.org/docs/master/specs/ivshmem-spec.html

**ivshmem**(`Inter-VM shared memory device`) 用来在不同的 guest 之间, guest 和 host 之间进行共享内存.

为了让所有 guest 都能够获取共享内存区域，QEMU 将其建模为 PCI 设备, 将所述内存作为 PCI BAR 暴露给 guest.

该设备可以直接使用 host 上的共享内存对象，也可以从 ivshmem server 中获取一个。In the latter case, the device can additionally interrupt its peers, and get interrupted by its peers.

qemu 中使用 ivshmem 见: https://www.qemu.org/docs/master/system/devices/ivshmem.html

从代码分析和实际验证，guest 与 guest 之间可以实现中断与非中断 2 种模式下的通信，host 与 guest 之间只支持非中断模式的通信。

# 设备的 guest 接口

设备的

* vendor ID: 1af4

* device ID: 1110

* revision: 1. QEMU 2.6.0 之前, revision 是 0.

## PCI BARS

BAR 是 PCI配置空间中从 0x10 到 0x24 的 6 个 register，用来定义 PCI 需要的配置空间大小以及配置 PCI 设备**占用的地址空间**.

* x86 中地址空间分为 MEM 和 IO 两类，因此 PCI 的 BAR 在 bit 0 来表示该设备是映射到 memory 还是 IO，bar 的 bit0 是只读的，

* bit1 保留位，

* bit2 中 0 表示 32 位地址空间，1 表示64位地址空间，

* bit3 表示 prefetchable 或 non-prefetchable

* 其余的bit用来表示设备需要占用的地址空间大小与设备起始地址。

ivshmem 设备支持 3 个 PCI BAR。

* BAR0 用于表示设备的寄存器信息, 256 字节的 MMIO 空间

* BAR1 用于 MSI-X table 和 PBA(仅仅用于 ivshmem-doorbell)

* BAR2 用来从 host 中映射共享内存对象。BAR2 的大小通过命令行指定，必须是 2 的次方。

BAR0 是 1kbyte 的MMIO区域，支持寄存器。根据计算可以得到，设备当前支持 3 个 32bits寄存器（下文介绍），还有一个寄存器为每个guest都有，最多支持253个guest（一共256*4=1kbyte），实际默认为16。


两种方式来使用这个设备:

* 如果只需要**共享内存**部分，**BAR2** 就足够了。这样就可以在 guest 中访问共享内存，并使用;

* 如果还需要**中断**的能力，则需要 **BAR0** 和 **BAR1**。你很可能希望编写一个内核驱动来处理中断。显然，需要对设备进行中断配置。

在 QEMU 2.6.0 之前，如果设备配置了中断，则 BAR2 刚开始可能是无效的。只有在 ivshmem server 提供共享内存后，它才能安全访问。这些设备的 PCI revision 为 0，而不是 1。在**访问 BAR2 之前**，guest 应等待 **IVPosition** 寄存器（下面）变为**非负数**。

revision 0 的设备无法告知 guest 软件该设备是否配置了中断。

## PCI 设备寄存器

Ivshmem 设备共有 4 种类型的寄存器. 寄存器在 BAR0 中:

```
Offset  Size  Access      On reset  Function
    0     4   read/write        0   Interrupt Mask
                                    bit 0: peer interrupt (rev 0)
                                           reserved       (rev 1)
                                    bit 1..31: reserved
    4     4   read/write        0   Interrupt Status
                                    bit 0: peer interrupt (rev 0)
                                           reserved       (rev 1)
                                    bit 1..31: reserved
    8     4   read-only   0 or ID   IVPosition
   12     4   write-only      N/A   Doorbell
                                    bit 0..15: vector
                                    bit 16..31: peer ID
   16   240   none            N/A   reserved
```

软件只能遵循 “Access” 列访问寄存器。保留位在读取时应忽略，在写入时禁止。

Mask寄存器：

与中断状态按位与，如果非0则触发一个中断。因此可以通过设置mask的第一bit为0来屏蔽中断。

Status寄存器：

当中断发生（pin 中断下 doorbell 被设置）时，目前qemu驱动所实现的寄存器被设置为1。由于status代码只会设1，所以 mask 也只有第一个 bit 会有左右，笔者理解可通过修改驱动代码实现status含义的多元化。


在 **revision** 是 **0** 的设备中，当设备**没有** `MSI-X` 功能时，`Interrupt Status` 和 `Interrupt Mask` 寄存器一起控制 legacy INTx 中断：两者**按位与**运算, 结果非 0 且设备没有 MSI-X 功能时，将断言 INTx(触发一个中断)。而对端收到中断请求时，`Interrupt Status` 的 **bit0** 变为 **1**。读该寄存器将清零。

IVPosition 寄存器: 只读. 如果设备**未配置中断**，则为**零**。否则，它是设备的 ID（介于 0 和 65535 之间）。

在 QEMU 2.6.0 之前，在复位后的短时间内读寄存器可能返回 -1。这些设备的 PCI revision 是 0，而不是 1。

软件没有很好的方法来确定设备是否配置了中断。IVPosition 返回正数意味着配置了中断，但零可能也意味着配置了中断。

Doorbell 寄存器: 通过写自己的 doorbell 可以向其 peer 发送中断。

* 高 16 位是要接受中断的 peer 的 ID;

* 低 16 位是所触发的 中断向量。

一个指定guest id的doorbell在mmio区域的偏移等于：

```
guest_id * 32 + Doorbell
```

写入 doorbell 的语义取决于设备是使用 msi 还是 pin 的中断.

如果设备没有配置中断, 写操作会被忽略.

如果中断还没设置完成，则忽略写入。设备无法告知 guest 设置是否完成。中断可能会在迁移时回归到此状态。

如果具有请求 ID 的 peer 还没连接，或者连接的中断向量较少，则忽略写入。该设备无法告诉 guest 连接了哪些 peer，或者连接了多少个中断向量。

此向量的 peer 中断会 pending。软件无法清除挂起的位，因此无法采用轮询操作模式。

如果 peer 是没有 MSI-X 功能的 revision 0 设备，它的 `Interrupt Status`(中断状态)寄存器设置为 1。这断言 INTx，除非通过 `Interrupt Mask`(中断掩码)寄存器进行了屏蔽。然后，设备无法将中断向量传送到 guest.

对于多个 MSI-X 向量，可以使用不同的向量来指示发生了不同的事件。中断向量的语义留给应用进程。

# 中断服务

配置中断时，peer 除了共享内存外，还会共享 eventfd 对象。共享的所有资源由 ivshmem server 管理。

## ivshmem server

> 共享内存server是在host上运行的一个应用程序，每启动一个vm，server会指派给vm一个id号，并且将vm的id号和分配的eventfd文件描述符一起发给qemu进程。Id号在收发数据时用来标识vm，guests之间通过eventfd来通知中断。每个guest都在与自己id所绑定的eventfd上侦听，并且使用其它eventfd来向其它guest发送中断.

该 server 监听一个 UNIX domain socket.

对于每一个连接到该 server 的**新的 client**, server 会:

* 获取一个新的 ID,

* 创建一个 eventfd 文件描述符用于中断向量,

* 发送该 ID 和 文件描述符给新的 client,

* 将新 client 的连接通知发送到其他 clients（这些 clients 包含用于发送中断的文件描述符），

* 将其他 clients 的连接通知发送到新 client

* 


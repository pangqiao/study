
从主板模拟那部分可以看出设备与总线是交替的，也就是**总线**下面**只能**够连接**设备**，**设备**也**只**能够连接到**总线**上，**总线与总线**之间、**设备与设备**之间**不能直接连接**。

QEMU 中**总线类型**用 `TYPE_BUS` 表示，也可以说这是**所有总线的基类**，所有**具体总线**的**父类**都是 `TYPE_BUS`，如 PCI_BUS、ISA_BUS、SCSI_BUS 等。

总线相关的类是 BusClass，其定义如下。

```cpp
// include/hw/qdev-core.h
struct BusClass {
    ObjectClass parent_class;

    /* FIXME first arg should be BusState */
    void (*print_dev)(Monitor *mon, DeviceState *dev, int indent);
    char *(*get_dev_path)(DeviceState *dev);

    char *(*get_fw_dev_path)(DeviceState *dev);

    bool (*check_address)(BusState *bus, DeviceState *dev, Error **errp);

    BusRealize realize;
    BusUnrealize unrealize;

    /* maximum devices allowed on the bus, 0: no limit. */
    int max_dev;
    /* number of automatically allocated bus ids (e.g. ide.0) */
    int automatic_ids;
};
```

* print_dev 打印总线上的一个设备。

* get_dev_path/get_fw_dev_path 得到设备路径以及在 firmware 中的路径。

* realize 是表示 Bus 进行 realize 的回调函数，unrealize 则是销毁时的回调函数。

* max_dev 表示的是该 Bus 上允许的最大设备。

* automatic_ids 表示自动生成 bus id 的序列号，如ide.0、ide.1 等。

表示Bus对象的结构是BusState，其定义如下

```cpp
// include/hw/qdev-core.h
struct BusState {
    /* private: */
    Object obj;
    /* public: */
    DeviceState *parent;
    char *name;
    HotplugHandler *hotplug_handler;
    int max_index;
    bool realized;
    bool full;
    int num_children;

    BusChildHead children;
    BusStateEntry sibling;
    ResettableState reset;
};

```
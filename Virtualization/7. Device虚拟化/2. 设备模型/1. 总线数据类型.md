
从主板模拟那部分可以看出设备与总线是交替的，也就是**总线**下面**只能**够连接**设备**，**设备**也**只**能够连接到**总线**上，**总线与总线**之间、**设备与设备**之间**不能直接连接**。

QEMU 中**总线类型**用 `TYPE_BUS` 表示，也可以说这是**所有总线的基类**，所有**具体总线**的**父类**都是 `TYPE_BUS`，如 PCI_BUS、ISA_BUS、SCSI_BUS 等。

总线相关的类是 BusClass，其定义如下。

```cpp
// include/hw/qdev-core.h
struct BusClass {
    ObjectClass parent_class;

    /* FIXME first arg should be BusState */
    void (*print_dev)(Monitor *mon, DeviceState *dev, int indent);
    char *(*get_dev_path)(DeviceState *dev);

    char *(*get_fw_dev_path)(DeviceState *dev);

    bool (*check_address)(BusState *bus, DeviceState *dev, Error **errp);

    BusRealize realize;
    BusUnrealize unrealize;

    /* maximum devices allowed on the bus, 0: no limit. */
    int max_dev;
    /* number of automatically allocated bus ids (e.g. ide.0) */
    int automatic_ids;
};
```

* print_dev 打印总线上的一个设备。

* get_dev_path/get_fw_dev_path 得到设备路径以及在 firmware 中的路径。

* realize 是表示 Bus 进行 realize 的回调函数，unrealize 则是销毁时的回调函数。

* max_dev 表示的是该 Bus 上允许的最大设备。

* automatic_ids 表示自动生成 bus id 的序列号，如ide.0、ide.1 等。

表示Bus对象的结构是BusState，其定义如下

```cpp
// include/hw/qdev-core.h
struct BusState {
    /* private: */
    Object obj;
    /* public: */
    DeviceState *parent;
    char *name;
    HotplugHandler *hotplug_handler;
    int max_index;
    bool realized;
    bool full;
    int num_children;

    BusChildHead children;
    BusStateEntry sibling;
    ResettableState reset;
};
```

* parent 表示总线所在的设备，因为总线不能独立产生，必须依赖于一个设备，如PCI总线是由PCI桥产生的，USB总线是由USB控制器产生的，SCSI总线是由SCSI控制器产生的，这里的parent即表示总线的父设备。

* hotplug_handler 指向一个处理热插拔的处理器，因为很多总线允许设备热插拔，这个结构就是用来完成热插拔处理的。

* `max_index` 表示插在该总线上的设备个数，children用来表示连接在该总线上面的所有设备。

* `sibling` 用来连接在一条总线上的设备。

了解了BusClass和BusState之后就可以分析TYPE_BUS的类型信息。

```cpp
// include/hw/qdev-core.h
#define TYPE_BUS "bus"

// hw/core/bus.c
static const TypeInfo bus_info = {
    .name = TYPE_BUS,
    .parent = TYPE_OBJECT,
    .instance_size = sizeof(BusState),
    .abstract = true,
    .class_size = sizeof(BusClass),
    .instance_init = qbus_initfn,
    .instance_finalize = qbus_finalize,
    .class_init = bus_class_init,
    .interfaces = (InterfaceInfo[]) {
        { TYPE_RESETTABLE_INTERFACE },
        { }
    },
};
```

`bus_class_init` 是 Bus 类型在初始化的时候调用的，代码如下

```cpp
// hw/core/bus.c
static void bus_class_init(ObjectClass *class, void *data)
{
    BusClass *bc = BUS_CLASS(class);
    ResettableClass *rc = RESETTABLE_CLASS(class);

    class->unparent = bus_unparent;
    bc->get_fw_dev_path = default_bus_get_fw_dev_path;

    rc->get_state = bus_get_reset_state;
    rc->child_foreach = bus_reset_child_foreach;
}
```



<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 硬件基础](#1-硬件基础)
- [2. Time Tick](#2-time-tick)
- [3. 虚拟化时钟](#3-虚拟化时钟)
- [4. hrtimer](#4-hrtimer)
- [5. Preemption Timer](#5-preemption-timer)
  - [5.1. 什么是Preemption Timer](#51-什么是preemption-timer)
  - [5.2. 如何使用Preemption Timer](#52-如何使用preemption-timer)
  - [5.3. Preemption Timer count down频率的计算](#53-preemption-timer-count-down频率的计算)

<!-- /code_chunk_output -->

# 1. 硬件基础

参见`Architecture/x86/7. 时钟.md`

操作系统时钟从作用上分为两种: 

* 计时
* 定时器

硬件方面，x86 主流平台，**计时**靠**tsc**，**定时**靠**local apic timer**。

软件方面，linux, 低精度，高精度，先低精度然后切换到高精度。

- rtc
- pit
- hpet
- tsc
- local timer
- kvmclock
- preemption timer

以前提到, APIC Timer的模式APIC定时器包含**3种定时器模式**，
- 周期触发`periodic`
- 一次性触发`one-shot`
- `TSC-Deadline`模式(最新的CPU里面支持)。

代码在`arch/x86/kvm/lapic.c`的`apic_update_lvtt`

查看操作系统的clocksource：

在`/sys/devices/system/clocksource/clocksource0`目录下；

- `available_clocksource`是当前**所有可用**的clocksource；

- `current_clocksource`是当前**正在使用**的clocksource。

clocksource management：

主要逻辑代码在`kernel/time/clocksource.c`中实现

# 2. Time Tick

一个操作系统要跑起来，必须有**Time Tick**，它就像是身体的脉搏。

普通情况下，**OS Time Tick**由**PIT**(i8254)或**APIC Timer**设备提供产生中断源

- PIT(i8254)定期(**每1ms**)产生一个**timer interrupt**，作为**global tick**, 
- **APIC Timer**产生一个**local tick**。

两者电子线路连接不同:
- 对于**i8254设备**来说首先连接到**i8259中断控制器**，i8259中断控制器再连接到**ioapic设备**中，送到**lapic**, 最后**注入到vcpu**中。
- 对于APIC Timer设备实际就是lapic的一个功能，意思就是通过编程可以触发lapic设备周期产生中断，然后注入到vcpu。

通过上面了解知道两者区别了**APIC Timer**的是**每个cpu**内核都有**一个定时器**，而**PIT是共用的一个**。

# 3. 虚拟化时钟

kvm支持的时钟有rtc、8254pit、HPET、TSC、local apic timer, kvmclock等

在虚拟化情况下，必须为**guest OS**模拟一个**PIT**和**APIC Timer**。

qemu-kvm模拟**两个时钟中断设备**: **PIT**(i8254)和**APIC Timer**设备，也就是产生**中断源**。

模拟的**PIT**和**APIC Timer**不能像真正硬件那样**物理计时**，所以一般用**HOST的某种系统服务**或**软件计时器**来为这个模拟 PIT/APIC Timer 提供模拟”**时钟源**”。

目前两种方案：

1. **用户态模拟方案**（QEMU）； 
2. **内核态模拟方案**（KVM）；

在**QEMU**中，用**SIGALARM信号**来实现：QEMU利用**某种机制**，使**timer interrupt handler**会向**QEMU process**发送一个**SIGALARM信号**，处理该信号过程中再**模拟PIT**中**产生一次时钟**。QEMU再通过某种机制，将**此模拟PIT**发出的**模拟中断交付给kvm**，再由kvm**注入**到虚拟机中去。

目前的kvm版本支持**内核PIT**、**APIC**和**内核PIC**，因为这几个设备是**频繁使用**的，在**内核模式中模拟**比在**用户模式模拟**性能更高。

# 4. hrtimer

hrtimer，不是时钟源，只是一种**高精准软件时钟**定时器，Linux一般用这个来计算ticker, 定时器的真实物理时钟源根据不同的硬件而不同

可作为超时或周期性定时器使用

传统的低精度的为时间轮方案; hrtimer为高精度定时器，管理机制为红黑树管理方案；

注: 不仅仅是kvm使用

主要涉及接口:

1. `hrtimer_init()`: 初始化定时器, 设置工作模式
2. `hrtimer_start()`: 启用一个定时器, 第二个参数用于设置超时参数
3. `hrtimer_cancel()`: 取消一个定时器

详细参见`Linux/Time`

# 5. Preemption Timer

## 5.1. 什么是Preemption Timer

Preemption Timer是一种可以**周期性**使**VM触发VMEXIT**的一种机制。即设置了Preemption Timer之后，可以使得虚拟机在**指定的TSC cycle之后**产生一次**VMEXIT**并设置对应的`exit_reason`，trap到VMM中。

使用Preemption Timer时需要注意下面两个问题：
在旧版本的Intel CPU中Preemption Timer是不精确的。在Intel的设计中，**Preemption Timer**应该是严格**和TSC保持一致**，但是在Haswell之前的处理器并不能严格保持一致。

Preemption Timer只有在VCPU进入到Guest时（即进入`non-root` mode）才会开始工作，在**VCPU**进入**VMM**时或者**VCPU被调度出CPU**时，其**值都不会有变化！！！**。

```
cat /sys/module/kvm_intel/parameters/preemption_timer
```

## 5.2. 如何使用Preemption Timer

Preemption Timer在VMCS中有三个域需要设置：

- `Pin-Based VM-Execution Controls，Bit 6，“Activate VMX preemption timer”`： 该位如果设置为1，则**打开Preemption Timer**；如果为0，则下面两个域的设置均无效。该位在Kernel代码中对应的宏为`PIN_BASED_VMX_PREEMPTION_TIMER`。

- `VM-Exit Controls，Bit 22，"Save VMX preemption timer value"`： 如果该位设置为**1**，则在**每次VMEXIT**的时候都会将**已经消耗过的value**存在**VMCS**中；如果设置为**0**，则在每次VMEXIT之后，`Preemption Value`都会被设置成**初始值**。该位在Kernel代码中对应的宏为`VM_EXIT_SAVE_VMX_PREEMPTION_TIMER`。

- `VMX-preemption timer value`：这个域是**VMCS中的一个域**，存储Preemption Value。这是一个32bit的域，设置的值是**每次VMENTER**时的值，在**VM运行的过程**中逐渐减少。如果设置了`Save VMX preemption timer value`，那么在退出时会**更新该域为新的值**，可以根据**两次的差**来计算**虚拟机运行**的**多少个TSC cycle**。在Kernel对用的宏为`VMX_PREEMPTION_TIMER_VALUE`。

和Preemption Timer相关的文档参见Intel Manual，以及全文搜索"Preemption Timer"得到的相关内容。

在使用时，需要首先设置`Activate VMX preemption timer`和`VMX-preemption timer value`，如果需要**VMEXIT**时**保存preemption value**的话，需要设置`Save VMX preemption timer value`，这样在VM因为**其他原因退出**的时候**不会重置preemption value**。

Preemption Timer一个可能的使用环境是：需要让**VM定期的产生VMEXIT**，那么上述三个域都需要设置。注意：在由`Preemption Timer Time-out`产生的VMEXIT中，是需要重置VMX preemption timer value的。

Preemption Timer相关的的`VMEXIT reason`号是**52**，参考`Intel Manual 3C Table C-1 [1]，"VMX-preemption timer expired. The preemption timer counted down to zero"`。

## 5.3. Preemption Timer count down频率的计算

Preemption Timer频率的计算可以参考`Intel Manual 3C [1]的"25.5.1 VMX-Preemption Timer`"，在这里我给出一个简单的算法，首先明确如下几个名词：

- **PTTR**（`Preemption Timer TSC Rate`）：在MSR `IA32_VMX_MISC`的**后五位中**，存储着一个5 bit的数据，代表着`Preemption Timer TSC Rate`。该rate表示TSC count down多少次会导致Preemption Timer Value count down一次，所以我成为“Rate”。

- **PTV**（`Preemption Timer Value`）：在VMCS的VMX-preemption timer value域中设置的值

- CPI（Cycle Per Instruction）：**每个CPU指令**需要消耗的**CPU周期**。在Intel架构中的Ideal CPI大约是0.25 [2]，但是在一般的应用中都会比这个值大一些。（注：CPI小于1的原因是多发射和超流水线结构）。

IPP（Instructions per Preemption）：Preemption Timer从**开始设置**到产生**相关的VMEXIT**时，VCPU执行了**多少条CPU指令**。

在这里我给出一个简单的计算方法：

```
IPP = PTV * PTTR / CPI
```

根据上述公式，可以简单的计算PTV和IPP之间的关系，根据每个Preemption中执行的指令数目来决定设置多大的Preemption Timer Value。
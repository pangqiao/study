
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 全虚拟化](#1-全虚拟化)
	* [1.1 软件辅助的全虚拟化](#11-软件辅助的全虚拟化)
	* [1.2 硬件辅助的全虚拟化](#12-硬件辅助的全虚拟化)
* [2 半虚拟化](#2-半虚拟化)

<!-- /code_chunk_output -->

https://blog.csdn.net/dongfei2033/article/details/82756634

# 1 全虚拟化

**不需要**对**GuestOS操作系统软件的源代码做任何的修改**, 就可以运行在这样的VMM中

在**全虚拟化的虚拟平台**中, **GuestOS**并**不知道**自己是一台**虚拟机**, 它会认为自己就是运行在计算机物理硬件设备上的HostOS. 因为**全虚拟化的VMM！！！**会将一个**OS**所能够操作的**CPU**、**内存**、**外设**等物理设备**逻辑抽象**成为**虚拟CPU**、**虚拟内存**、**虚拟外设**等虚拟设备后, 再交由**GuestOS来操作使用**. 这样的GuestOS会将底层硬件平台视为自己所有的, 但是实际上, 这些都是VMM为GuestOS制造了这种假象. 

全虚拟化又分为: 软件辅助的全虚拟化 & 硬件辅助的全虚拟化. 

## 1.1 软件辅助的全虚拟化

架构图

![config](./images/12.png)

在Intel等CPU厂商还没有发布**x86 CPU虚拟化技术之前**, **完全虚拟化**都是通过**软件辅助**的方式来实现的. 

而**软件辅助的全虚拟化**主要是应用了**两种机制**: 

1. **特权解除(优先级压缩**): 从上述的软件辅助全虚拟化架构图中可以看出, **VMM**、**GuestOS**、**GuestApplications**都是运行在**Ring 1-3用户态(！！！VMM也处于用户态！！！**)中的应用程序代码. 当在**GuestOS**中执行**系统内核的特权指令**时, 一般都会**触发异常！！！**. 这是因为**用户态代码**不能直接运行在**核心态**中, 而且**系统内核的特权指令**大多都**只能运行在Ring 0核心态**中. 在**触发了异常**之后, 这些**异常就会被VMM捕获**, 再由**VMM！！！**将这些**特权指令！！！**进行**虚拟化**成为**只针对虚拟CPU起作用(！！！**)的**虚拟特权指令！！！**. 其本质就是使用**若干能运行在用户态中的非特权指令(！！！**)来**模拟**出**只针对GuestOS有效的虚拟特权指令**, 从而将特权指令的特权解除掉. 

缺点: 但是特权解除的问题在于当初设计**标准x86架构CPU**时, 并没有考虑到要支持虚拟化技术, 所以会存在**一部分特权指令**运行在**Ring 1用户态**上, 而这些运行在Ring 1上的特权指令并**不会触发异常然后再被VMM捕获(！！！有些特权指令不会被VMM捕获！！！**). 从而导致在**GuestOS**中执行的**特权指令直接对HostOS**造成了影响(GuestOS和HostOS没能做到**完全隔离**). 

针对这个问题, 再引入了**陷入模拟的机制**. 

2. **陷入模拟(二进制翻译**): 就是**VMM**会对**GuestOS**中的**二进制代码(运行在CPU中的代码！！！**)进行**扫描！！！**, 一旦发现**GuestOS**执行的**二进制代码**中包含有**运行在用户态上的特权指令二进制代码**时, 就会将这些二进制代码翻译成**虚拟特权指令二进制代码(！！！**)或者是**翻译成运行在核心态中的特权指令！！！二进制代码从而强制的触发异常！！！**. 这样就能够很好的解决了运行在**Ring 1用户态上的特权指令没有被VMM捕获！！！**的问题, 更好的实现了GuestOS和HostOS的隔离. 

简而言之, **软件辅助虚拟化**能够成功的将所有在**GuestOS**中执行的**系统内核特权指令**进行**捕获、翻译**, 使之成为只能对GuestOS生效的虚拟特权指令. 但是退一步来说, 之所以需要这么做的前提是因为**CPU**并不能准确的去判断**一个特权指令！！！**到底是由**GuestOS发出！！！**的还是由**HostOS发出！！！**的, 这样也就**无法针对一个正确的OS**去**将这一个特权指令执行**. 

直到后来CPU厂商们发布了能够**判断特权指令归属！！！**的**标准x86 CPU**之后, 迎来了**硬件辅助全虚拟化**. 

## 1.2 硬件辅助的全虚拟化

![config](./images/13.png)

硬件辅助全虚拟化主要使用了**支持虚拟化功能**的**CPU**进行支撑, **CPU**可以明确的**分辨出**来自**GuestOS的特权指令**, 并**针对GuestOS进行特权操作(！！！**), 而**不会影响到HostOS**. 

从更深入的层次来说, **虚拟化CPU**形成了**新的CPU执行状态** —— **Non\-Root Mode& Root Mode**. 从上图中可以看见, **GuestOS(！！！**)运行在**Non\-Root Mode** 的**Ring 0核心态**中, 这表明**GuestOS**能够**直接执行特却指令**而不再需要 **特权解除** 和 **陷入模拟** 机制. 并且在**硬件层**上面紧接的就是**虚拟化层的VMM**, 而**不需要HostOS！！！**. 这是因为在**硬件辅助全虚拟化的VMM**会以一种更具协作性的方式来实现虚拟化 —— 将**虚拟化模块**加载到**HostOS的内核**中, 例如: KVM, KVM通过在HostOS内核中加载KVM Kernel Module来将**HostOS转换成为一个VMM！！！**. 所以此时**VMM可以看作是HostOS, 反之亦然**. 

这种虚拟化方式创建的**GuestOS知道**自己是正在**虚拟化模式**中运行的GuestOS, KVM就是这样的一种虚拟化实现解决方案. 

# 2 半虚拟化

需要对**GuestOS的内核代码**做一定的修改, 才能够将GuestOS运行在半虚拟化的VMM中. 

**半虚拟化**通过在**GuestOS的源代码级别上修改特权指令**来回避上述的虚拟化漏洞. 

**修改内核**后的**GuestOS**也**知道**自己就是一台**虚拟机**. 所以能够很好的对**核心态指令**和**敏感指令**进行识别和处理, 但缺点在于**GuestOS的镜像文件并不通用**. 

具体的**x86架构CPU**解析, 请参考[虚拟化的发展历程和实现方式](https://blog.csdn.net/jmilk/article/details/51031118)

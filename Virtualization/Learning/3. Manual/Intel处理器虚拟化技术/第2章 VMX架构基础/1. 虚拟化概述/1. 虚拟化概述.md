
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 概述](#1-概述)
- [2. 虚拟设备](#2-虚拟设备)
  - [2.1. 外部中断控制权在guest上](#21-外部中断控制权在guest上)
  - [2.2. 外部中断控制权在VMM上](#22-外部中断控制权在vmm上)
  - [2.3. 外部设备所有权归VMM](#23-外部设备所有权归vmm)
  - [2.4. 外部设备所有权归VM](#24-外部设备所有权归vm)
- [3. 地址转换](#3-地址转换)
- [4. 设备的I/O访问](#4-设备的io访问)

<!-- /code_chunk_output -->

# 1. 概述

虚拟机的运用需要以**处理器平台提供Virtualization Technology(VT, 虚拟化技术**)为前提, 是以资源的虚拟化管理的结果. 在虚拟化技术之前, 软件运行在物理机器上, 对物理资源进行直接控制, 譬如设备的中断请求, guest的内存访问, 设备的I/O访问等. 软件更改这些资源的状态将直接反映在物理资源上, 或设备的请求得到直接响应.

在**CPU端的虚拟化**里, 实现了VMX(Virtual\-Machine Extensions, 虚拟机扩展)架构. 这个虚拟机架构中, 存在两种角色环境: **VMM(Virtual Machine Monitor, 虚拟机监管者**)和**VM(Virtual Machine, 虚拟机**). **host端软件**运行在**VMM环境**中, 可以**仅作为hypervisor角色**存在(作为**全职的虚拟机管理者**), 或者**包括VMM(虚拟机监管者**)职能的**host OS**.

guest端软件运行在VM环境中. 一个VM代表一个虚拟机实例, 一个处理器平台可以有多个虚拟机实例, 由于VM里的资源被虚拟化, 每个MV彼此独立.

**guest软件**访问的**资源受到VMM监管**, **guest**希望**修改某些物理资源**时, **VMM**返回一个**虚拟化后的结果给guest**. 例如, **guest**软件对**8259控制器**的状态进行修改, **VMM拦截**这个修改, 进行**虚拟化操作**, 实时修改或不修改8259控制器的物理状态, 反馈一个不真实的结果给guest软件.

下图展示前面提到的虚拟化环境里的三种虚拟化管理:

(1) 设备中断请求

(2) guest内存访问

(3) 设备的I/O访问

![config](./images/1.png)

设备的**中断请求**经由**VMM监管**, 模拟出**虚拟设备(！！！**)反馈一个**虚拟中断**给guest执行, 在这个模型中, **设备中断请求不直接发给guest执行**. 

而**guest访问的物理地址**也**不是最终的物理地址**, 而是**经过EPT进行转换**才得到的最终物理地址. 

设备1和设备2使用**DMA访问**时, 它们**最终的目标物理地址**经过**VT\-d(！！！**)技术的**DMA重新映射功能**映射到**属于自己的domain(区域**).

# 2. 虚拟设备

在**设备发生中断请求**时, 这就产生设备的ISR(中断服务例程)是由**VMM(或host OS)处理！！！**, 还是**直接由VM(guest OS)处理**(或由**VMM转发给VM！！！**)的问题, 即**ISR**是**运行在host**还是**guest端**的问题.

依赖于VMM对**外部设备所有权**的设计产生**两种模型(！！！**):

- **设备**是属于**host所有**, 物理设备的**ISR**由**VMM来执行**.
- **设备**分配给**VM使用**, 那么**ISR**将在**guest环境**里运行.

**host**和**guest**都有自己的**IDT(中断描述符表**), host vector对应物理设备ISR在host IDT的位置, 而guest vector对应着VMM反馈给guest的中断请求在guest IDT上的位置. **中断请求**通过**VMM**给**VM**使用**injection event(注入事件！！！**)的手段来实现.

## 2.1. 外部中断控制权在guest上

**host vector**和**guest vector**并**不相等**, 但在**设备分配给VM**使用的模型里, 若**外部中断控制权在guest**手上, 那么**guest vector**可以对应**物理设备ISR在guest IDT**的位置, 也就是**物理设备ISR完全由guest执行**, 而**VMM并不监管或转发**.

## 2.2. 外部中断控制权在VMM上

如果**外部中断的控制权**需要掌握在**VMM(即host**)手中, 通过**开启"external\-interrupt exiting！！！**"功能, 并且结合"**acknowledge interrupt on exit"位！！！**的设置来实现. 当发生**外部中断**时, **VM停止工作**, 处理器**控制权切换回VMM**.

## 2.3. 外部设备所有权归VMM

在**设备所有权归VMM(！！！**)的模型里, **虚拟设备**产生了, 它是**VMM**在**物理设备之上抽象**出来的虚拟设备概念. 

**中断发生**, **VMM的vector**是物理设备对应在**host IDT**里, **VMM**执行**物理设备的ISR**. 然后**模拟guest的ISR处理流程**, 如发送EOI命令给中断控制器, 更新中断控制器状态. 根据**对应的guest vector**注入一个**外部中断给guest(！！！**)在自己的IDT找到ISR执行, 这个**guest ISR可能并不能做实际收尾工作**, 如发送EOI命令(被VMM接管)或更新中断控制器.

**host vector**代表着来自**平台的物理设备**, 而**guest vector**代表来自**虚拟设备**, 这**两个vector值不一致**, 这个**虚拟设备由VMM维护**而代表着**物理设备在VM环境中的名字**. **虚拟设备**可能并**不存在实体功能**, 只是逻辑表述上的抽象概念.

## 2.4. 外部设备所有权归VM

在**设备分配给VM**使用的模型里, guest vector与host vector可能一致也可能不一致, 但**物理设备的ISR由guest**去运行, 代表着ISR的收尾工作由guest去执行. **VMM截取中断请求**后根据**guest vector**, 同样使用**事件注入手段**转发外部中断给**guest执行**, 而**VMM可能并不做其他工作**. 这是在**host夺取外部中断控制器**的前提下, 前面所述在**guest掌控外部中断权**时, 设备ISR直接在guest中执行.

当然, **VMM也可以不拦截外部中断(！！！**), 这样外部中断就直接通过guest\-IDT进行deliver执行, 而**不需要经过VMM转发**.

# 3. 地址转换

EPT和guest paging\-structure table

**host软件**和**guest软件**都运行在**物理平台**上, 需要**guest不能干扰VMM**的执行. 比如, guest软件访问100000h物理地址, 但这个物理地址可能属于host的私有空间, 或者host也需要访问100000h物理地址. **VMM**的设计需要guest不能访问到这个真实的物理地址, VMM通过**EPT(Extend Page Table, 扩展页表**)来实现"**guest端物理地址到host端物理地址**"的转换, 使得guest访问到其他的物理区域.

**EPT**是**内存虚拟化**的重要手段. EPT的实现原理和分页机制里的转换页表一样, 经过多级转换产生最终的物理地址.

在**开启EPT机制**, 产生两个地址概念: **GPA(Guest Physical Address**)和**HPA(Host Physical Address**), **HPA是真正的物理地址**. **guest软件**访问的**物理地址(！！！**)都属于**GPA**, 而host软件访问的物理地址则属于HPA. 而**没启用EPT机制**情况下, **guest**软件访问的**物理地址**就是**最终的物理地址**.

另一个概念: **guest paging\-structure table(guest的页结构表**), 也就是**guest内**保护模式分页机制下的**线性地址到物理地址转换**使用的**页表**. 这个**页表项**内使用的**物理地址**是**GPA**(例如**CR3的页目录指针基址**), 而**EPT paging\-structure table(EPT页表结构**)页表项使用的是**HPA**.

# 4. 设备的I/O访问

在由**CPU发起访问外部设备(！！！**)时, 需要通过**PCI\PCIe总线**的**内存读写事务**、**I/O读写事务**或**配置读写事务**进行. 当**guest**软件发起这样的访问, **VMM**可以通过**内存虚拟化**和**I/O地址虚拟化**达到**虚拟化设备的目的**.

当由**设备主动发起访问内存**(即**DMA读写事务**), 在DMA读写下**CPU不参与**, 也就**不能**为这个读写内存提供**地址转换**, VMM单纯依赖CPU来监控设备访问是比较难的.

于是, **基于PCI总线域(！！！**)的**虚拟化**需要提供支持, **VT\-d**就是为解决这个提出的. VT\-d的其中一个重要功能就是进行**DMA remapping(DMA重新映射**), DMA remapping机制在**芯片组或PCI设备(！！！**)上实现**地址转换(！！！**)功能, 其原理和分页机制下的**虚拟地址转换到物理地址**是相似的.

**DMA remapping**需要**识别设备的source\-id**, 这个source\-id代表着**发起DMA访问设备(即requester, 请求者)的身份**, 实际上它就是**PCI总线域的ID(！！！**), 由**bus、device和function组成**. 根据**source\-id**找到设备**对应的页表(！！！**)结构, 然后**通过页表进行转换**.

如图, 首先, 一个被称为**Root\-entry table(！！！**)的结构需要在**内存中构造(！！！**), 由**Root\-entry**指出**Context\-entry table(！！！**), 再由**context\-entry**得到**页表结构(！！！**), 最后**经过页表**得到最终的**物理地址**.

![config](./images/2.png)

**Root\-entry table的基址**被提供在**MCH(Memory Control Hub！！！**)部件, 一般位于**Bus0、Device0、Function0设备(内存控制器！！！**)扩展空间里的**MEREMAPBAR寄存器(！！！**), 在**这个寄存器**提供一个**remap MMIO空间**, 其中的**RTADDR\_REG寄存器(！！！**)提供**Root\-entry table指针值**, 但不同处理器, 这个remap MMIO空间的基址也存放在**不同的位置**.

DMA remapping提出了一个**domain(域**)的概念, 实际上就是为**设备**在内存中分配一个**对应的区域**. 例如, 为**设备1**分配**domain 1**, 为设备2分配domain 2, 它们访问各自独立的区域. 这个domain值可能被用作标记, 处理器使用它来标记内部的cache. 当然, 不同的设备也可以访问同一个domain, 但必须使用同一个domain值.
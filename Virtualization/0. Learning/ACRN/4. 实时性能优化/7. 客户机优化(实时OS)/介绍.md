
在嵌入式虚拟化环境下运行实时操作系统 (即 RT V M) 与在物理机上直接运行操作系统还是有区别的. 正如前面所述, 单靠 Hypervisor 层的支持无法完全避免 VM Exit 的产生. 因此在 RTVM 运行实时任务的过程中, 其余的 VM 和 VMM 要尽量避免对运行实时任务的 RTVM 产生干扰, 避免增加不确定性和额外的延时. 另外, RTVM 内部的程序设计也要做好配合和支持. 下面以 ACRN 为例, 在 RTVM 执行实时任务时需要注意以下优化事项.

* 避免执行某些特殊指令, 如 HALT, CPUID 等, 这些指令会导致 CPU 陷入 VMM 中去执行 VMM 中的处理流程.

* 也要避免访问一些特殊 MSR, 如 MTTR/PAT,TSC 相关的 MSR, 也会导致 CPU 陷入 VMM 中.

* 要避免访问 Port I/O. 另外, 对于 MMIO 除了直通的物理设备外, 模拟的设备也要避免访问, 同样会导致 CPU 陷入 VMM, 甚至还会到 Service VM 的 ACRN 设备模型中进行处理, 从而带来更多的不确定性.

* 实时任务要避免对非实时核发送处理器间中断(IPI), 避免非实时核的处理延时导致实时核的不确定性. 一般来说, 发送 IPI 的核会导致发送核产生 VM Exit. 如果把 APIC 寄存器都直通给实时核, 则有可能导致安全问题, 导致实时核可随意向其他物理核发送 IPI.

除上面的注意事项外, 还有一些配置优化项也要特别注意.

* 如果 RT V M 有实时的核和非实时的核, 则可以把外部中断服务移到非实时核上来处理; 如果有模拟的设备, 也可以将相关任务移到非实时的核上, 如 virtio-block 的访问.

* 要避免共享数据的非对齐访问, 如果是 ARM 平台本身会产生异常, 在开发测试阶段就会及时发现; 因为 x86 平台本身支持非对齐的数据访问, 所以不会出错, 但是可能会导致内存总线锁 (split-lock) 的问题, 即有一类特殊的非对齐访问, 占用了两个高速缓存行(cache line), 这种可能会让处理器先读取多个高速缓存行, 然后再做真正的加载或存储操作. 如果这里的操作是原子操作, 处理器需要保证数据的一致性, 会首先对系统总线进行锁操作, 这部分导致总线竞争问题, 从而会带来较长的延时.

* 在目前的 Intel 处理器上, 如果发生 split-lock 的情况, 会产生一个 #AC(Assign Check)异常, 可在 ACRN Hypervisor 中把警告信息打出来, 在开发测试阶段就可以发现这种问题, 从而进行规避. 另外, ACRN 目前也支持对产生 #AC 异常的指令的模拟, 避免对内存总线进行锁操作, 减轻了 #AC 异常带来的延时. 但对实时系统而言, 最好避免这种情况的发生.

* 此外还有 Hypervisor 对共享缓存的操作指令 wbinvd 的模拟支持. 因为每个 VM 均可以执行 wbinvd 的指令, 所以可能对其他 VM 包括 RTVM 有较大的性能影响, 因此在 Hypervisor 中会实现对 wbinvd 指令的模拟: 使用 clflush 指令操作对应的 VM 用到的物理内存空间.

实时操作系统自身的配置优化, 可以参考第 8 章.

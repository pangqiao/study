
如果没有内核级别的任何抢占, 则实际上不可能有任何级别的实时 Linux.PREEMPT_RT 的发展一直以 100% 可抢占的内核为目标.

在 Linux 2.4 以及更早的版本中, Linux 的内核调度器只支持用户态抢占. 在此种模式下, 用户态的某个运行中的进程的时间片可以被一个更高优先级的进程抢占, 而内核只在特定时间点检测是否有更高优先级的进程产生. 配置选项 CONFIG_PREEMPT_NONE 指的是用户态抢占. 用户态抢占在大多数情况下能提供良好的延时, 但是无法满足工业需要的确定性的保证, 所以用户态抢占往往用于服务器和科学计算系统等.

从 Linux 2.6 开始, Linux 内核调度器开始允许内核态的抢占. 其本质是在原有用户态的抢占基础上, 增加了更多的内核抢占检查点. 根据不同的可抢占度(preemptibility),PREEMPT_RT 的实时模式可以细分为以下 4 种.

* 内核态自愿抢占 (CONFIG_PREEMPT_VOLUNTARY): 此模式采用白名单机制, 内核在关键位置提供了明确的抢占点, 通过显式调用 might_resched() 来决定要不要调度更高优先级的进程以减少延迟. 由于要进行权衡以减少最大调度延迟并实现对交换事件的最快响应, 因此会损失部分吞吐量. 一般多用于个人桌面系统.

* 内核态低延迟抢占 (CONFIG_PREEMPT): 此模式采用黑名单机制, 在中断禁用区以外的任何地方都可以实现抢占, 比如在 Spinlock,preempt_disable() 和 preempt_enable()等包含的区间. 内核态低延迟抢占主要用于毫秒级别延迟需求的桌面或者嵌入式系统.

* 基本实时内核(PREEMPT_RT): 这种模型基本上和内核态低延迟抢占相同, 但是开启了完全抢占内核的初步修改.

* 内核态实时抢占 (CONFIG_PREEMPT_RT): 此模式最重要的新增特性是删除了大部分不可抢占的自旋锁. 所有实时功能都可以通过 CONFIG_PREEMPT_RT 配置标志启用. 应用并启用实时补丁后, spinlock_t 和 rwlock_t 类型变为可抢占式, 而 raw_spinlock_t 就像普通的自旋锁一样. 另外所有休眠的互斥体都被替换为实现优先级继承的 rt_mutex 类型, 以及信号量. 该补丁显著提高了内核的可抢占性, 使中断处理程序的上半部分和 raw_spinlock_t 受保护的关键区域成为唯一仍然不可抢占的部分. 这提高了系统的响应速度, 减少了延迟并提高了可预测性. 但是, 它会增加上下文切换和资源争用的数量, 从而降低吞吐量. 这种内核态主要用于延迟要求更低的(100μs 或以下) 的实时系统.
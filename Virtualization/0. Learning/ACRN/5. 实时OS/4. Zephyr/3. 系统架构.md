
与大多数实时操作系统不同, Zephyr 不仅提供操作系统的内核, 同时也包含应用开发所需要的其他关键服务, 例如 TCP/IP 协议栈, MTQQ 协议栈, CAN 协议栈等. 同时, Zephyr 也是一个高度可定制化的系统, 所有的组件都可配置化, 应用开发者可以根据自己的需求选择组件, 避免包含不需要的组件, 从而充分优化系统资源, 节省硬件资源.

考虑到嵌入式设备以及 IoT 设备的硬件多样性, Zephyr 支持几乎所有主流 CPU 架构, 包含:

* ARC EM 和 HS.

* ARMv6-M,ARMv7-M 和 ARMv8-M(Cortex-M).

* ARMv7-A 和 ARMv8-A(Cortex-A,32 位和 64 位)​.

* ARMv7-R(Cortex-R).

* Intel x86(32 位和 64 位)​.

* NIOS II Gen 2.

* RISC-V(32 位和 64 位)​.

* SPARC V8.

* Tensilica Xtensa.

如图 8-7 所示, Zephyr 实时操作系统主要由三层组成: 内核 (kernel) 层, 操作系统服务 (OS Service) 层和应用服务 (Application Service) 层. 接下来的章节, 我们将基于 Zephyr 2.6 版本讨论每层的细节.



# 内核层

Zephyr 内核是整个系统的核心, 它构建了一个低内存占用, 高效和多线程的运行环境. Zephyr 系统其他部分, 例如驱动程序, 网络协议栈, 应用程序等, 全都依赖于内核提供的服务. 内核主要提供以下基础操作系统服务.

* 线程服务: 提供线程创建, 终止, 删除和调度接口. 在 Zephyr 里面, 每一个线程的所有信息被保存在一个内核对象中.

* 线程调度服务: 基于调度算法决定被运行的线程. 内核总是选择优先级最高的线程运行, 当多个线程的优先级相同时, 等待时间最长的线程将被运行. 但是, 中断服务程序总是能打断线程的运行, 除非中断被屏蔽.

* 系统线程: 内核启动过程中默认启动两个线程, 即内核主线程和空闲 (idle) 线程. 内核主线程负责内核的初始化以及调用应用程序的 main()函数. 空闲线程是一个必须被创建的线程, 否则将产生系统异常. 当系统没有其他的线程需要运行时, 空闲线程将被运行.

* 工作队列线程: 内核为工作队列创建一个专门的线程, 用于处理工作队列中的任务. 用户可以通过内核提供的工作队列机制, 方便地创建队列, 添加任务. 工作队列线程将依据先进先出的原则处理工作队列中的任务.

* 中断处理: 为用户提供响应硬件和软件中断的机制.

* 轮询等待服务: 提供使线程等待一个或者多个条件被满足的服务. 该服务作用于 Zephyr 的内核对象, 例如 FIFO 内核对象, 信号量内核对象, 信号对象等.

* 信号量(Semaphore): 提供内核信号量对象以便于多线程的同步. 同时, 提供相应的信号量的操作接口.

* 互斥(Mutex): 提供互斥内核对象以及相应的操作接口, 使多线程能安全地同时访问共享的硬件或者软件资源.

* 条件变量(Condition Variable): 提供一种同步机制, 通常用于控制共享资源的访问, 它允许一个线程等待其他线程创建共享资源需要的条件.

* 多处理器架构支持(SMP): 提供对多 CPU 架构的支持. 线程能运行在任意处理器上, 用户不需要对于某一处理器做特殊的处理.

线程之间的数据传送以及共享是操作系统必须提供的核心功能之一. Zephyr 内核提供了丰富的线程间传输共享方式, 能满足不同应用场景的需要. 应用程序开发者可以根据自己的需求选择合适的数据传输共享方式. 目前, Zephyr 主要支持以下几种数据传输方式.

* 队列(Queue): 一个队列在 Zephyr 中是一个内核对象, 内核提供操作该对象的相应接口. 队列可以用于线程之间或者线程与中断处理之间的数据传输和共享.

* 先入先出 (FIFO) 队列: 一种特殊形式的队列, 同时是一个内核对象. 它的实现基于普通队列, 最先被加入队列的元素将先被取出, 内核提供先入先出队列的操作方法. 它可以用于线程之间或者线程与中断处理之间的数据传输和共享.

* 后入先出 (LIFO) 队列: 一种特殊形式的队列, 同时是一个内核对象. 它的实现基于普通队列, 最后被加入队列的元素将先被取出, 内核提供后入先出队列的操作方法. 它可以用于线程之间或者线程与中断处理之间的数据传输和共享.

* 栈(Stack): 一种特殊形式的队列, 同时是一个内核对象. 它的实现基于普通队列, 最后被加入队列的元素将先被取出, 内核提供堆栈的操作方法. 它可以用于线程之间或者线程与中断处理之间的数据传输和共享.

* 消息队列(Message Queue): 一个内核对象. 内核提供消息队列的操作方法. 它可以用于线程之间或者线程与中断处理之间的数据传输和共享.

* 邮箱(Mailbox): 一个内核对象. 内核提供邮箱内核对象的操作方法. 它主要用于线程间的数据传输和共享, 适合于大数据的数据交换, 同时它支持同步和异步模式.

* 管道(Pipe): 一个内核对象. 内核提供管道对象的操作方法. 管道基于流数据的传输, 适应于大数据传输, 同时它支持同步和异步模式. 内存管理是操作系统的另一个核心功能. Zephyr 主要提供以下两种内存管理方式.

* 堆 (Heap) 内存管理: 内核提供丰富的接口对于堆内存进行管理. 堆内存通过两种方式定义: 静态定义和动态定义. 静态定义使堆的大小在编译时确定, 动态定义可以使堆的大小可以在应用程序运行时确定.

* slab 内存管理: 主要用于固定大小的内存进行分配和释放. 由于内存分配的大小是固定的, 内存操作的性能相较于堆内存管理更有优势, 同时能避免内存碎片的产生. 时间和定时器直接决定了操作系统的性能和实时性, 对于实时操作系统尤为重要.

* 时间: Zephyr 内核为用户提供健壮, 可扩展的时间框架. 基于此框架, 用户可以方便地从硬件时钟获得并计算时间.

* 定时器: 定时器在内核中由一个内核对象表示, 内核提供丰富的接口便于用户创建, 使用, 停止定时器.
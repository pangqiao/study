
本节将介绍 Zephyr 的实现细节. 本书并不是一本专门介绍 Zephyr 的书籍, 这里只介绍与实时性相关的关键部分, 使读者能对 Zephyr 实时性相关的实现有一个详细的了解. 如果读者想了解 Zephyr 更多信息, 请考虑 Zephyr 官方文档.

Zephyr 项目在线文档: https://docs.zephyrproject.org/latest

# 线程

线程是用于实现应用程序部分功能的独立可调度指令的集合, 主要用于处理由于执行时间太长或者太复杂而不能在中断服务例程 (Interrupt Service Routine,ISR) 内执行的任务. 在 Zephyr 中, 应用程序可以定义任意数量的线程, 并且可以通过使用创建线程时给该线程分配的线程标识符来引用该线程.

线程包括如下关键属性.

* 栈区域: 一段用于线程控制块和线程栈的内存区域. 栈空间的大小可以被裁剪, 以适应线程处理的实际需求.

* 入口函数: 线程启动时调用的函数, 该函数最多能接收 3 个参数.

* 调度优先级: 指示内核的调度器如何给该线程分配 CPU 时间.

* 线程选项: 允许内核在特定场景中对该线程做某种特殊处理.

* 启动延时: 指定线程在启动前需要等待的时间.

线程必须先创建再使用. 创建线程时, 内核将初始化线程栈区域的控制块区域以及栈的尾部, 栈区域的其他部分通常都是未初始化的. 如果指定的启动延时是 K_NO_WAIT, 内核将立即启动线程, 也可以指定一个超时时间, 让内核延迟启动该线程. 例如, 让线程需要使用的设备就绪后再启动线程. 如果延迟启动的线程还未启动, 内核可以取消该线程. 如果线程已经启动了, 则内核在尝试取消它时不会有任何效果. 如果延迟启动的线程被成功地取消了, 它必须被再次创建后才能再次使用.

线程一旦被启动, 它通常会一直运行下去. 不过, 线程也可以从入口函数中返回, 从而同步结束执行, 这种结束方式叫作正常结束. 正常结束的线程需要在返回前释放它所拥有的共享资源, 例如互斥量, 动态分配的内存等, 因为内核不会自动回收这些资源. 线程也可以通过异常终止异步结束其执行. 如果线程触发了一个致命错误 (例如引用了空指针)​, 内核将自动终止该线程. 其他线程(或线程自己) 也可以调用 k_thread_abort()终止一个线程. 不过, 更优雅的做法是向线程发送一个信号, 让该线程自己结束执行. 线程终止时, 内核不会自动回收该线程拥有的共享资源.

如果一个线程被挂起, 它将在一段不确定的时间内暂停执行. 函数 k_thread_suspend()可以用于挂起包括调用线程在内的所有线程, 对已经挂起的线程再次挂起时不会产生任何效果. 线程一旦被挂起, 它将一直不能被调度, 除非另一个线程调用 k_thread_resume()取消挂起. 线程可以使用 k_sleep()睡眠一段指定的时间. 不过, 这与挂起不同, 睡眠线程在睡眠时间完成后会自动运行.

Zephyr 内核支持一系列线程选项, 以允许线程在特殊情况下被特殊对待, 这些与线程关联的选项在线程创建时就被指定了. 不需要任何线程选项的线程的选项值是零. 如果线程需要选项, 可以通过选项名指定, 如果需要多个选项, 使用符号 "|" 作为分隔符, 支持的选项如下.

* K_ESSENTIAL: 该选项将线程标记为必需线程, 表示当该线程正常结束或异常终止时, 内核将认为产生了一个致命的系统错误. 默认情况下, 一般线程都不是必需线程.

* K_FP_REGS 和 K_SSE_REGS: 这两个选项是与 x86 相关的选项, 分别表示线程使用 CPU 的浮点寄存器和 SSE 寄存器, 指示内核在调度线程进行时需要采取额外的步骤来保存 / 恢复这些寄存器的上下文. 默认情况下, 内核在调度线程时不会保存 / 恢复这些寄存器的上下文.

# 线程调度

Zephyr 内核的调度器是基于优先级的, 它允许应用程序的多个线程共享 CPU. 调度器的主要作用是判断将要执行哪个线程, 被调度器选定的线程叫作当前线程. 无论什么时候, 当调度器改变当前线程的标识符或者当前线程被 ISR 运行所替代时, 内核都会先保存当前线程的 CPU 寄存器值. 当这个线程在之后恢复执行时, 这些寄存器的值就会被恢复. 如果一个线程没有阻碍其执行的因子, 就被认为是就绪的. 就绪的线程可以被选择作为当前线程.

如果一个线程有一个或多个阻碍其执行的因子, 就被认为是非就绪的. 非就绪的线程不能被选择作为当前线程.

下列因素将使线程成为非就绪线程.

* 线程还未被启动.

* 线程正在等待某个内核对象(例如, 现在正在获取一个无效的信号量)​.

* 线程正在等待超时服务.

* 线程被挂起.

* 线程已经结束或终止.

线程的优先级是一个整数值, 可以是负数或者非负数. 数字越小, 优先级越高. 例如, 如果线程 A 的优先级是 4, 线程 B 的优先级是 7, 调度器则认为 A 的优先级比 B 的优先级高; 同样地, 如果线程 C 的优先级是 - 2, 则它的优先级比 A 和 B 都高.

调度器基于线程的优先级将线程分为以下两类.

* 协作式线程: 优先级为负数的线程. 这样的线程一旦成为当前线程, 它将一直执行下去, 直到它采取的某种动作导致自己变为非就绪线程.

* 抢占式线程: 优先级为非负的线程. 这样的线程成为当前线程后, 它可以在任何时刻被协作式线程或者优先级更高 (或相等) 的抢占式线程替代. 抢占式线程被替代后, 它依然是就绪的.

线程的初始优先级值可以在线程启动后动态地增加或减小. 因此, 通过改变线程的优先级, 抢占式线程可以变为协作式线程, 或者相反. 内核几乎可以支持无数个优先级等级. 配置选项 CONFIG_NUM_COOP_PRIORITIES 和 CONFIG_NUM_PREEMPT_PRIORITIES 指定了这两种线程的优先级的范围.

* 协作式线程:(-CONFIG_NUM_COOP_PRIORITIES)至 - 1.

* 抢占式线程: 0 至(CONFIG_NUM_PREEMPT_PRIORITIES-1).

内核的调度器总是选择优先级最高的就绪线程作为当前线程. 当多个线程具有相同的优先级时, 调度器选择等待时间最长的线程. ISR 优先于线程, 因此当前线程可能会在任何时刻被非屏蔽中的 ISR 代替, 这对协作式线程和抢占式线程都成立.

协作式线程一旦成为当前线程, 它将一直执行下去, 直到它采取的某种动作导致自己变为非就绪线程. 这种方式其实有一个缺陷, 即如果协作式线程需要执行长时间的计算, 将导致包括优先级高于或等于该线程在内的其他所有线程的调度被延迟到一个不可接受的时间之后. 为了解决这个问题, 协作式线程可以自身间或性地放弃 CPU, 让其他线程得以执行. 线程放弃 CPU 的方法有以下两种.

* 调用 k_yield()将线程放到调度器维护的按照优先级排列的就绪线程链表中, 然后调用调度器. 在该线程被再次调度前, 所有优先级高于或等于该线程的就绪线程都将得以执行. 如果不存在优先级更高或相等的线程, 调度器将不会进行上下文切换, 立即再次调度该线程.

* 调用 k_sleep()让该线程在一段指定时间内变为非就绪线程. 所有优先级的就绪线程都可能得以执行; 不过, 不能保证优先级低于该睡眠线程的其他线程都能在睡眠线程再次变为就绪线程前执行完.

抢占式线程成为当前线程后, 它将一直执行下去, 直到有更高优先级的线程变为就绪线程, 或者线程自己执行了某种动作导致其变为非就绪线程. 相应地, 如果抢占式线程需要执行长时间的计算, 将导致包括优先级等于该线程在内的其他所有线程的调度被延迟到一个不可接受的时间之后. 为了解决这个问题, 可抢占式线程可以执行协作式时间片 (如上面所述) 或者使用调度器的时间片功能, 让优先级等于该线程的其他线程得以执行. 调度器将时间分割为一系列的时间片. 时间片的大小是可配置的, 并且可以在程序运行期间修改. 在每个时间片结束时, 调度器会检查当前线程是否是可抢占的. 如果是, 它将对该线程隐式地调用 k_yield(), 让其他同优先级的就绪线程在该线程被再次调度前得以执行; 否则, 当前线程继续执行.

优先级高于指定极限的线程不用实现抢占式时间片, 且不能被同优先级的其他线程抢占. 应用程序只有处理优先级更低且对时间不敏感的线程时才采用抢占式时间片. 内核的时间片算法不确保同等优先级的所有线程占用的 CPU 时间完全相同, 因为它不会测量线程的实际执行时间. 例如, 某个线程可能在时间片快完的时候才刚刚执行, 但是时间片到后会立即释放 CPU. 尽管如此, 该算法将确保某个线程的执行时间超过单个时间片的长度后释放 CPU(当然, 也可能释放 CPU 后不进行上下文切换而立即再次执行)​.

如果抢占式线程希望在执行某个特殊的操作时不被抢占, 它可以调用 k_sched_lock(), 让调度器将其临时当作协作式线程, 从而避免被抢占. 一旦完成特殊操作, 该线程必须调用 k_sched_unlock(), 以恢复其可抢占特性. 如果线程调用了 k_sched_lock(), 但是随后执行了一个动作导致其非就绪, 调度器会将这个锁定的线程切换出去, 以允许其他线程得以执行. 当锁定的线程再次成为当前线程后, 其不可抢占状态依然有效.

线程可以调用 k_sleep()让其延迟一段指定的时间后再执行. 在线程睡眠的这段时间, CPU 被释放给其他线程. 到达指定的时间后, 线程将变为就绪状态, 然后才能够再次被调度. 正在睡眠的线程可以被其他线程使用 k_wakeup()唤醒. 这种技术可以让其他线程给该睡眠线程发送信号, 而睡眠线程不需要请求某个内核对象(例如信号量)​. 唤醒一个未睡眠的线程也是允许的, 但是不会有任何效果.

线程可以调用 k_busy_wait()执行一个忙等待操作. 所谓的忙等待, 指的是线程延迟一段指定的时间后再处理相关任务, 但是它并不会将 CPU 释放给其他就绪线程. 使用忙等待而不使用线程睡眠的典型情况是: 由于所需要的延迟太短, 因此调度器来不及从当前线程切换到其他线程再切换回当前线程.

# 中断

中断服务例程 (ISR) 是一个异步响应硬件或者软件中断的函数. ISR 通常会抢占当前正在执行的线程, 以达到快速响应的目的. 只有当所有的 ISR 工作都完成后, 线程才能得以恢复执行. 理论上, 用户可以定义任意数量的 ISR, 但是它的实际个数会受到硬件的限制.

ISR 的关键属性如下.

* 中断请求 (Interrupt Request,IRQ) 信号: 触发 ISR 的信号.

* 优先级: 与 IRQ 绑定在一起的优先级.

* 中断处理函数: 用于处理中断的函数.

* 参数值: 传递给函数的参数.

中断描述符表 (IDT) 或者向量表用于将一个给定的 ISR 与一个给定的中断源关联在一起. 在任意时刻, 一个 IRQ 只能与一个 ISR 关联. 多个 ISR 可以利用同一个函数来处理中断, 这样做的好处是允许一个函数可以同时服务于某个设备产生的多种不同类型中断, 甚至服务于多个设备 (通常是同种类型的) 产生的中断. 传递给 ISR 的参数值可以用于判断具体是哪一个中断源产生了信号. 内核为所有未使用的 IDT 入口提供了一个默认的 ISR. 如果发生了意外的中断, 该 ISR 将产生一个致命的系统错误.

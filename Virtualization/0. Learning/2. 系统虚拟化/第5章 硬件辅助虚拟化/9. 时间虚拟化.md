
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 操作系统的时间概念](#1-操作系统的时间概念)
- [2. 客户机的时间概念](#2-客户机的时间概念)
- [3. 时钟设备仿真](#3-时钟设备仿真)
  - [3.1. 客户机不会被调度出去的情况](#31-客户机不会被调度出去的情况)
    - [3.1.1. PIT的时钟中断](#311-pit的时钟中断)
    - [3.1.2. PIT的时钟计数器](#312-pit的时钟计数器)
  - [3.2. 客户机被调度出去的情况](#32-客户机被调度出去的情况)
    - [3.2.1. 实现客户机时间概念的一种方法 --- 丢失中断连续注入](#321-实现客户机时间概念的一种方法-丢失中断连续注入)
    - [3.2.2. 实现客户机时间概念的另一种方法](#322-实现客户机时间概念的另一种方法)
      - [3.2.2.1. 上面方法的缺陷](#3221-上面方法的缺陷)
      - [3.2.2.2. 另一种方法 --- 计数器修正](#3222-另一种方法-计数器修正)
- [4. 如何满足客户机时间不等于实际时间的需求](#4-如何满足客户机时间不等于实际时间的需求)

<!-- /code_chunk_output -->

# 1. 操作系统的时间概念

- 绝对时间(Wall Time): 又称墙上时间. 即OS启动后到目前为止的总运行时间, 它是一个单调递增的值

- 相对时间: 两个时间之间的间隔. 

从前面知道, **硬件定时器如RTC、PIT或HPET**等都能以**某种频率**触发**时钟中断**, 触发**频率**可以由**软件编程控制**. 通常, OS会将**频率设定**为一个**给定的值**(例如10ms), 从而可以知道**两次时钟中断之间的时间差**(本例中是10ms). 同时, 硬件定时器也会提供**计数器(Counter**)的功能, OS可知两次读取计数器之间的时间差, 从而得到相对时间概念.

OS在启动时候**读取CMOS**的**实时时钟**, 或通过**NPT协议**, 得到系统启动时的**绝对时间**. 同时, **系统**通过维护**相对时间**, 可知系统总运行的事件, 从而OS可得到任意时刻点的绝对时间, 如下公式:

当前绝对时间 = 系统启动时的时间 + 系统启动后运行的时间

图5\-222描述OS的时钟概念. 系统在时间t0时候启动, 当实际时间到达t1的时候, 系统内部维护的运行时间为t1 \- t0, 而系统内部的绝对时间为t0+(t1-t0), 从而保证了内存时间与实际时间的一致性. 每次时钟中断发生时(t1、t2、t3等), OS都会更新内部的时间概念. 而在t1 \~ t2时间内, OS可通过读时间设备的计数器得到相对时间.

![config](./images/34.png)

# 2. 客户机的时间概念

在**硬件辅助的虚拟环境**下, 客户机OS仍然需要维护正确地时间概念, 包括**相对时间**和**绝对时间**. 这意味着**VMM**需要为客户机提供**系统硬件时钟设备的仿真**, 包括**PIT**、**HPET**和**TSC**等. 

**虚拟环境**下, **不同客户机**和**VMM共享物理平台**, 客户机只能得到部分处理器时间.

图5-23和图5\-24给定不同的客户机时间概念的实现. 

假定客户机在t1时刻处于运行状态, t2的时候被调度进入睡眠状态, t3时候重新被调度执行, 直到t5时候被再次调度出去. 如果客户机内的某一个程序(操作系统内核或应用程序)希望得到t4和t1之间的相对时间, 那么返回值应该是多少?

显然, **不同情况**, 返回值应该是不相同的, 考虑下面两种应用.

⓵ 进程记账: 主要用于统计某一个进程的执行时间. 就不能包含被调度出去的时间.

⓶ 网络速度检测程序: 网络速度检测程序通过计算发送数据包和收到应答包的时间. 

![](./images/2019-04-16-10-05-22.png)

![](./images/2019-04-16-10-05-31.png)

实际需求中, 多数应用是网络速度检测这样的应用, 因此, 通常时间虚拟化的策略都是给客户机呈现与实际时间相同的事件概念. 后面讨论基于客户机时间与实际时间相等的情况, 不等的情况会在最后简单介绍.

OS通过系统中**时钟设备**(包括PIT、HPET和TSC等)得到自己的**绝对时间**或**相对时间**, 因此首先介绍**时钟设备虚拟化的实现方法**, 然后再讨论**如何给客户机提供与实际时间相等的时间**.

# 3. 时钟设备仿真

x86系统中**时间设备**包括**PIT**、**HPET**、**ACPI PM Timer**和**TSC**等。

这里以PIT为例, 先介绍客户机不会被调度出去的情况, PIT设备如何虚拟化. 下节介绍客户机被调度出去的情况.

第2章说过, PIT主要功能是为OS提供定时的**时钟中断！！！**和**时钟计数器！！！**. OS对PIT设备的**I/O端口读写**, 设定时钟中断的**触发频率**, 设置和读取**时钟计数器**.

为实现时间设备的虚拟化, **VMM**必须提供**软件定时器机制**, 使得程序可以在**设定的某个未来时间执行一段代码**, 同时还提供**接口**, 使得程序可以了解**当前的实际时间**.

## 3.1. 客户机不会被调度出去的情况

### 3.1.1. PIT的时钟中断

假定**客户机OS**设定PIT时钟**中断频率**为10ms, VMM截获这个设定(截获方法参考**I/O虚拟化**), 并通知**PIT设备模型**. 

**PIT设备模型**会**向VMM！！！注册**一个间隔为10ms的**软件定时器！！！**, 并提供**回调函数**, 这个**函数功能**就是向**客户机注入一个时钟中断！！！**.

在**客户机不被调度出去！！！** 的情况下，每隔10ms，**VMM！！！**都会**调用这个回调函数！！！** 向客户机**注入一个时钟中断**。

具体中断注入参考中断虚拟化相关章节.

### 3.1.2. PIT的时钟计数器

当客户机**读取PIT**的**Counter寄存器**时, **PIT设备模型**通过VMM了解当前的**实际时间！！！**, 并**减去PIT的事件计数器**被初始化时的实际时间, 以得到**流逝时间**, 经过**PIT频率转换**后返回给客户机.

**HPET**和**ACPI PM Timer**, 基本方法相同, 不同点在于, **客户机**读取**PIT**通过**IO实现**, 而这两个是**MMIO截获**实现. 同时, 各个时间设备的**中断号不同**.

由于OS可依赖**多个时钟设备**实现内部时间的维护, 因此, 当VMM提供**多个时钟设备的仿真**时, 需要保证**各个设备模型**之间的**时间一致性**.

## 3.2. 客户机被调度出去的情况

下面讨论当**客户机被调度出去**的情况下, 如何通过**设备仿真**实现**客户机的时间概念**, 以使**客户机时间等于实际的时间**. 

图2-25 客户机被调度出去情况下时间概念的实现:

![2019-12-12-17-37-25.png](./images/2019-12-12-17-37-25.png)

如图5\-25, 假定客户机在t2时候被调度出去, 在t5被调度进来. 

这个过程中, 根据客户机OS对**虚拟PIT**的设置, 在**t3**和**t4**需要**插入时钟中断**, 以使得客户机OS能维持内部的时间计数. 然而, t3和t4时候客户机并没有运行, 因此, **VMM没有机会**将**中断注入给客户机**.

### 3.2.1. 实现客户机时间概念的一种方法 --- 丢失中断连续注入

通常做法是, 当客户机在**t5时刻！！！** 被调度回来, **VMM**连续将**t3、t4时刻丢掉**的两个**时钟中断连续！！！注入**客户机. "连续"指, 当客户机处理完**t3的时钟中断！！！** 后, 立刻把t4时刻的时钟中断注入给客户机, 在客户OS看来就是在一个**时钟中断处理**完后另一个时钟中断**紧接着发生**了. 由于这个过程没有其他的程序被运行, 因此, 当应用程序会内核中需要时间服务的程序运行的时候, t3和t4丢失的时钟中断都已补偿给客户机了. 这样, VMM保证了**客户机内部的时间！！！**与**实际时间一致！！！**. 

当然, 如果在**OS的时钟中断函数**中, 有**需要时钟服务的代码**运行, 那么这些代码仍然会**得到不正确的时间**. 但, OS为保证中断的快速反应, 通常并不会出现这种情况.

图5\-26给出实现这一过程的示意. 当客户机在t5时刻被调度运行时, VMM立刻注入t3'时刻的时钟中断给客户机, 使得客户机的时钟概念跳变到t3', 客户机在t5'时候执行完t3'中断的中断处理函数后, VMM立刻注入t4'时刻的时钟中断, 使得客户机时钟跳变到t4'. 由于客户机处理函数执行速度很快, 因此(t5' \- t5)远远小于(t6 \- t5).

图2-26 客户机被调度出去情况下中断注入的微观示意图:

![2019-12-12-17-40-45.png](./images/2019-12-12-17-40-45.png)

设备模型中**计数器**的实现. 图5\-26中, 在t5'后, 由于所有中断都已经被注入到客户机内, **客户机的时钟**已经调整到和**实际时间一致**, 设备模型中计数器的值与实际时间也是一致的. 而在**t5到t5'**的过程中, 由于**客户机的时钟概念仍然停留在t3时刻**, 因此计数器的返回值也应该在t3和t4之间. 由于t5到t5'的时间非常短, 因此, 具体在t3和t4之间的那个点依赖具体实现.

### 3.2.2. 实现客户机时间概念的另一种方法

#### 3.2.2.1. 上面方法的缺陷

上面方法存在一些问题. 

例如, 

- 由于把客户机调度出去时的时钟中断补偿给客户机, 因此它对系统性能会有影响, 特别是运行客户机比较多的时候, 时钟中断的补偿会消耗很多的时间. 

- 其次, 在SMP情况下, **各个VCPU**之间tsc的同步存在一些问题.

#### 3.2.2.2. 另一种方法 --- 计数器修正

前面说到, 时钟虚拟化的主要目的是保护客户机内部时间概念的正确性, 因此, 可以针对OS特定的时间概念维护机制, 修改VMM时间虚拟化的方法. 

这里给另外一个方法.

在硬件平台上, 虽然时钟中断丢失的情况很少见, 但是还存在这种可能的, 通常情况下是因为操作系统关闭中断的时间过长. 然而, 有些OS已经考虑了时钟中断丢失的情况, 在**收到时钟中断**后, 会**读取时钟设备中的计数器**, 并根据计数器的值进行修正. 如图5\-27, 假定OS中没有收到t3时刻的时钟中断, 当t4时刻时钟中断注入的时候(注, 这是物理平台, 所以t3时刻的中断是没有机会补偿给操作系统), 中断处理函数会读取时钟设备中的计数器, 发现和上一次时钟中断的发生已经超过了10ms, 因此, OS会认为自己错过了时钟中断, 并**根据时钟设备中的计数器！！！来修正自己的时钟概念**.

![](./images/2019-04-16-21-37-23.png)

针对**这种OS**, **时钟虚拟化不再需要将错过的中断补偿给客户机！！！**. 

以图5\-25为例, 在t5时刻客户机被重新调度运行的时候, VMM并不需要将t3/t4时刻的时钟中断注入客户机, 而只需要注入一次. 当客户机的时钟中断处理函数读取时钟设备的计数器时, 直接返回实际时间. 客户机OS通过检查计数器返回值, 就可以知道错过了t3/t4的时钟中断, 并将自己的时间概念更新到t5.

# 4. 如何满足客户机时间不等于实际时间的需求

前面讨论了**如何通过设备仿真**, 使**客户机内部的时间概念**与**实际的时间相等**. 然而, 有些应用需要**客户机时间等于客户机实际运行的时间！！！**, 例如**进程记账软件**. 

对于这种需求, 一种做法是在**客户机内部引入PV的时间模块**, 使得**客户机被调度出去的时间**(也就是图5\-25中的t2\~t5)被计算在**PV的时间模块**, 而**不是当前进程**上. 

详细资料参见VMware相关文献.

CPU 从 Guest 切换到 Host 后，VMM 根据寄存器地址，发现是驱动通知模拟设备开始处理 I/O，则将请求转发给具体的模拟设备，以 Virtioblk 为例，其根据写入的队列索引，找到具体的队列，并开始处理驱动的 I/O request：

```cpp
commit a2c8c69686be7bb224b278d4fd452fdc56b52c3c
kvm,virtio: add scatter-gather support
kvmtool.git/blk-virtio.c

struct virt_queue {
	/* The last_avail_idx field is an index to ->ring of struct vring_avail.
	   It's where we assume the next request index is at.  */
	uint16_t			last_avail_idx;
};

static bool blk_virtio_out(struct kvm *self, uint16_t port, void *data, int size, uint32_t count)
{
	unsigned long offset;

	offset		= port - IOPORT_VIRTIO;

	switch (offset) {
    ...
	case VIRTIO_PCI_QUEUE_NOTIFY: {
		struct virt_queue *queue;
		uint16_t queue_index;

		queue_index		= ioport__read16(data);

		queue			= &device.virt_queues[queue_index];

		while (queue->vring.avail->idx != queue->last_avail_idx) {
			if (!blk_virtio_request(self, queue))
				return false;
		}
		kvm__irq_line(self, VIRTIO_BLK_IRQ, 1);

		break;
	}
    ...
}
```

其中结构体avail中的idx指向有效可用描述符区域的头部，设备侧在队列的结构体中定义了一个变量last_avail_id用来记录已经消费的位置，也就是有效可用描述符区域的尾部。函数blk_virtio_out从notify寄存器中读出驱动写的队列索引，找到对应的队列，遍历其可用描述符区域，直到队列为空。blk_virtio_out调用函数blk_virtio_request处理每个可用描述符链。

模拟设备还要在消费完成后负责告知驱动可以进行回收了。因此，设备需要将消费完的描述符链填充到已用描述符区域。设备将消费的描述符链的第1个描述符的ID追加到已用描述符区域的数组ring中，已用描述符数组下标由已用描述符区域的变量idx标识。除了标识设备处理的是哪一个描述链之外，设备还需要更新设备处理的数据长度，以读操作为例，驱动需要知道成功读入了多少数据。

通常情况下，一个可用描述符链包含一个用于描述I/O基本信息的描述符，包括header区域，包括I/O命令（写还是读）、I/O的起始扇区，多个存储I/O数据的数据描述符，接下来我们可以看到代码中使用了一个循环处理数据描述符，以及一个I/O执行的结果的状态描述符。具体处理每个可用描述符链的代码在函数blk_virtio_request中：

```cpp
commit a2c8c69686be7bb224b278d4fd452fdc56b52c3c
kvm,virtio: add scatter-gather support
kvmtool.git/blk-virtio.c

static bool blk_virtio_request(struct kvm *self, struct virt_queue *queue)
{
	struct vring_used_elem *used_elem;
	struct virtio_blk_outhdr *req;
	uint16_t desc_block_last;
	struct vring_desc *desc;
	uint16_t desc_status;
	uint16_t desc_block;
	uint32_t block_len;
	uint32_t block_cnt;
	uint16_t desc_hdr;
	uint8_t *status;
	void *block;
	int err;
	int err_cnt;
	/* header */
	desc_hdr		= queue->vring.avail->ring[queue->last_avail_idx++ % queue->vring.num];
    ...
    desc			= &queue->vring.desc[desc_hdr];

	req			= guest_flat_to_host(self, desc->addr);

	/* status */
	desc_status		= desc_hdr;

	do {
		desc_block_last	= desc_status;
		desc_status	= queue->vring.desc[desc_status].next;
	} while (queue->vring.desc[desc_status].flags & VRING_DESC_F_NEXT);

	desc			= &queue->vring.desc[desc_status];

	status			= guest_flat_to_host(self, desc->addr);

	/* block */
	desc_block		= desc_hdr;
	block_cnt		= 0;
	err_cnt			= 0;

	do {
		desc_block	= queue->vring.desc[desc_block].next;

		desc		= &queue->vring.desc[desc_block];

		block		= guest_flat_to_host(self, desc->addr);
		block_len	= desc->len;
		switch (req->type) {
		case VIRTIO_BLK_T_IN:
			err	= disk_image__read_sector(self->disk_image, req->sector, block, block_len);
			break;
		case VIRTIO_BLK_T_OUT:
			err	= disk_image__write_sector(self->disk_image, req->sector, block, block_len);
			break;
		...
		}

		if (err)
			err_cnt++;

		req->sector	+= block_len >> SECTOR_SHIFT;
		block_cnt	+= block_len;

		if (desc_block == desc_block_last)
			break;

		if (desc_block >= queue->vring.num) {
			return false;
		}

	} while (true);

	*status			= err_cnt ? VIRTIO_BLK_S_IOERR : VIRTIO_BLK_S_OK;

	used_elem		= &queue->vring.used->ring[queue->vring.used->idx++ % queue->vring.num];
	used_elem->id		= desc_hdr;
	used_elem->len		= block_cnt;

	return true;
}
```

对于当前处理的队列，首先需要确认上次设备消费结束的位置。这个位置记录在队列的结构体变量last_avail_idx中。函数blk_virtio_request从队列的结构体中取出变量last_avail_idx，以其为索引，取出准备处理的可用描述符链的头，即第1个描述符。同时，变量last_avail_idx增加了1，也就是说，这个描述符链已经被从有效描述符区域中移除了。描述符中指向存储数据的地址addr为GPA，还需要将GPA转换为Host的虚拟地址HVA，函数guest_flat_to_host就是用来完成这个转换的。

在处理描述符中的数据描述符前，函数blk_virtio_request将记录状态的内存地址也取了出来，最后会将I/O执行的状态写入这个地址。状态描述符位于描述符链的最后，所以会在代码中一直遍历到最后一个描述符。同样的，也需要调用函数 guest_flat_to_host 将存储状态的地址的GPA转换为HVA。

接下来，代码中循环处理数据描述符。对于每个数据描述符，取出其存储数据的地址，并调用函数guest_flat_to_host将存储数据的地址GPA转换为HVA，并取出I/O数据的长度。然后调用虚拟机磁盘镜像相关的函数，根据I/O命令，将数据写入磁盘镜像文件，或者从磁盘镜像文件读入数据。然后更新下一次I/O访问的扇区，即代码中的req-＞sector。由于数据描述符中记录数据长度的变量是以字节为单位的，所以需要转换为以扇区为单位。一旦下一个描述符是状态描述符，则结束数据描述符的处理。

最后，根据I/O处理的结果，填充状态描述符。至此，一个可用描述符链处理完成。

同时，函数blk_virtio_request将这个刚刚处理完的描述符链，记录到已用描述符区域，当CPU从Host切换回Guest后，驱动可以知道哪些I/O request已经被设备处理完成。


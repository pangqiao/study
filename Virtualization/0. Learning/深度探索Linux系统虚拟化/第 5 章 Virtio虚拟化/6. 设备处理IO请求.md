
CPU 从 Guest 切换到 Host 后，VMM 根据寄存器地址，发现是驱动通知模拟设备开始处理 I/O，则将请求转发给具体的模拟设备，以 Virtioblk 为例，其根据写入的队列索引，找到具体的队列，并开始处理驱动的 I/O request：

```cpp
commit a2c8c69686be7bb224b278d4fd452fdc56b52c3c
kvm,virtio: add scatter-gather support
kvmtool.git/blk-virtio.c

struct virt_queue {
	/* The last_avail_idx field is an index to ->ring of struct vring_avail.
	   It's where we assume the next request index is at.  */
	uint16_t			last_avail_idx;
};

static bool blk_virtio_out(struct kvm *self, uint16_t port, void *data, int size, uint32_t count)
{
	unsigned long offset;

	offset		= port - IOPORT_VIRTIO;

	switch (offset) {
    ...
	case VIRTIO_PCI_QUEUE_NOTIFY: {
		struct virt_queue *queue;
		uint16_t queue_index;

		queue_index		= ioport__read16(data);

		queue			= &device.virt_queues[queue_index];

		while (queue->vring.avail->idx != queue->last_avail_idx) {
			if (!blk_virtio_request(self, queue))
				return false;
		}
		kvm__irq_line(self, VIRTIO_BLK_IRQ, 1);

		break;
	}
    ...
}
```

其中结构体avail中的idx指向有效可用描述符区域的头部，设备侧在队列的结构体中定义了一个变量last_avail_id用来记录已经消费的位置，也就是有效可用描述符区域的尾部。函数blk_virtio_out从notify寄存器中读出驱动写的队列索引，找到对应的队列，遍历其可用描述符区域，直到队列为空。blk_virtio_out调用函数blk_virtio_request处理每个可用描述符链。

模拟设备还要在消费完成后负责告知驱动可以进行回收了。因此，设备需要将消费完的描述符链填充到已用描述符区域。设备将消费的描述符链的第1个描述符的ID追加到已用描述符区域的数组ring中，已用描述符数组下标由已用描述符区域的变量idx标识。除了标识设备处理的是哪一个描述链之外，设备还需要更新设备处理的数据长度，以读操作为例，驱动需要知道成功读入了多少数据。

通常情况下，一个可用描述符链包含一个用于描述I/O基本信息的描述符，包括header区域，包括I/O命令（写还是读）、I/O的起始扇区，多个存储I/O数据的数据描述符，接下来我们可以看到代码中使用了一个循环处理数据描述符，以及一个I/O执行的结果的状态描述符。具体处理每个可用描述符链的代码在函数blk_virtio_request中：

```cpp
commit a2c8c69686be7bb224b278d4fd452fdc56b52c3c
kvm,virtio: add scatter-gather support
kvmtool.git/blk-virtio.c

static bool blk_virtio_request(struct kvm *self, struct virt_queue *queue)
{
	struct vring_used_elem *used_elem;
	struct virtio_blk_outhdr *req;
	uint16_t desc_block_last;
	struct vring_desc *desc;
	uint16_t desc_status;
	uint16_t desc_block;
	uint32_t block_len;
	uint32_t block_cnt;
	uint16_t desc_hdr;
	uint8_t *status;
	void *block;
	int err;
	int err_cnt;

	/* header */
	desc_hdr		= queue->vring.avail->ring[queue->last_avail_idx++ % queue->vring.num];
    ...
    desc			= &queue->vring.desc[desc_hdr];

	req			= guest_flat_to_host(self, desc->addr);

	/* status */
	desc_status		= desc_hdr;

	do {
		desc_block_last	= desc_status;
		desc_status	= queue->vring.desc[desc_status].next;
	} while (queue->vring.desc[desc_status].flags & VRING_DESC_F_NEXT);

	desc			= &queue->vring.desc[desc_status];

	status			= guest_flat_to_host(self, desc->addr);

	/* block */
	desc_block		= desc_hdr;
	block_cnt		= 0;
	err_cnt			= 0;

	do {
		desc_block	= queue->vring.desc[desc_block].next;

		desc		= &queue->vring.desc[desc_block];

		block		= guest_flat_to_host(self, desc->addr);
		block_len	= desc->len;
		switch (req->type) {
		case VIRTIO_BLK_T_IN:
			err	= disk_image__read_sector(self->disk_image, req->sector, block, block_len);
			break;
		case VIRTIO_BLK_T_OUT:
			err	= disk_image__write_sector(self->disk_image, req->sector, block, block_len);
			break;
		default:
			warning("request type %d", req->type);
			err	= -1;
		}

		if (err)
			err_cnt++;

		req->sector	+= block_len >> SECTOR_SHIFT;
		block_cnt	+= block_len;

		if (desc_block == desc_block_last)
			break;

		if (desc_block >= queue->vring.num) {
			return false;
		}

	} while (true);

	*status			= err_cnt ? VIRTIO_BLK_S_IOERR : VIRTIO_BLK_S_OK;

	used_elem		= &queue->vring.used->ring[queue->vring.used->idx++ % queue->vring.num];
	used_elem->id		= desc_hdr;
	used_elem->len		= block_cnt;

	return true;
}
```
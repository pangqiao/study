
在完全模拟的场景下，Guest的I/O操作很自然地就会被VMM捕捉到，因为Guest一旦进行I/O操作，将触发CPU从Guest模式切换到Host模式。但是使用了Virtio后，Guest进行I/O时，是利用Virtqueue传输数据，并不会进行如完全模拟那样的I/O操作，CPU不会执行如out或者outs这样的I/O指令，因此不会触发CPU从Guest模式切换到Host模式。

因此，对于使用Virtio标准的设备，不能再依靠I/O指令自然地触发VM exit了，而是需要驱动主动触发CPU从Guest模式切换到Host模式。为此，Virtio标准在Virtio设备的配置空间中，增加了一个QueueNotify寄存器，驱动准备好Virtqueue后，向Queue Notify寄存器发起写操作，从而触发CPU从Guest模式切换到Host模式，KVM拿到控制权后，根据触发I/O的地址，知道是Guest已经准备好Virtqueue了，设备应该开始I/O了。

回到Virtio blk驱动，驱动遍历了request队列后，如果有request，在将request组织为可用描述符链后，驱动将触发CPU从 Guest模式向Host模式切换，代码如下：

```cpp
commit 3343660d8c62c6b00b2f15324ef3fcb6be207bfa
virtio: PCI device
linux.git/drivers/block/virtio_blk.c
static void do_virtblk_request(struct request_queue *q)
{
    ...
	while ((req = elv_next_request(q)) != NULL) {
		vblk = req->rq_disk->private_data;

		/* If this request fails, stop queue and wait for something to
		   finish to restart it. */
		if (!do_req(q, vblk, req)) {
			blk_stop_queue(q);
			break;
		}
		blkdev_dequeue_request(req);
		issued++;
	}

	if (issued)
		vblk->vq->vq_ops->kick(vblk->vq);
}

linux.git/drivers/virtio/virtio_ring.c
static void vring_kick(struct virtqueue *_vq)
{
	...
	vq->vring.avail->idx += vq->num_added;
	vq->num_added = 0;
    ...
	if (!(vq->vring.used->flags & VRING_USED_F_NO_NOTIFY))
		/* Prod other side to tell it about changes. */
		vq->notify(&vq->vq);
}

linux.git/drivers/virtio/virtio_pci.c
/* the notify function used when creating a virt queue */
static void vp_notify(struct virtqueue *vq)
{
	/* we write the queue's selector into the notification register to
	 * signal the other end */
	iowrite16(info->queue_index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY);
}
```

在函数vring_kick中，在触发切换前，驱动更新了可用描述符链中的变量idx，其中num_added是处理的request的数量，也是增加的可用描述符链的数量。驱动同时也向notify寄存器写入了队列的索引，告知设备侧可以处理哪个队列的request了。

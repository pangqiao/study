
当设备处理完I/O request后，需要通过向驱动发送中断的方式通知Guest。事实上，还存在一种驱动阻塞在虚拟机切出的位置同步等待从Host返回的方式，这种方式对于设备可以快速处理的场景，在延迟方面要比中断方式有优势，在这节的结尾我们会用一个代码片段进行展示。

设备侧在处理完I/O request后，将调用kvm__irq_line向Guest发起中断：

```cpp
commit a2c8c69686be7bb224b278d4fd452fdc56b52c3c
kvm,virtio: add scatter-gather support
kvmtool.git/blk-virtio.c

static bool blk_virtio_out(struct kvm *self, uint16_t port, void *data, int size, uint32_t count)
{
    ...
	case VIRTIO_PCI_QUEUE_NOTIFY: {
		...
		while (queue->vring.avail->idx != queue->last_avail_idx) {
			if (!blk_virtio_request(self, queue))
				return false;
		}
		kvm__irq_line(self, VIRTIO_BLK_IRQ, 1);

		break;
	}
    ...
}
```

驱动收到设备通知后，继续后续的操作，比如，之前发起I/O request的任务可能挂起等待数据的到来，对于这种情况，驱动需要唤醒等待读数据的任务。为此，通用块层提供了函数 end_dequeued_request 来执行这些I/O操作的收尾工作，由于函数 end_dequeued_request 的高版本比较复杂，我们以低版本为例，逻辑一目了然：

```cpp
linux-0.10/kernel/blk_drv/blk.h

extern inline void end_request(int uptodate)
{
    if (CURRENT->bh) {
        CURRENT->bh->b_uptodate = uptodate;
        unlock_buffer(CURRENT->bh);
    }
    ...
    wake_up(&CURRENT->waiting);
    ...
}
```

基本上，在收到设备发送的 I/O 中断后，驱动侧需要做 2 件事：

1） 找到设备已经处理完的I/O request，传递给通用块层的 end_dequeued_request通知上层任务。

2） 既然I/O request已经处理完了，request对应的描述符链也就需要退出历史舞台了，因此，从已用描述符区域清除描述符链，将其归还到空闲描述符链中。

Virtio PCI设备注册了中断处理函数vp_interrupt：

```cpp
commit 3343660d8c62c6b00b2f15324ef3fcb6be207bfa
virtio: PCI device
linux.git/drivers/virtio/virtio_pci.c

/* the PCI probing function */
static int __devinit virtio_pci_probe(struct pci_dev *pci_dev,
				      const struct pci_device_id *id)
{
    ...
	/* register a handler for the queue with the PCI device's interrupt */
	err = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,
			  vp_dev->vdev.dev.bus_id, vp_dev);
    ...
}
```

vp_interrupt会调用具体的Virtio设备提供的具体的中断处理函数。比如，Virtio blk驱动注册的中断处理函数为blk_done：

```cpp
commit 3343660d8c62c6b00b2f15324ef3fcb6be207bfa
virtio: PCI device
linux.git/drivers/block/virtio_blk.c

static void blk_done(struct virtqueue *vq)
{
	struct virtio_blk *vblk = vq->vdev->priv;
	struct virtblk_req *vbr;

	while ((vbr = vblk->vq->vq_ops->get_buf(vblk->vq, &len)) != NULL) {
		int uptodate;
		switch (vbr->in_hdr.status) {
		case VIRTIO_BLK_S_OK:
			uptodate = 1;
			break;
        ...
		end_dequeued_request(vbr->req, uptodate);
		...
	}
    ...
}
```

函数blk_done遍历已用描述符区域，处理每个已用描述符链。对于每个已经消费的I/O reqeust，blk_done检查其I/O是否执行成功，这里的status就是设备负责填充的in方向的状态描述符。然后blk_done调用通用块层的end_dequeued_request唤醒等待I/O的任务。函数vring_get_buf从有效已用描述符区域的尾部开始，结构体vring_virtqueue中的变量last_used_idx记录有效已用描述符区域的尾部。在每个已用描述符中，记录了已经处理的描述符链头的ID。之前在驱动根据I/O request组织描述符链时，已经以描述符链头的ID为索引，在结构体vring_virtqueue的数组data中记录了描述符链对应的I/O request。所以，这里获取描述符链头的ID后，以其为索引，可以在结构体vring_virtqueue的数组data中索引到具体的I/O request：

```cpp
commit 3343660d8c62c6b00b2f15324ef3fcb6be207bfa
virtio: PCI device
linux.git/drivers/virtio/virtio_ring.c

static void *vring_get_buf(struct virtqueue *_vq, unsigned int *len)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
	void *ret;
	unsigned int i;
    ...
	i = vq->vring.used->ring[vq->last_used_idx%vq->vring.num].id;
    ...
	/* detach_buf clears data, so grab it now. */
	ret = vq->data[i];
	detach_buf(vq, i);
	vq->last_used_idx++;
	END_USE(vq);
	return ret;
}
```

vring_get_buf 将索引到的 I/O request 返回给上层，自增 last_used_idx，去掉这个处理完的已用描述符，然后调用 detach_buf 将处理完的这个 I/O request 对应的描述符链归还到空闲的描述符链的头部：

```cpp
commit 3343660d8c62c6b00b2f15324ef3fcb6be207bfa
virtio: PCI device
linux.git/drivers/virtio/virtio_ring.c

static void detach_buf(struct vring_virtqueue *vq, unsigned int head)
{
	unsigned int i;
    ...
	/* Put back on free list: find end */
	i = head;
	while (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {
		i = vq->vring.desc[i].next;
		vq->num_free++;
	}

	vq->vring.desc[i].next = vq->free_head;
	vq->free_head = head;
	/* Plus final descriptor */
	vq->num_free++;
}
```

我们刚刚提及了还有不通过设备发送中断的情况，比如网络设备的一些简单命令请求，模拟设备可以很快执行完成。对于Guest来讲，在向设备发出request后，静待设备完成的代价要小于进程上下文切换的代价，因此适合使用同步回收方式。也就是说，Guest发出request后，一直轮询设备是否执行完毕，而不是切换到其他任务运行。

如果模拟设备端的操作是长耗时的，采用同步的方式会导致 Guest 中的其他任务长时间得不到执行，这样显然不合适。对于这种情况，采用异步的方式更为合理。也就是说，Guest向设备发出request后，不再是当前任务霸占CPU轮询设备是否处理完request，而是把CPU让给其他任务，切换到其他任务运行，直到收到设备的中断，才进行回收。下面是同步等待设备处理request的例子:

```cpp
commit 2a41f71d3bd97dde3305b4e1c43ab0eca46e7c71
virtio_net: Add a virtqueue for outbound control commands
linux.git/drivers/net/virtio_net.c

static bool virtnet_send_command(...)
{
    ...
    vi->cvq->vq_ops->kick(vi->cvq);
    ...
    while (!vi->cvq->vq_ops->get_buf(vi->cvq, &tmp))
            cpu_relax();
    ...
}
```
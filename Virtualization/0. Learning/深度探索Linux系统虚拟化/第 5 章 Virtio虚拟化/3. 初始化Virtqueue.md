
# VQ 的 owner

在执行具体的 I/O 前，需要先搭建好承载数据的基础设施 Virtqueue。Virtio 协议规定，**Guest** 的内核**驱动**是 **Virtqueue** 的 **owner**。

在前面 I/O 栈部分探讨**驱动**时，我们看到，

* 在**向设备写数据**时，**驱动**负责将 **cache** 中的数据**写入硬盘的寄存器**；

* 从设备**读取数据**时，**驱动**负责**从硬盘的寄存器读取**数据，然后**写入 cache** 中对应的 **buffer**。

无论是**读**还是**写**，**设备**都**不参与 buffer 的管理**，所以从这个角度讲，**Virtqueue** 更适合由 **Guest** 内核中的**驱动**管理。

从另外一个角度，从 Guest 一侧可以方便地将虚拟地址（GVA）转换为物理地址（GPA），VMM 拿到 GPA 后，很容易将 GPA 转换为 HPA。但是反过来，在 VMM 中分配一块地址，几乎不可能将 **HPA** 转换为 Guest 可以识别的虚拟地址（GVA）。

既然驱动是 Virtqueue 的 owner，那么 Virqueue 的**初始化**就需要**驱动来负责**。我们在**驱动**一个**真实的物理硬盘**时，需要**从硬盘**获取具体的**参数**，比如硬盘的磁头、柱面等信息。Virtio 协议也规定如 **Virtqueue** 的 size 等**参数**由**模拟设备负责定义**，而**这些参数**在**设备的配置空间**中，因此，**驱动**首先使用 `pci_iomap` 函数将 Virtio 设备的配置**映射到内核**，Virtio 标准**约定**从**第 1 个 I/O 区域**的起始位置开始放置设备的配置，所以驱动传给 `pci_iomap` 的第 2 个参数的值为 0，即使用**第一个 bar**，也就是第一个 I/O 区域。这样，**驱动**就可以**访问 Virtio header** 获取 **Virtqueue** 的**各种参数**了。接下来，**驱动**调用函数 `find_vq` 开启 **Virtqueue** 的**初始化**过程：

```cpp
commit 3343660d8c62c6b00b2f15324ef3fcb6be207bfa
Author:     Anthony Liguori <aliguori@us.ibm.com>
AuthorDate: Mon Nov 12 21:30:26 2007 -0600
Commit:     Rusty Russell <rusty@rustcorp.com.au>
CommitDate: Mon Feb 4 23:50:11 2008 +1100

    virtio: PCI device

    This is a PCI device that implements a transport for virtio.  It allows virtio
    devices to be used by QEMU based VMMs like KVM or Xen.

    Signed-off-by: Anthony Liguori <aliguori@us.ibm.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
--- /dev/null
+++ b/drivers/virtio/virtio_pci.c

/* the PCI probing function */
static int __devinit virtio_pci_probe(struct pci_dev *pci_dev,
                                     const struct pci_device_id *id)
{
    ...
    vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
    ...
}

```

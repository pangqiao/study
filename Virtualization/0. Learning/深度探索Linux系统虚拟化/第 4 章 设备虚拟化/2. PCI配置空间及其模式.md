
PCI 标准约定, 每个 PCI 设备都需要实现一个称为配置空间(Configuration Space)的结构, 该结构就是若干寄存器的集合, 其大小为 256 字节, 包括**预定义头部**(`predefined header region`)和**设备相关部分**(`device dependent region`), 预定义头部占据 64 字节, 其余 192 字节为设备相关部分. 预定义头部定义了 PCI 设备的基本信息以及通用控制相关部分, 包括 Vendor ID、Device ID 等, 其中 Vendor ID 是唯一的, 由 PCI 特别兴趣小组(PCI SIG)统一负责分配. 在 Linux 内核中, PCI 设备驱动就是通过 Device ID 和 Vendor ID 来匹配设备的. 所有 PCI 设备的预定义头部的前 16 字节完全相同, 16～63 字节的内容则依具体的PCI设备类型而定. 位于配置空间中的偏移 0x0E 处的寄存器 Header Type 定义了PCI设备的类型, 00h 为普通 PCI 设备, 01h 为 PCI 桥, 02h 为 CardBus 桥. 图4-4为普通 PCI 设备的预定义头部.

![2024-03-01-16-56-51.png](./images/2024-03-01-16-56-51.png)

除了预定义头部外, 从偏移 64 字节开始到 255 字节, 共192字节为设备相关部分, 比如存储设备的能力(Capabilities). 比如 PCI 设备支持的 MSI(X) 中断机制, 就是利用 PCI 设备配置空间中设备相关部分来存储中断信息的, 包括中断目的地址(即目的 CPU), 以及中断向量. 操作系统初始化中断时将为 PCI 设备分配的中断信息写入 PCI 配置空间中的设备相关部分. 系统初始化时, BIOS(或者 UEFI)将把 PCI 设备的配置空间映射到处理器的 I/O 地址空间, 操作系统通过 I/O 端口访问配置空间中的寄存器. 后来的 PCI Exepress 标准约定配置空间从 256 字节扩展到了 4096 字节, 处理器需要通过 MMIO 方式访问配置空间, 当然前 256 字节仍然可以通过 I/O 端口方式访问. 篇幅所限, 我们不过多讨论 PCI Exepress 相关内容了.

除了配置空间中的这些寄存器外, PCI 设备还有**板上存储空间**. 比如 PCI 显卡中的 frame buffer, 用来存储显示的图像, 板上内存可以划分为多个区域, 这个 frame buffer 就属于其中一个区域; 再比如网卡可能使用板上内存作为发送和接收队列. 处理器需要将这些板上内存区域映射到地址空间进行访问, 但是与同标准中预先约定好的配置空间相比, 不同设备的板上内存大小不同, 不同机器上的 PCI 设备也不同, 这些都是变化的, 处理器不可能预先为所有 PCI 设备制定一个地址空间映射方案. 因此, PCI 标准提出了一个聪明的办法, 即各 PCI 设备自己提出需要占据的地址空间的大小, 以及板上内存是映射到内存地址空间, 还是 I/O 地址空间, 然后将这些诉求记录在配置空间的寄存器 BAR 中, 每个 PCI 最多可以请求映射 6 个区域. 至于映射到地址空间的什么位置, 由 BIOS(或者 UEFI)在系统初始化时, 访问寄存器 BAR, 查询各 PCI 设备的诉求, 统一为 PCI 设备划分地址空间.

PCI 设备配置空间和板上存储空间到处理器地址空间的映射关系如图 4-5 所示.

![2024-03-01_16-59-13.png](./images/2024-03-01_16-59-13.png)

了解了 PCI 设备的配置空间的基本结构后, 在探讨 VMM 如何虚拟 PCI 设备的配置空间前, 我们还需要知晓处理器是如何访问 PCI 设备的配置空间的. PCI 总线通过 PCI Host Bridge 和 CPU 总线相连, PCI Host Bridge 和 PCI 设备之间通过 PCI 总线通信. PCI Host Bridge 内部有两个寄存器用于系统软件访问 PCI 设备的配置空间, 一个是位于 CF8h 的 `CONFIG_ADDRESS`, 另外一个是位于 CFCh 的 `CONFIG_DATA`.

当系统软件访问 PCI 设备配置空间中的寄存器时, 首先将目标地址写入寄存器 `CONFIG_ADDRESS` 中, 然后向寄存器 `CONFIG_DATA` 发起访问操作, 比如向寄存器 `CONFIG_DATA` 写入一个值. 当 PCI Host Bridge 感知到 CPU 访问 `CONFIG_DATA` 时, 其根据地址寄存器 `CONFIG_ADDRESS` 中的值, 片选目标 PCI 设备, 即有效连接目标 PCI 设备的管脚 IDSEL(Initialization Device Select), 然后将寄存器 `CONFIG_ADDRESS` 中的功能号和寄存器号发送到 PCI 总线上. 目标 PCI 设备在收到地址信息后, 在接下来的时钟周期内与 PCI Host Bridge 完成数据传输操作. 这个过程如图 4-6 所示. 对于 PCIe 总线, 图 4-6 中的 PCI Host Bridge 对应为 Root Complex.

![2024-03-01-17-06-47.png](./images/2024-03-01-17-06-47.png)

图 4-6 中特别画出了内存控制器, 目的是协助读者理解系统是如何区分映射到内存地址空间的设备内存和真实物理内存, 对于设备内存映射的内存地址, 内存控制器会将其忽略, 而 PCI Host Bridge 则会认领. 在 BIOS(或者 UEFI)为 PCI 设备分配内存地址空间后, 会将其告知 PCI Host Bridge, 所以 PCI Host Bridge 知晓哪些地址应该发往 PCI 设备.

根据 PCI 的体系结构可见, 寻址一个PCI配置空间的寄存器, 显然需要**总线号**(`Bus Number`)、**设备号**(`Device Number`)、**功能号**(`Function Number`)以及最后的寄存器地址, 也就是我们通常简称的 BDF 加上偏移地址. 如果是 PCIe 设备, 还需要在总线号前面加上一个 RC(Root Complex)号. 因此, PCI Host Bridge 中的寄存器 `CONFIG_ADDRESS` 的格式如图 4-7 所示.

![2024-03-01-18-37-29.png](./images/2024-03-01-18-37-29.png)

访问具体的 PCI 设备时, 作为 CPU 与 PCI 设备之间的中间人 PCI Host Bridge, 还需要将系统软件发送过来的地址格式转换为PCI总线地址格式, 转换方式如图 4-8 所示.

![2024-03-01-18-38-40.png](./images/2024-03-01-18-38-40.png)

由于PCI Host Bridge使用管脚IDSEL已经片选了目标PCI设备, 因
此PCI总线地址不再需要设备号了, 只需要将功能号和寄存器号翻译到
PCI总线地址即可.

下面以kvmtool为例讨论其是如何虚拟PCI设备配置空间的：
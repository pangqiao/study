
最先出现的设备虚拟化方案是, VMM按照硬件设备的规范, 完完整整地模拟硬件设备的逻辑. 完全虚拟化的优势是VMM对于Guest是完全透明的, Guest可以不加任何修改地运行在任何VMM上. 起初, 完全虚拟化的逻辑完全在用户空间实现, 因为Guest的I/O操作触发CPU从Guest陷入Host内核中的KVM模块后, CPU还需要从内核空间切换到用户空间进行I/O模拟操作, 其过程基本如图4-1所示.

![2024-03-01-16-10-24.png](./images/2024-03-01-16-10-24.png)

既然Guest因为I/O触发CPU切换到Host模式后首先进入的是内核中的KVM模块, 为什么不在内核中完成设备的模拟动作, 而是要切换到用户空间中模拟呢？因此, 在有些场景下, 设备虚拟更适合在内核空间进行, 比如典型的中断虚拟化芯片的模拟. 但是, 有的设备模拟过程非常复杂, 如果完全在内核中实现, 除了会给内核中增加复杂度, 也容易带来安全问题. 于是, 开发人员提出了一个折中的Vhost方案, 将模拟设备的数据处理相关部分(dataplane)搬到了内核空间, 控制部分还保留在用户空间中, 如图4-2所示.

![2024-03-01-16-21-57.png](./images/2024-03-01-16-21-57.png)

事实上, 对于软件方式模拟的设备虚拟化来讲, 完全没有必要生搬硬套硬件的逻辑, 而是可以制定一个更高效、简洁地适用于驱动和模拟设备交互的方式, 于是半虚拟化诞生了, Virtio协议是半虚拟化的典型方案之一. 与完全虚拟化相比, 使用Virtio标准的驱动和模拟设备交互不再使用寄存器等传统的I/O方式, 而是采用了Virtqueue的方式来传输数据. 这种设计降低了设备模拟实现的复杂度, 去掉了很多CPU和I/O设备之间不必要的通信, 减少了CPU在Guest模式和Host模式之间的切换, I/O也不再受数据总线宽度、寄存器宽度等因素的影响, 提高了虚拟化的性能.

除了软件开发人员在软件虚拟方案上不断地更新迭代以外, 芯片厂商在硬件层面也在提供支持, 比如Intel提出了VT-d方式. VT-d最初支持将设备整个透传给虚拟机, 但是这种方案不支持在多虚拟机之间共享设备, 不具备可扩展性, 于是又演生出了SR-IOV方案, 如图4-3所示.

![2024-03-01-16-25-35.png](./images/2024-03-01-16-25-35.png)

事实上, 相对于硬件虚拟化方式, 设备采用软件虚拟有一些明显的优势, 比如在可信计算方面, 虚拟设备的绝大部分复杂代码都在用户空间实现, 而特权操作则需要通过VMM完成. 因此, 为了提高硬件虚拟化方案的安全性, Intel花了很大力气加强VT-d方案的安全性, 典型的方案包括DMA重映射、中断重映射.
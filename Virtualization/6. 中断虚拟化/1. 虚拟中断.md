<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 物理 CPU 处理中断](#1-物理-cpu-处理中断)
- [2. 虚拟化](#2-虚拟化)
  - [2.1. 单核使用 PIC](#21-单核使用-pic)
  - [2.2. 多处理器使用 APIC](#22-多处理器使用-apic)
- [3. 硬件辅助](#3-硬件辅助)
  - [3.1. VM exit 开销](#31-vm-exit-开销)
  - [3.2. virtual-APIC page](#32-virtual-apic-page)
  - [3.3. Guest 模式实现逻辑](#33-guest-模式实现逻辑)
  - [3.4. posted-interrupt](#34-posted-interrupt)

<!-- /code_chunk_output -->

# 1. 物理 CPU 处理中断

在探讨 Guest 模式的 CPU 处理中断前, 我们首先回顾一下**物理 CPU** 是如何**响应中断**的. 当**操作系统允许 CPU 响应中断**后, 每当**执行完一条指令**, **CPU** 都将检查**中断引脚是否有效**. 一旦有效, CPU 将**处理中断**, 然后再**执行下一条指令**, 如下图所示.

![2024-03-04-16-44-01.png](./images/2024-03-04-16-44-01.png)

# 2. 虚拟化

当有中断需要 CPU 处理时, **中断芯片**将**使连接 CPU 的 INTR 引脚有效**, 也就是说如果 INTR 是**高电平有效**, 那么**中断芯片拉高 INTR 引脚**的电平. **CPU** 在执行完一条指令后, 将**检查 INTR 引脚**.

类似的, **虚拟中断**也**效仿这种机制**, **使**与 CPU 的 INTR 引脚相连的"**引脚**"**有效**, 当然, 对于**软件虚拟**的**中断芯片**而言, "**引脚**"只是一个**变量**, 从**软件模拟**的角度就是**设置变量的值**了.

如果 **KVM** 发现**虚拟中断芯片**有**中断请求**, 则向 **VMCS** 中 `VM-entry control` 部分的 `VM-entry interruption-information field` 字段**写入中断信息**, 在**切入 Guest 模式**的一刻, **CPU** 将检查这个字段, 就**如同检查 CPU 管脚**, 如果有中断, 则进入**中断执行过程**.

## 2.1. 单核使用 PIC

下图为**单核系统**使用 **PIC** 中断芯片下的虚拟中断过程.

![2024-03-04-17-02-26.png](./images/2024-03-04-17-02-26.png)

具体步骤如下:

1) 虚拟设备向虚拟中断芯片 PIC 发送中断请求, 虚拟 PIC 记录虚拟设备的中断信息. 与物理的中断过程不同, 此时并不会触发虚拟 PIC 芯片的中断评估逻辑, 而是在 VM entry 时进行.

2) 如果虚拟 CPU 处于睡眠状态, 则唤醒虚拟 CPU, 即使虚拟 CPU 对应的线程进入了物理 CPU 的就绪任务队列.

3) 当虚拟 CPU 开始运行时, 在其切入 Guest 前一刻, **KVM** 模块将**检查虚拟 PIC 芯片**, 查看**是否有中断**需要处理. 此时, KVM 将触发虚拟 PIC 芯片的中断评估逻辑.

4) 一旦经过虚拟中断芯片计算得出有需要 Guest 处理的中断, 则将**中断信息**注入 **VMCS** 中的字段 `VM-entry interruption-information`.

5) 进入 **Guest** 模式**后**, **CPU** 检查 **VMCS** 中的**中断信息**.

6) 如果有中断需要处理, **CPU** 将调用 **Guest IDT** 中相应的**中断服务**处理中断.

## 2.2. 多处理器使用 APIC

**PIC** 只能支持**单处理器系统**, 对于**多处理器系统**, 需要 **APIC** 支持. 对于虚拟化而言, 显然也需要**虚拟相应的 APIC**, 但是其本质上与 PIC 基本相同, 如下图所示.

![2024-03-04-17-06-48.png](./images/2024-03-04-17-06-48.png)

与单处理器情况相比, 多处理器的虚拟中断主要有两点不同:

1) 在**多处理器**系统下, 不同 CPU 之间需要收发中断, 因此, **每个 CPU** 需要分别关联一个**独立的中断芯片**, 这个中断芯片称为 LAPIC. LAPIC 不仅需要接收 CPU 之间的**核间中断**(`Inter-Processor Interrupt`, **IPI**), 还需要接收来自**外设的中断**. **外设**的中断引脚**不可能**连接到**每个 LAPIC** 上, 因此, 有一个**统一的 I/O APIC芯片**负责**连接外设**, 如果一个 I/O APIC 引脚不够用, 系统中可以使用**多个 I/O APIC**. LAPIC 和 I/O APIC 都接到总线上, 通过总线进行通信. 所以在虚拟化场景下, 需要虚拟 LAPIC 和 I/O APIC 两个组件.

2) 在**多处理器**情况下, **仅仅**是**唤醒**可能在睡眠的**虚拟 CPU 线程**还不够, 如果**虚拟 CPU** 是在**另外一个物理 CPU** 上运行于 **Guest 模式**, 此时还需要向其发送 **IPI**, 使目的 CPU 从 Guest 模式退出到 Host 模式, 然后在下一次 VM entry 时, 进行**中断注入**.

# 3. 硬件辅助

## 3.1. VM exit 开销

Guest 模式的 CPU 和虚拟中断芯片处于两个"世界", 所以**处于 Guest 模式的 CPU 不能检查虚拟中断芯片的引脚**, 只能在 VM entry 前由 **KVM** 模块代为检查, 然后**写入 VMCS**. 所以, 一旦有中断需要注入, 那么处于 Guest 模式的 CPU 一定需要通过 **VM exit** 退出到 Host 模式, 这是一个很大的开销.

## 3.2. virtual-APIC page

为了去除 VM exit 的开销, Intel 在**硬件层面**对中断虚拟化进行了支持. 典型的情况比如当 Guest 访问 LAPIC 的寄存器时, 将导致 VM exit. 但是事实上, 某些访问过程并**不需要 VMM 介入**, 也就无须 VM exit. 我们知道, **物理 LAPIC 设备**上有一个**页面大小的内存**用于**存储寄存器**, 这个页面称为 **APIC page**, 于是 Intel 实现了一个处于 **Guest 模式**的页面, 称为 **virtual-APIC page**.

## 3.3. Guest 模式实现逻辑

除此之外, Intel 还在 **Guest 模式下**实现了**部分中断芯片的逻辑**, 比如**中断评估**, 我们将其称为**虚拟中断逻辑**. 如此, 在 Guest 模式下就有了状态和逻辑, 就可以模拟很多中断的行为, 比如访问中断寄存器、跟踪中断的状态以及向 CPU 递交中断等. 因此, 很多中断行为就**无须 VMM 介入**了, 从而大大地减少了 VM exit 的次数.

当然, 有些**写中断寄存器**的操作是具有副作用的, 比如通过写 icr 寄存器发送 IPI, 此时仍然需要触发 VM exit, 由本地 LAPIC 向目标 LAPIC 发送 IPI.

## 3.4. posted-interrupt

在**硬件虚拟化**支持下, 当 LAPIC 收到中断时, 不必再等到下一次 VM entry 时被动执行中断评估, 而是主动向处于 Guest 模式的 CPU 告知信息, LAPIC 首先将中断信息写入 posted-interrupt descriptor. 然后, LAPIC 通过一个特殊的核间中断 posted-interrupt notification 通知目标 CPU, 目标 CPU 在 Guest 模式下借助虚拟中断逻辑处理中断. 虚拟中断过程如下图所示.

![2024-03-04-17-10-36.png](./images/2024-03-04-17-10-36.png)


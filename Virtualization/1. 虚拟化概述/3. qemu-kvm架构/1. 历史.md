
QEMU 和 KVM 经常被人们放在一起讨论, 其实两者的关系完全可以解耦合.

QEMU 最开始是由法国程序员 Fabrice Bellard 开发的一个**模拟器**. 是一个**纯软件实现的开源「模拟」软件**, 它能够**模拟整套虚拟机**的实现, 包括 CPU、内存、各种 IO 设备、鼠标、键盘、USB 、网卡、声卡等等, 基本上没有它不能模拟的.

QEMU 能够完成**用户程序模拟**和**系统虚拟化模拟**.

* **用户程序模拟**指的是 QEMU 能够将为**一个平台**编译的**二进制文件**运行在**另一个不同的平台**, 如一个 ARM 指令集的二进制程序, 通过 QEMU 的 TCG(`Tiny Code Generator`)引擎的处理之后, ARM指令被转换成TCG中间代码, 然后再转换成目的平台的代码.

* **系统虚拟化模拟**指的是 QEMU 能够模拟一个完整的系统虚拟机, 该虚拟机有自己的虚拟CPU、芯片组、虚拟内存以及各种虚拟外部设备, 能够为虚拟机中运行的操作系统和应用软件呈现出与物理计算机完全一致的硬件视图. QEMU 能够模拟的平台很多, 包括x86、ARM、MIPS、PPC等, 早期的 QEMU 都是通过 TCG 来完成各种硬件平台的模拟, 所有的虚拟机指令需要经过QEMU的转换.

系统虚拟机天生适用于云计算. 云计算提供了一种按需服务的模式, 让用户能够很方便地根据自己的需求使用各种计算、网络、存储资源. 以计算资源中的虚拟机为例, 用户可以指定不同 CPU 模型和内存规格的虚拟机. 云计算平台可以通过系统虚拟化技术很方便地满足用户的需求. 如果用户删除资源, 云计算平台可以直接删除其对应的虚拟机. 早期的 QEMU 都是软件模拟的, 很明显其在性能上是不能满足要求的. 所以早期的云计算平台通常使用 Xen 作为其底层虚拟化平台. 前面提到过, Xen 早期是在 x86 架构上直接完成的虚拟化, 这需要修改虚拟机内部的操作系统, 也使得 Xen 的整个 VMM 非常复杂, 缺陷比较多.

Intel 和 AMD 在 2005 年左右开始在 CPU 层面提供对系统虚拟化的支持, 叫作硬件虚拟化, Intel 在 x86 指令集的基础上增加了一套 VMX 扩展指令 VT-x, 为 CPU 增加了新的运行模式, 完成了 x86 虚拟化漏洞的修补. 通过新的硬件虚拟化指令, 可以非常方便地构造VMM, 并且 x86 虚拟机中的代码能够原生地运行在物理 CPU 上.

以色列初创公司 Qumranet 基于新的虚拟化指令集实现了 KVM, 并推广到 Linux 内核社区. KVM 本身是一个内核模块, 导出了一系列的接口到用户空间, 用户空间可以使用这些接口创建虚拟机. 最开始 KVM 只负责最核心的 CPU 虚拟化和内存虚拟化部分, 使用 QEMU 作为其用户态组件, 负责完成大量外设的模拟, 当时的方案被称为 QEMU-KVM. KVM 的具体设计与实现可以参考 Avi Kivity 等人在 2007 年发表的论文"`KVM: The Linux Virtual Machine Monitor`". 由于 KVM 的设计架构精简, 能够跟现有的 Linux 内核无缝吻合, 因此在社区获得了极大的关注与支持. 特别是随着 Red Hat 投入大量的人力去完善 QEMU 和 KVM, QEMU 社区得到了飞速发展. 直到现在, QEMU 社区依然非常活跃, 但是其主要用途已经不是作为一个模拟器了, 而是作为以 QEMU-KVM 为基础的为云计算服务的系统虚拟化软件. 当然, 不仅仅是 KVM 将 QEMU 作为应用层组件, Xen 后来支持的硬件虚拟机也使用 QEMU 作为其用户态组件来完成虚拟机的设备模拟.







很多时候 **QEMU** 需要将一些**数据传递给虚拟机**，比如虚拟机的**启动引导顺序**、**ACPI** 和 **SMBIOS** 表、**SMP** 和 **NUMA 信息**等。**虚拟机**的 **Firmware**（如 `SeaBIOS`）可以根据这些数据进行相应的**配置**。

QEMU 提供了所谓的 `Firmware Configuration` (`fw_cfg`) Device 机制来完成这项工作。

本节将首先对 fw_cfg 的基本机制进行介绍，然后会简单介绍如何配置自定义的fw_cfg数据，最后以一个实例来分析如何从虚拟机中读取fw_cfg数据。

# fw_cfg 设备初始化

fw_cfg 是虚拟机用来获取 QEMU 提供数据的一个接口。通过 fw_cfg 能够将 QEMU 的数据透明地传递到虚拟机的内存地址空间中。最开始 `fw_cfg` 是用来**加载固件**的，如 **BIOS**、**ACPI** 和 **SMBIOS** 表，后来逐渐成为一个通用的接口，比如可以用它来设置 **SMP** 和 **NUMA** 信息以及**虚拟机的 UUID**，当然，用户也可以在 QEMU 的命令行通过指定 `-fw_cfg` 参数来将数据传递到虚拟机。

fw_cfg 是通过模拟设备实现的，涉及的设备有3个，如下所示.

```cpp
// include/hw/nvram/fw_cfg.h
#define TYPE_FW_CFG     "fw_cfg"
#define TYPE_FW_CFG_IO  "fw_cfg_io"
#define TYPE_FW_CFG_MEM "fw_cfg_mem"

OBJECT_DECLARE_SIMPLE_TYPE(FWCfgState, FW_CFG)
OBJECT_DECLARE_SIMPLE_TYPE(FWCfgIoState, FW_CFG_IO)
OBJECT_DECLARE_SIMPLE_TYPE(FWCfgMemState, FW_CFG_MEM)
```

其中

* `TYPE_FW_CFG` 是一个抽象类型，作为 `TYPE_FW_CFG_IO` 和 `TYPE_FW_CFG_MEM` 的父类型;

* `TYPE_FW_CFG_MEM` 表示虚拟机使用MMIO与fw_cfg设备进行通信，如 ARM架构就使用这种方式;

* `TYPE_FW_CFG_IO` 表示虚拟机使用I/O端口与fw_cfg设备进行通信，如 x86 架构就使用这种方式，这里只考虑x86的情况。

fw_cfg 设备是在 `fw_cfg_arch_create` 函数调用的 `fw_cfg_init_io_dma` 函数中进行初始化的，`fw_cfg_arch_create` 本身则是通过 `pc_init1->pc_memory_init->fw_cfg_arch_create` 被调用的。

```cpp
// hw/i386/fw_cfg.c
FWCfgState *fw_cfg_arch_create(MachineState *ms,
                                      uint16_t boot_cpus,
                                      uint16_t apic_id_limit)
{
    ...
    fw_cfg = fw_cfg_init_io_dma(FW_CFG_IO_BASE, FW_CFG_IO_BASE + 4,
                                &address_space_memory);
    ...
}
```

`fw_cfg` 使用的 I/O 端口为从 0x510 开始的若干端口，其中 `0x510 ~ 0x511` 两个端口用于 fw_cfg 的普通控制，0x514~0x51b 八个端口用于 DMA控制。`fw_cfg_init_io_dma` 函数代码如下，参数 iobase 表示 fw_cfg 的控制起始端口，dam_iobase 表示 DMA 的起始端口，dma_as 表示整个虚拟机的地址空间。


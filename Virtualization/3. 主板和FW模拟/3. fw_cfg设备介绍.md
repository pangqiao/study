
很多时候 **QEMU** 需要将一些**数据传递给虚拟机**, 比如虚拟机的**启动引导顺序**、**ACPI** 和 **SMBIOS** 表、**SMP** 和 **NUMA 信息**等. **虚拟机**的 **Firmware**(如 `SeaBIOS`)可以根据这些数据进行相应的**配置**. 

QEMU 提供了所谓的 `Firmware Configuration` (`fw_cfg`) Device 机制来完成这项工作. 

本节将首先对 fw_cfg 的基本机制进行介绍, 然后会简单介绍如何配置自定义的fw_cfg数据, 最后以一个实例来分析如何从虚拟机中读取fw_cfg数据. 

# fw_cfg 设备初始化

fw_cfg 是虚拟机用来获取 QEMU 提供数据的一个接口. 通过 fw_cfg 能够将 QEMU 的数据透明地传递到虚拟机的内存地址空间中. 最开始 `fw_cfg` 是用来**加载固件**的, 如 **BIOS**、**ACPI** 和 **SMBIOS** 表, 后来逐渐成为一个通用的接口, 比如可以用它来设置 **SMP** 和 **NUMA** 信息以及**虚拟机的 UUID**, 当然, 用户也可以在 QEMU 的命令行通过指定 `-fw_cfg` 参数来将数据传递到虚拟机. 

fw_cfg 是通过模拟设备实现的, 涉及的设备有3个, 如下所示.

```cpp
// include/hw/nvram/fw_cfg.h
#define TYPE_FW_CFG     "fw_cfg"
#define TYPE_FW_CFG_IO  "fw_cfg_io"
#define TYPE_FW_CFG_MEM "fw_cfg_mem"

OBJECT_DECLARE_SIMPLE_TYPE(FWCfgState, FW_CFG)
OBJECT_DECLARE_SIMPLE_TYPE(FWCfgIoState, FW_CFG_IO)
OBJECT_DECLARE_SIMPLE_TYPE(FWCfgMemState, FW_CFG_MEM)
```

其中

* `TYPE_FW_CFG` 是一个抽象类型, 作为 `TYPE_FW_CFG_IO` 和 `TYPE_FW_CFG_MEM` 的父类型;

* `TYPE_FW_CFG_MEM` 表示虚拟机使用MMIO与fw_cfg设备进行通信, 如 ARM架构就使用这种方式;

* `TYPE_FW_CFG_IO` 表示虚拟机使用I/O端口与fw_cfg设备进行通信, 如 x86 架构就使用这种方式, 这里只考虑x86的情况. 

`fw_cfg` 设备是在 `fw_cfg_arch_create` 函数调用的 `fw_cfg_init_io_dma` 函数中进行**初始化**的, `fw_cfg_arch_create` 本身则是通过 `pc_init1->pc_memory_init->fw_cfg_arch_create` 被调用的. 

```cpp
// hw/i386/fw_cfg.h
#define FW_CFG_IO_BASE     0x510

// hw/i386/fw_cfg.c
FWCfgState *fw_cfg_arch_create(MachineState *ms,
                                      uint16_t boot_cpus,
                                      uint16_t apic_id_limit)
{
    ...
    // 第一, 0x510 ~ 0x514
    fw_cfg = fw_cfg_init_io_dma(FW_CFG_IO_BASE, FW_CFG_IO_BASE + 4,
                                &address_space_memory);
    // 将 guest 使用的 cpus 数目添加到 fw_cfg 中
    fw_cfg_add_i16(fw_cfg, FW_CFG_NB_CPUS, boot_cpus);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, apic_id_limit);
    // memory size
    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, ms->ram_size);
#ifdef CONFIG_ACPI
    // acpi 表
    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,
                     acpi_tables, acpi_tables_len);
#endif
    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, 1);
    // e820 表
    fw_cfg_add_file(fw_cfg, "etc/e820", e820_table,
                    sizeof(struct e820_entry) * e820_get_num_entries());

    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));
    /* allocate memory for the NUMA channel: one (64bit) word for the number
     * of nodes, one word for each VCPU->node and one word for each node to
     * hold the amount of memory.
     */
    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);
    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);
    for (i = 0; i < cpus->len; i++) {
        unsigned int apic_id = cpus->cpus[i].arch_id;
        assert(apic_id < apic_id_limit);
        numa_fw_cfg[apic_id + 1] = cpu_to_le64(cpus->cpus[i].props.node_id);
    }
    for (i = 0; i < nb_numa_nodes; i++) {
        numa_fw_cfg[apic_id_limit + 1 + i] =
            cpu_to_le64(ms->numa_state->nodes[i].node_mem);
    }
    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,
                     (1 + apic_id_limit + nb_numa_nodes) *
                     sizeof(*numa_fw_cfg));

    return fw_cfg;
}
```

`fw_cfg` 使用的 I/O 端口为从 0x510 开始的若干端口, 其中 `0x510 ~ 0x511` **两个端口**用于 `fw_cfg` 的**普通控制**, `0x514 ~ 0x51b` 八个端口用于 **DMA 控制**. 

第一. `fw_cfg_init_io_dma` 函数代码如下:

* `iobase` 表示 `fw_cfg` 的**控制起始端口**;

* `dam_iobase` 表示 **DMA 的起始端口**;

* `dma_as` 表示整个虚拟机的地址空间. 

```cpp
// hw/nvram/fw_cfg.c
FWCfgState *fw_cfg_init_io_dma(uint32_t iobase, uint32_t dma_iobase,
                                AddressSpace *dma_as)
{
    DeviceState *dev;
    SysBusDevice *sbd;
    FWCfgIoState *ios;
    FWCfgState *s;
    MemoryRegion *iomem = get_system_io();
    bool dma_requested = dma_iobase && dma_as;
    // 第一
    dev = qdev_new(TYPE_FW_CFG_IO);
    if (!dma_requested) {
        qdev_prop_set_bit(dev, "dma_enabled", false);
    }

    object_property_add_child(OBJECT(qdev_get_machine()), TYPE_FW_CFG,
                              OBJECT(dev));

    sbd = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(sbd, &error_fatal);
    ios = FW_CFG_IO(dev);
    memory_region_add_subregion(iomem, iobase, &ios->comb_iomem);

    s = FW_CFG(dev);

    if (s->dma_enabled) {
        /* 64 bits for the address field */
        s->dma_as = dma_as;
        s->dma_addr = 0;
        memory_region_add_subregion(iomem, dma_iobase, &s->dma_iomem);
    }

    return s;
}
```

第一. 首先通过 `qdev_new` 创建一个 `TYPE_FW_CFG_IO` 设备, 这里没有指定设备所属的总线, 所以该设备会被挂在系统总线上, 然后设置该设备的一些属性(如基址 iobase 和 dma 的相关数据), 接着调用 `fw_cfg_init1` 函数, 在该函数中会调用 qdev_init_nofail 对设备进行具现化, 最后通过 `fw_cfg_init_io_dma` 函数将 fw_cfg 的版本信息添加到 fw_cfg 中, 虚拟机的 Firmware 或者 OS 可以借此知道 fw_cfg 的版本. 

对应的设备是:

```
# ll /sys/devices/pci0000\:00/QEMU0002\:00/
total 0
drwxr-xr-x  3 root root    0 Apr 10 14:32 ./
drwxr-xr-x 14 root root    0 Apr 10 14:32 ../
-rw-r--r--  1 root root 4096 Apr 10 14:32 driver_override
lrwxrwxrwx  1 root root    0 Apr 10 14:32 firmware_node -> ../../LNXSYSTM:00/LNXSYBUS:00/PNP0A03:00/QEMU0002:00/
-r--r--r--  1 root root 4096 Apr 10 14:32 modalias
drwxr-xr-x  2 root root    0 Apr 10 14:32 power/
lrwxrwxrwx  1 root root    0 Apr 10 14:32 subsystem -> ../../../bus/platform/
-rw-r--r--  1 root root 4096 Apr 10 14:32 uevent
-r--r--r--  1 root root 4096 Apr 10 14:32 waiting_for_supplier
```

通过 /proc/ioports 可以看到

```
# cat /proc/ioports
  0510-051b : QEMU0002:00
```

`TYPE_FW_CFG_IO` 的 realize 函数为 `fw_cfg_io_realize`, 该函数代码如下. 

```cpp
// include/standard-headers/linux/qemu_fw_cfg.h
/* width in bytes of fw_cfg control register */
#define FW_CFG_CTL_SIZE		0x02

// hw/nvram/fw_cfg.c
static void fw_cfg_io_realize(DeviceState *dev, Error **errp)
{
    ERRP_GUARD();
    FWCfgIoState *s = FW_CFG_IO(dev);

    fw_cfg_file_slots_allocate(FW_CFG(s), errp);
    if (*errp) {
        return;
    }

    // 第一
    memory_region_init_io(&s->comb_iomem, OBJECT(s), &fw_cfg_comb_mem_ops,
                          FW_CFG(s), "fwcfg", FW_CFG_CTL_SIZE);
    // 第二, 实现了 DMA 功能
    if (FW_CFG(s)->dma_enabled) {
        memory_region_init_io(&FW_CFG(s)->dma_iomem, OBJECT(s),
                              &fw_cfg_dma_mem_ops, FW_CFG(s), "fwcfg.dma",
                              sizeof(dma_addr_t));
    }

    fw_cfg_common_realize(dev, errp);
}

static void fw_cfg_common_realize(DeviceState *dev, Error **errp)
{
    FWCfgState *s = FW_CFG(dev);
    MachineState *machine = MACHINE(qdev_get_machine());
    uint32_t version = FW_CFG_VERSION;

    if (!fw_cfg_find()) {
        error_setg(errp, "at most one %s device is permitted", TYPE_FW_CFG);
        return;
    }

    fw_cfg_add_bytes(s, FW_CFG_SIGNATURE, (char *)"QEMU", 4);
    fw_cfg_add_bytes(s, FW_CFG_UUID, &qemu_uuid, 16);
    fw_cfg_add_i16(s, FW_CFG_NOGRAPHIC, (uint16_t)!machine->enable_graphics);
    fw_cfg_add_i16(s, FW_CFG_BOOT_MENU, (uint16_t)(machine->boot_config.has_menu && machine->boot_config.menu));
    fw_cfg_bootsplash(s);
    fw_cfg_reboot(s);

    if (s->dma_enabled) {
        version |= FW_CFG_VERSION_DMA;
    }
    // 将版本信息添加到 fw_cfg 中
    fw_cfg_add_i32(s, FW_CFG_ID, version);

    s->machine_ready.notify = fw_cfg_machine_ready;
    qemu_add_machine_init_done_notifier(&s->machine_ready);
}
```

第一. 调用 `memory_region_init_io` 来**分配** `FW_CFG_CTL_SIZE` **两个端口**并将其加入到系统中;


第二. 如果 `fw_cfg` 实现了 DMA 功能, 还会**分配和添加 DMA 对应的端口**. 从 `fw_cfg_init_io_dma` 里面可以知道, 由于 `fw_cfg` 的基端口为 0x510, 所以 fwcfg 这个 MemoryRegion 的端口范围就是 `0x510 ~ 0x511`. 如果开启了 DMA, 那还会添加 DMA 对应的端口, DMA 使用的端口范围是 `0x514 ~ 0x51b`. 


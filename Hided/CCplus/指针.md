
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 前言: 复杂类型说明](#1-前言-复杂类型说明)
  - [1.1. int p](#11-int-p)
  - [1.2. int *p](#12-int-p)
  - [1.3. int p[3]](#13-int-p3)
  - [1.4. int *p[3]](#14-int-p3)
  - [1.5. int (*p)[3]](#15-int-p3)
  - [1.6. int **p](#16-int-p)
  - [1.7. int p(int)](#17-int-pint)
  - [1.8. int (*p)(int)](#18-int-pint)
  - [1.9. int *(*p(int))[3]](#19-int-pint3)
- [2. 细说指针](#2-细说指针)
  - [2.1. 指针的类型](#21-指针的类型)
  - [2.2. 指针所指向的类型](#22-指针所指向的类型)
  - [2.3. 指针的值 --- 或叫指针所指向的内存区或地址](#23-指针的值-或叫指针所指向的内存区或地址)
  - [2.4. 指针本身所占据的内存区](#24-指针本身所占据的内存区)
- [3. 指针的算术运算](#3-指针的算术运算)
- [4. 运算符&和*](#4-运算符和)
- [5. 指针表达式](#5-指针表达式)
- [6. 数组和指针的关系](#6-数组和指针的关系)
- [7. 指针和结构类型的关系](#7-指针和结构类型的关系)
- [8. 指针和函数的关系](#8-指针和函数的关系)
- [9. 指针类型转换](#9-指针类型转换)
- [10. 指针的安全问题](#10-指针的安全问题)
- [11. 结束语](#11-结束语)
- [12. 参考](#12-参考)

<!-- /code_chunk_output -->

# 1. 前言: 复杂类型说明

要了解指针,多多少少会出现一些比较复杂的类型, 所以我先介绍一下如何完全理解一个复杂类型,要理解复杂类型其实很简单, **一个类型**里会出现**很多运算符**, 他们也像**普通的表达式**一样, 有**优先级**, 其优先级和**运算优先级**一样, 所以我总结了一下其原则: 

>从**变量名**处起,根据**运算符优先级结合**,一步一步分析

注: 指针是一个**带有大小范围的地址**

下面让我们先从简单的类型开始慢慢分析吧:

## 1.1. int p

```c
int p;
```

这是一个普通的整型变量

## 1.2. int *p

```c
int *p;
```

**首先从 P 处开始**, 先**与\*结合**, 所以说明 P 是**一个指针**, 然后再**与 int 结合**, 说明**指针所指向的内容**的**类型为 int 型**. 

所以 P 是**一个返回整型数据的指针**

## 1.3. int p[3]

```c
int p[3];
```

首先从 P 处开始, **先与[]结合**,说明 **P 是一个数组**, 然后**与 int 结合**, 说明**数组里的元素是整型的**.

所以 P 是一个**由整型数据组成的数组**

## 1.4. int *p[3]

```c
int *p[3];
```

首先从 P 处开始, **先与[]结合**, 因为其**优先级比\*高**, 所以 **P 是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针类型**, 然后**再与 int 结合**, 说明**指针所指向的内容的类型是整型**的.

所以 P 是一个由**返回整型数据的指针**所**组成的数组**

## 1.5. int (*p)[3]

```
int (*p)[3];
```

首先从 P 处开始, **先与\*结合**, 说明 P 是**一个指针**, 然后**再与[]结合**(与"()"这步可以忽略, 只是为了改变优先级), 说明**指针所指向的内容是一个数组**, 然后**再与 int 结合**, 说明**数组里的元素是整型**的.

所以 P 是一个指向由**整型数据组成的数组**的**指针**

## 1.6. int **p

```c
int **p;
```

首先从 P 开始, **先与\*结合**, 说是 P 是**一个指针**, 然后**再与\*结合**, 说明**指针所指向的元素是指针**, 然后**再与 int 结合**, 说明**该指针所指向的元素是整型数据**. 由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针.

## 1.7. int p(int)

```c
int p(int);
```

从 P 处起, **先与()结合**, 说明 P 是**一个函数**,然后进入()里分析, 说明该函数**有一个整型变量的参数**, 然后再与外面的 int 结合, 说明**函数的返回值**是一个**整型数据**

## 1.8. int (*p)(int)

```c
int (*p)(int);
```

从 P 处开始, **先与指针结合**, 说明 P 是**一个指针**, 然后**与()结合**, 说明**指针指向的是一个函数**, 然后再与()里的int 结合, 说明函数有一个 int 型的参数, 再与最外层的int 结合, 说明函数的返回类型是整型, 所以 P 是一个指向有一个整型参数且返回类型为整型的函数的指针

## 1.9. int *(*p(int))[3]

```c
int *(*p(int))[3];
```

从 P 开始, **先与()结合**, 说明 **P 是一个函数**, 然后进入()里面, 与 int 结合, 说明**函数有一个整型变量参数**, 然后再与外面的\*结合, 说明函数**返回的是一个指针**, 然后到最外面一层, 先与[]结合, 说明**返回的指针指向的是一个数组**, 然后**再与\*结合**, 说明**数组里的元素是指针**, 然后再与 int 结合, 说明**指针指向的内容是整型数据**. 

所以 P 是一个**参数为一个整数据**且返回一个指向由整型指针变量组成的数组的指针变量的函数.

# 2. 细说指针

指针是一个**特殊的变量**，它里面**存储的数值**被解释成为**内存里的一个地址**。

要搞清一个指针需要搞清指针的**四方面的内容**: 

* **指针的类型**、
* 指针**所指向的类型**、
* 指针的**值**或者叫指针**所指向的内存区**、
* 指针**本身所占据的内存区**。

让我们分别说明。

先声明几个指针放着做例子:

(1) `int *ptr`;

(2) `char *ptr`;

(3) `int **ptr`;

(4) `int (*ptr)[3]`;

(5) `int *(*ptr)[4]`;

## 2.1. 指针的类型

从语法的角度看，你只要把**指针声明语句**里的**指针名字去掉**，剩下的部分就是这个**指针的类型**。这是指针本身所具有的类型。让我们看看例一中各个指针的类型:

(1) `int *ptr`; //指针的类型是 `int*`

(2) `char *ptr`; //指针的类型是 `char*`

(3) `int **ptr`; //指针的类型是 `int**`

(4) `int (*ptr)[3]`; //指针的类型是 `int(*)[3]`

(5) `int *(*ptr)[4]`; //指针的类型是 `int*(*)[4]`

## 2.2. 指针所指向的类型

当你通过指针来访问**指针所指向的内存区**时，**指针所指向的类型**决定了**编译器**将把**那片内存区里的内容**当做什么来看待。

从语法上看，你只须把**指针声明语句**中的**指针名字**和**名字左边的指针声明符\*去掉**，剩下的就是指针所指向的类型。例如:

(1) `int *ptr`; //指针所指向的类型是 `int`

(2) `char *ptr`; //指针所指向的的类型是 `char`

(3) `int **ptr`; //指针所指向的的类型是 `int*`

(4) `int (*ptr)[3]`; //指针所指向的的类型是`int()[3]`

(5) `int *(*ptr)[4]`; //指针所指向的的类型是 `int*()[4]`

在指针的算术运算中，指针所指向的类型有很大的作用。 指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对 C 越来越熟悉时，你会发现，把与指针搅和在一起的"类型"这个概念分成 "指针的类型"和"指针所指向的类型"两个概念，是精通指针的关键点之一。 我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了， 所以看起书来前后矛盾，越看越糊涂。

## 2.3. 指针的值 --- 或叫指针所指向的内存区或地址

**指针的值**是指针**本身存储的数值**，这个值将被**编译器当作一个地址**，而不是一个一般的数值。

在 32 位程序里，**所有类型**的**指针的值**都是一个 **32 位整数**，因为 **32 位程序**里**内存地址**全都是 **32 位长**。 **指针所指向的内存区**就是从**指针的值**所代表的**那个内存地址开始**，长度为 **sizeof(指针所指向的类型**)的**一片内存区**。

以后，我们说**一个指针的值**是 **XX**，就相当于说**该指针指向了以 XX 为首地址**的**一片内存区域**; 我们说**一个指针**指向了**某块内存区域**， 就相当于说该指针的值是**这块内存区域的首地址**。

指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

以后，每遇到一个指针，都应该问问:这个指针的类型是什么?指针指的类型是什么?该指针指向了哪里?(重点注意)

## 2.4. 指针本身所占据的内存区

**指针本身**占了**多大的内存**? 你只要用函数 **sizeof(指针的类型**) 测一下 就知道了。在 **32 位平台**里，指针本身占据了 **4 个字节的长度**。

指针本身占据的内存这个概念在判断一个**指针表达式**(后面会解释)是否是**左值**时很有用。

# 3. 指针的算术运算


# 4. 运算符&和*

这里`&`是**取地址运算符**，`*`是**间接运算符**。

`&a` 的**运算结果**是**一个指针**，**指针的类型**是 **a 的类型加个**`*`，指针**所指向的类型**是 **a 的类型**，指针所指向的地址嘛，那就是 **a 的地址**。

`*p` 的运算结果就五花八门了。总之 `*p` 的结果是 **p 所指向的东西**， 这个东西有这些特点:它的类型是 **p 指向的类型**，它所占用的地址是 p 所指向的地址。

例子:

```c
int a=12;
int b; 
int *p; 
int **ptr;

p=&a;
*p=24;
ptr=&p;
*ptr=&b;
**ptr=34;
```

`p = &a`;      // `&a` 的结果是一个指针，类型是 `int*`，指向的类型是int，指向的地址是 a 的地址。

`*p = 24`;     // `*p` 的结果，在这里它的类型是 int，它所占用的地址是p 所指向的地址，显然，\*p 就是变量 a

`ptr = &p`;    // \&p 的结果是个指针，该指针的类型是 p 的类型加个\*，在这里是 int \*\*。该指针所指向的类型是 p 的类型，这里是 int\*。该指针所指向的地址就是指针 p 自己的地址。

`*ptr = &b`;  // \*ptr 是个指针，&b 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用\&b 来给\*ptr 赋值就是毫无问题的了。

\*\*ptr=34; // \*ptr 的结果是 ptr 所指向的东西，在这里是一个指针，对这个指针再做一次\*运算，结果是一个 int 类型的变量。

# 5. 指针表达式

一个**表达式的结果**如果是**一个指针**，那么这个表达式就叫指针表式。

下面是一些指针表达式的例子:

```c
int a,b;

int array[10];

int *pa;

pa=&a;          // &a 是一个指针表达式。

int **ptr=&pa;  // &pa 也是一个指针表达式。

*ptr=&b;        // *ptr 和&b 都是指针表达式。

pa=array;

pa++;           //这也是指针表达式。
```






# 6. 数组和指针的关系

# 7. 指针和结构类型的关系

# 8. 指针和函数的关系

# 9. 指针类型转换

# 10. 指针的安全问题

# 11. 结束语

C 中唯一的难点就是指针，指针搞定其它小菜而已，重要的是实践.

C\+\+是一门难学易用的语言，要真正掌握C\+\+可不是那么容易的，将基本的学完后，就学数据结构吧，算法才是永恒的，程序设计语言层出不穷，永远学不完。学完之后就认真啃下 STL 这根骨头吧，推荐书籍--------《范型编程与STL》 和 《STL源码剖析》。STL里有大量的精华而高效的算法。


# 12. 参考

网络资源: <让你不再害怕指针>
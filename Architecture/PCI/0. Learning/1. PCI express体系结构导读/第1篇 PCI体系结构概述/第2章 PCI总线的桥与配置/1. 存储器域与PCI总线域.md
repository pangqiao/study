
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [概述](#概述)
- [CPU域、DRAM域与存储器域](#cpu域-dram域与存储器域)
  - [CPU域](#cpu域)
  - [DRAM域](#dram域)
  - [存储器域](#存储器域)
- [PCI总线域](#pci总线域)
- [处理器域](#处理器域)

<!-- /code_chunk_output -->

# 概述

**HOST主桥**的实现**因处理器系统而异(！！！**). PowerPC处理器和x86处理器的HOST主桥除了**集成方式不同**之外其**实现机制也有较大差异**. 但是**这些HOST主桥**所完成的**最基本功能**依然是**分离存储器域与PCI总线域(！！！**)完成**PCI总线域**到**存储器域****存储器域**到**PCI总线域**之间的**数据传递(！！！**)并**管理PCI设备的配置空间(！！！**).

上文曾经多次提到在**一个处理器系统**中存在**PCI总线域**与**存储器域**. 深入理解这**两个域的区别**是**理解HOST主桥的关键**所在. 在一个处理器系统中**存储器域**、**PCI总线域**与**HOST主桥**的关系如图2‑1所示.

![config](./images/1.png)

上图所示的**处理器系统**由**一个CPU****一个DRAM控制器**和**两个HOST主桥**组成. 在这个处理器系统中包含**CPU域**、**DRAM域**、**存储器域**和**PCI总线域地址空间**. 其中**HOST主桥x**和**HOST主桥y**分别管理**PCI总线x域**与**PCI总线y域**.

**PCI设备访问存储器域时(！！！**)也需要**通过HOST主桥**并由**HOST主桥(！！！**)进行**PCI总线域**到**存储器域的地址转换**; **CPU访问PCI设备时(！！！**)同样需要通过**HOST主桥**进行**存储器域**到**PCI总线域的地址转换(！！！**).

**如果HOST主桥**支持**Peer\-to\-Peer传送**机制**PCI总线x域**上的**设备**可以与**PCI总线y域**上的**设备直接通信(！！！**)如PCI设备x11可以直接与PCI设备y11通信. 为简化模型在本书中PCI总线仅使用32位地址空间.

# CPU域、DRAM域与存储器域

## CPU域

**CPU 域地址空间**指 **CPU 所能直接访问的地址空间集合(！！！**). 在本书中, **CPU**、**处理器**与**处理器系统**的**概念不同(！！！**). 如MPC8548处理器的内核是`E500 V25`本书将这个**处理器内核称为CPU**; **处理器**由**一个或者多个CPU**、**外部Cache**、**中断控制器**和**DRAM控制器**组成; 而**处理器系统**由**一个或者多个处理器**和**外部设备**组成.

在 CPU 域中有一个重要概念即 **CPU 域边界**所谓 CPU 域边界即 **CPU 所能控制的数据完整性边界**. **CPU 域的边界**由 **Memory Fence指令**(`x86` 处理器的 Memory Fence 指令为MFENCE, LFENCE和SFENCE, 而 PowerPC 处理器的 Memory Fence 指令为 msync 和 mbar) 的**作用范围确定**, CPU域边界的划分对数据完整性(Data Consistency)非常重要. 与CPU域相关的数据完整性知识较为复杂可以独立出书因此本篇对**数据完整性**不做进一步介绍. 笔者有计划再更新完PCIe总线部分的资料后书体系结构的两方面内容一个是Cache层次结构一个是以Weakly Ordered Memory Modle为基础书写数据完整性.

严格的讲**CPU域仅在CPU内核中有效(！！！**)**CPU**访问**主存储器**时首先将**读写命令**放入**读写指令缓冲(！！！**)中然后将这个命令发送到**DRAM控制器(！！！**)或者**HOST主桥(！！！**). **DRAM控制器**或者**HOST主桥**将**CPU地址**转换为**DRAM**或者**PCI总线地址(！！！**)分别进入**DRAM域(！！！**)或者**PCI总线域(！！！**)后再访问**相应的地址空间**.

## DRAM域

**DRAM域地址空间**指 **DRAM 控制器**所能访问的**地址空间集合(！！！**). 目前处理器系统的 **DRAM** 一般由 **DDR\-SDRAM** 组成, 有的书籍也将**这部分内存**称为**主存储器**. 在**有些处理器系统**中, **DRAM控制器**能够访问的**地址空间**, 并**不能被处理器访问**, 因此在这类处理器系统中, CPU 域与 DRAM 域地址空间并不等同.

比如**有些CPU**可以支持**36位的物理地址**, 而**有些DRAM控制器**仅支持**32位的物理地址**, 此时 CPU 域包含的地址空间大于 DRAM 域地址空间. 但是这并不意味着DRAM域一定包含在CPU域中, 在某些处理器系统中, CPU 并不能访问在 DRAM 域中的某些数据区域. 而**CPU域**中除了**包含DRAM域**外, 还**包含外部设备空间(！！！**).

在**多数处理器系统**中, **DRAM 域空间**是 **CPU 域空间**的**一部分**但是**也有例外**. 比如**显卡控制器**可能会借用**一部分主存储器空间**, 这些**被借用的空间不能被CPU访问**, 而**只能被DRAM控制器**, 更为准确地说是**显卡通过DRAM控制器访问(！！！**), 因此**这段空间不属于CPU域(！！！**), 严格地讲, **这段空间属于外部设备域(！！！**).

## 存储器域

本书使用**存储器域统称CPU域与DRAM域(！！！**). **存储器域**包括**CPU内部的通用寄存器****存储器映像寻址的寄存器****主存储器空间**和**外部设备空间**. 在Intel的x86处理器系统中**外部设备空间与PCI总线域地址空间等效(！！！**)因为在**x86处理器系统**中使用**PCI总线统一管理全部外部设备(！！！**). 为简化起见本书使用 **PCI 总线域替代外部设备域(！！！**).

值得注意的是**存储器域的外部设备空间(！！！**)在 **PCI总线域**中还有一个**地址映射**. 当**处理器**访问**PCI设备**时**首先访问**的是**这个设备**在**存储器域**上的**PCI设备空间**之后**HOST主桥**将这个存储器域的PCI总线地址转换为PCI总线域的物理地址(PCI总线域只含有物理地址, 因此下文将直接使用PCI总线地址, 而不适用PCI总线物理地址)然后再通过PCI总线事务访问PCI总线域的地址空间.

# PCI总线域

在x86处理器系统中**PCI总线域**是**外部设备域**的重要组成部分. 实际上在Intel的x86处理器系统中**所有的外部设备**都使用**PCI总线**管理. 而AMD的x86处理器系统中还存在一条HT(HyperTransport)总线在AMD的x86处理器系统中还存在HT总线域. 本书对HT总线不做进一步介绍.

**PCI总线域(PCI Segment**)由PCI设备所能直接访问的地址空间组成. 在一个处理器系统中可能存在多个HOST主桥因此也存在多个PCI总线域. 如在图2‑1所示的处理器系统中具有两个HOST主桥因而在这个处理器系统中存在PCI总线x和y域.

在多数处理器系统中分属于两个PCI总线域的PCI设备并不能直接进行数据交换而需要通过FSB进行数据交换. 值得注意的是如果某些处理器的HOST主桥支持Peer-to-Peer数据传送那么这个HOST主桥可以支持不同PCI总线域间的数据传送.

PowerPC处理器使用了OCeaN技术连接两个HOST主桥OCeaN可以将属于x域的PCI数据请求转发到y域OCeaN支持PCI总线的Peer\-to\-Peer数据传送. 有关OCeaN技术的详细说明见第2.2节.

# 处理器域

处理器域是指一个处理器系统能够访问的地址空间集合. 处理器系统能够访问的地址空间由存储器域和外部设备域组成. 其中存储器域地址空间较为简单而在不同的处理器系统中外部设备域的组成结构并不相同. 如在x86处理器系统中外部设备域主要由PCI总线域组成因为大多数外部设备都是挂接在PCI总线[4]上的而在PowerPC处理器和其他处理器系统中有相当多的设备与FSB直接相连而不与PCI总线相连.

本书仅介绍PCI总线域而不对其他外部设备域进行说明. 其中存储器域与PCI总线域之间由HOST主桥联系在一起. 深入理解这些域的关系是深入理解PCI体系结构的关键所在实际上这也是理解处理器体系结构的基础.

通过HOST主桥处理器系统可以将处理器域划分为存储器域与PCI总线域. 其中存储器域与PCI总线域彼此独立并通过HOST主桥进行数据交换. HOST主桥是联系存储器域与PCI总线域的桥梁是PCI总线域实际的管理者.

有些书籍认为HOST处理器是PCI总线域的管理者这种说法并不精确. 假设在一个SMP(symmetric multiprocessing)处理器系统中存在4个CPU而只有一个HOST主桥这4个CPU将无法判断究竟谁是HOST处理器. 不过究竟是哪个处理器作为HOST处理器并不重要因为在一个处理器系统中是HOST主桥管理PCI总线域而不是HOST处理器. 当一个处理器系统中含有多个CPU时如果这些CPU都可以访问HOST主桥那么这些CPU都可以作为这个HOST主桥所管理PCI总线树的HOST处理器.

在一个处理器系统中CPU所能访问的PCI总线地址一定在存储器域中具有地址映射; 而PCI设备能访问的存储器域的地址也一定在PCI总线域中具有地址映射. 当CPU访问PCI域地址空间时首先访问存储器域的地址空间然后经过HOST主桥转换为PCI总线域的地址再通过PCI总线事务进行数据访问. 而当PCI设备访问主存储器时首先通过PCI总线事务访问PCI总线域的地址空间然后经过HOST主桥转换为存储器域的地址后再对这些空间进行数据访问.

由此可见存储器域与PCI总线域的转换关系由HOST主桥统一进行管理. 有些处理器提供了一些寄存器进行这种地址映射如PowerPC处理器使用Inbound和Outbound寄存器组保存存储器域与PCI总线域的地址映射关系; 而有些处理器并没有提供这些寄存器但是存储器域到PCI总线域的转换关系依然存在.

HOST主桥进行不同地址域间的数据交换时需要遵循以下规则. 为区别存储器域到PCI总线域的地址映射下文将PCI总线域到存储器域的地址映射称为反向映射.

(1) 处理器访问PCI总线域地址空间时首先需要访问存储器域的地址空间之后通过HOST主桥将存储器地址转换为PCI总线地址之后才能进入PCI总线域进行数据交换. PCI设备使用的地址空间保存在各自的PCI配置寄存器中即BAR寄存器中. 这些PCI总线地址空间需要在初始化时映射成为存储器域的存储器地址空间之后处理器才能访问这些地址空间. 在有些处理器的HOST主桥中具有独立的寄存器保存这个地址映射规则如PowerPC处理器的Outbound寄存器组; 而有些处理器如在x86处理器中虽然没有这样的寄存器组但是在HOST主桥的硬件逻辑中仍然存在这个地址转换的概念.

(2) PCI设备访问存储器域时首先需要访问PCI总线域的地址空间之后通过HOST主桥将PCI总线地址转换为存储器地址之后才能穿越HOST主桥进行数据交换. 为此处理器需要通过HOST主桥将这个PCI总线地址反向映射为存储器地址. PCI设备不能访问在PCI总线域中没有进行这种反向映射的存储器域地址空间. PowerPC处理器使用Inbound寄存器组存放PCI设备所能访问的存储器空间而在x86处理器中并没有这样的寄存器组但是依然存在这个地址转换的概念.

(3) 如果HOST主桥不支持Peer-to-Peer传送方式那么分属不同PCI总线域的PCI设备间不能直接进行数据交换. 在32位的PCI总线中每一个PCI总线域的地址范围都是0x0000-0000~0xFFFF-FFFF但是这些地址没有直接联系. PCI总线x域上的PCI总线地址0x0000-0000与PCI总线y域上的PCI总线地址0x0000-0000并不相同而且这两个PCI总线地址经过HOST主桥反向映射后得到的存储器地址也不相同.

本篇在第2.2节中主要以PowerPC处理器为例说明HOST主桥的实现机制并在第2.2.4节简要说明了x86处理器中的南北桥构架. 尽管部分读者对PowerPC处理器并不感兴趣笔者仍然强烈建议读者仔细阅读第2.2节的全部内容.

在PowerPC处理器中HOST主桥的实现比较完整尤其是PCI总线域与存储器域的映射关系比较明晰便于读者准确掌握这个重要的概念. 而x86处理器由于考虑向前兼容设计中包含了太多的不得已x86处理器有时不得不保留原设计中的不完美向前兼容是Intel的重要成就也是一个沉重的十字架.

[1] MPC8548处理器基于E500 V2内核. 目前E500内核包括V1V2和mc(MultiCore)三个版本.

[2] x86处理器的Memory Fence指令为MFENCELFENCE和SFENCE而PowerPC处理器的Memory Fence指令为msync和mbar.

[3] PCI总线域只含有物理地址因此下文将直接使用PCI总线地址而不使用PCI总线物理地址.

[4] AMD的x86处理器中的某些外部设备可能是基于HT总线而不使用PCI总线.
## 1. 概念

汇编语言(assembly language)是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言亦称为符号语言. 在汇编语言中用助记符(Mnemonics)代替机器指令的操作码用地址符号(Symbol)或标号(Label)代替指令或操作数的地址. 

## 2. 特点

不同的设备中汇编语言对应着不同的机器语言指令集通过汇编过程转换成机器指令. 普遍地说特定的汇编语言和特定的机器语言指令集是一一对应的不同平台之间不可直接移植. 

汇编语言的主体是汇编指令. 汇编指令和机器指令的差别在于指令的表示方法上. 汇编指令是机器指令便于记忆的书写格式. 

```
操作: 寄存器BX的内容送到AX中

1000100111011000              机器指令

mov ax,bx                     汇编指令
```

汇编语言写出源程序再用汇编编译器将其编译为机器码由计算机最终执行. 

汇编语言是直接**面向处理器**(Processor)的程序设计语言. 处理器是在指令的控制下工作的处理器可以识别的每一条指令称为机器指令. 每一种处理器都有自己可以识别的一整套指令称为指令集. 

汇编语言的另一个特点就是它所操作的对象不是具体的数据,而是寄存器或者存储器即直接和寄存器和存储器打交. 既然数据是存放在寄存器或存储器中那么必然就存在着寻址方式也就是用什么方法找到所需要的数据. 例如上面的例子我们就不能像高级语言一样直接使用数据而是先要从相应的寄存器AX、BX 中把数据取出. 这也就增加了编程的复杂性因为在高级语言中寻址这部分工作是由编译系统来完成的而在汇编语言中是由程序员自己来完成的这无异增加了编程的复杂程度和程序的可读性. 

汇编语言指令是机器指令的一种符号表示而不同类型的CPU 有不同的机器指令系统也就有不同的汇编语言,所以汇编语言程序与机器有着密切的关系. 所以除了同系列、不同型号CPU 之间的汇编语言程序有一定程度的可移植性之外其它不同类型(如: 小型机和微机等)CPU 之间的汇编语言程序是无法移植的也就是说汇编语言程序的通用性和可移植性要比高级语言程序低. 

## 3. 指令

### 数据传送指令

包括通用数据传送指令MOV、条件传送指令CMOVcc、堆栈操作指令PUSH/PUSHA/PUSHAD/POP/POPA/POPAD、交换指令XCHG/XLAT/BSWAP、地址或段描述符选择子传送指令LEA/LDS/LES/LFS/LGS/LSS等. 注意CMOVcc不是一条具体的指令而是一个指令簇包括大量的指令用于根据EFLAGS寄存器的某些位状态来决定是否执行指定的传送操作. 

### 整数和逻辑运算指令

用于执行算术和逻辑运算包括加法指令ADD/ADC、减法指令SUB/SBB、加一指令INC、减一指令DEC、比较操作指令CMP、乘法指令MUL/IMUL、除法指令DIV/IDIV、符号扩展指令CBW/CWDE/CDQE、十进制调整指令DAA/DAS/AAA/AAS、逻辑运算指令NOT/AND/OR/XOR/TEST等. 

### 移位指令

这部分指令用于将寄存器或内存操作数移动指定的次数. 包括逻辑左移指令SHL、逻辑右移指令SHR、算术左移指令SAL、算术右移指令SAR、循环左移指令ROL、循环右移指令ROR等. 

### 位操作指令

这部分指令包括位测试指令BT、位测试并置位指令BTS、位测试并复位指令BTR、位测试并取反指令BTC、位向前扫描指令BSF、位向后扫描指令BSR等. 

### 条件设置指令

这不是一条具体的指令而是一个指令簇包括大约30条指令用于根据EFLAGS寄存器的某些位状态来设置一个8位的寄存器或者内存操作数. 比如SETE/SETNE/SETGE等等. 

### 控制转移指令

这部分包括无条件转移指令JMP、条件转移指令Jcc/JCXZ、循环指令LOOP/LOOPE/LOOPNE、过程调用指令CALL、子过程返回指令RET、中断指令INTn、INT3、INTO、IRET等. 注意Jcc是一个指令簇包含了很多指令用于根据EFLAGS寄存器的某些位状态来决定是否转移; INT n是软中断指令n可以是0到255之间的数用于指示中断向量号. 

### 串操作指令

这部分指令用于对数据串进行操作包括串传送指令MOVS、串比较指令CMPS、串扫描指令SCANS、串加载指令LODS、串保存指令STOS这些指令可以有选择地使用REP/REPE/REPZ/REPNE和REPNZ的前缀以连续操作. 

### 输入输出指令

这部分指令用于同外围设备交换数据包括端口输入指令IN/INS、端口输出指令OUT/OUTS. 

### 高级语言辅助指令

这部分指令为高级语言的编译器提供方便包括创建栈帧的指令ENTER和释放栈帧的指令LEAVE. 

### 控制和特权指令

这部分包括无操作指令NOP、停机指令HLT、等待指令WAIT/MWAIT、换码指令ESC、总线封锁指令LOCK、内存范围检查指令BOUND、全局描述符表操作指令LGDT/SGDT、中断描述符表操作指令LIDT/SIDT、局部描述符表操作指令LLDT/SLDT、描述符段界限值加载指令LSR、描述符访问权读取指令LAR、任务寄存器操作指令LTR/STR、请求特权级调整指令ARPL、任务切换标志清零指令CLTS、控制寄存器和调试寄存器数据传送指令MOV、高速缓存控制指令INVD/WBINVD/INVLPG、型号相关寄存器读取和写入指令RDMSR/WRMSR、处理器信息获取指令CPUID、时间戳读取指令RDTSC等. 

### 浮点和多媒体指令

这部分指令用于加速浮点数据的运算以及用于加速多媒体数据处理的单指令多数据(SIMD及其扩展SSEx)指令. 这部分指令数据非常庞大无法一一列举请自行参考INTEL手册. 

### 虚拟机扩展指令

这部分指令包括INVEPT/INVVPID/VMCALL/VMCLEAR/VMLAUNCH/VMRESUME/VMPTRLD/VMPTRST/VMREAD/VMWRITE/VMXOFF/VMON等

## 4. 开发环境

编译器的选择依赖于目标处理器的类型和具体的系统平台. 

常用的高级语言编译器有Microsoft公司的MASM系列和Borland公司的TASM(Turbo ASM)和NASM等编译器都是80x86的汇编器都是Intel的汇编语言语法. 

Linux下主要使用GNU as汇编编译器. 当然也有nasm. 

## 5. 汇编语法风格

汇编语言根据风格不同分为Intel风格和AT&T风格Intel风格主要使用在Windows下Linux下基本采用的是AT&T风格汇编(nasm在Linux下面也有)两者有不同的地方. 

GNU as使用的是AT&T汇编语法格式. 

两种汇编差异以及介绍也可以参考: 

Linux/Linux内核完全剖析—基于0.12内核/3.内核编程语言和环境/

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [基本概念](#基本概念)
- [1. 中断架构](#1-中断架构)
  - [1.2. PIC](#12-pic)
  - [1.3. APIC](#13-apic)
  - [1.4. 处理器间中断](#14-处理器间中断)
  - [1.5. MSI](#15-msi)
  - [1.6. 中断的重要概念](#16-中断的重要概念)
    - [1.6.1. 中断的分类](#161-中断的分类)
    - [1.6.2. 中断触发方式](#162-中断触发方式)
    - [1.6.3. IRQ、GSI和中断向量](#163-irq-gsi和中断向量)
    - [1.6.4. 中断的优先级](#164-中断的优先级)
    - [1.6.5. 中断的屏蔽](#165-中断的屏蔽)
    - [1.6.6. IDT表](#166-idt表)
    - [1.6.7. 中断门](#167-中断门)
- [2. 异常架构](#2-异常架构)
- [3. 中断与异常总结](#3-中断与异常总结)
- [4. 操作系统对中断/异常的处理流程](#4-操作系统对中断异常的处理流程)

<!-- /code_chunk_output -->

# 基本概念

# 1. 中断架构

从某种意义上, **现代计算机架构**是由**大量的中断事件驱动(！！！**)的. **中断**提供给**外部硬件设备**一种"**打断CPU当前执行任务, 并响应自身服务！！！**"的手段.

**中断**从设备发送到CPU需要由被称为"**中断控制器！！！** "的部件**转发**(MSI除外). 中断控制器发展至今, 经历了**PIC**(Programmable Interrupt Controller, 可编程中断控制器)和**APIC**(Advanced Programmable Interrupt Controller, 高级可编程中断控制器)两个阶段.

## 1.2. PIC

![2019-07-09-13-53-59.png](./images/2019-07-09-13-53-59.png)

最老的中断控制芯片就是**8259A**了也就是PIC芯片.

PIC由**2个i8259**进行“级联”一个为master一个为slave**每个i8259**有**8个PIN**(**salve**的**INT输出线**连接到**master**的**IRQ2引脚**上,所以实际可用的**IRQ数目为15**). 

**IRQ = 起始base号 + pin**. **接收到设备中断**后通过**拉高引脚**通知**CPU**CPU收到中断发送**两个INT ACK**到**INTA**第二个INTA期间PIC向CPU提交中断vector. 

8259A芯片就是常说的PIC, 它具有`IR0~IR7`共**8个中断管脚**连接外部设备. 中断管脚具有**优先级**, 其中**IR0优先级最高**, **IR7最低**. 

PIC有三个重要的寄存器.

⓵ **IRR**(Interrupt Request Register, 中断请求控制器): 共8位, 对应**IR0\~IR7这8个中断管脚**. 某位**置1**代表**收到对应管脚的中断**但还**未提交到CPU**.

⓶ **ISR**(Interrupt Service Register, 中断服务寄存器): 共8位. 某位置1代表**对应管脚的中断**已经**提交到了CPU处理**, 但**CPU还未处理完**.

⓷ **IMR**(Interrupt Mask Register, 中断屏蔽寄存器): 共8位. 某位置1对应的中断**管脚被屏蔽**.

除此之外, PIC还有一个**EOI位**, 当**CPU处理完一个中断**时, 通过**写该位**告知PIC**中断处理完成**. 

PIC向CPU递交中断的流程如下.

⓵ **一个**或**多个IR**管脚上产生**电平信号**, 若**对应的中断没有被屏蔽**, **IRR**中相应的位被**置1(！！！所有收到的IR管脚的电平信号！！！**).

⓶ **PIC拉高INT**管脚**通知CPU**中断发生.

⓷ **CPU**通过**INTA管脚**应答**PIC**, 表示**中断请求收到**.

⓸ **PIC**收到**INTA应答**后, 将**IRR**中具有**最高优先级(！！！因为有多个！！！**)的位清0, 并设置**ISR中对应的位**.

⓹ CPU通过**INTA管脚**第二次发出**脉冲**, **PIC收到后**计算**最高优先级中断的vector**, 并将它提交到**数据线**上.

⓺ 等待CPU写EOI. 收到EOI后, ISR中最高优先级的位被清0. 若PIC处于AEOI模式, 当第二个INTA脉冲收到后, ISR中最高优先级的位自动清0.

PIC处理中断流程

① 当IRQ线上发生中断请求时, 8259内核的**IRR对应的位将置位**, 这个中断请求可以是**edge或level模式触发**

② 如果这个中断请求是允许的(**没被屏蔽, 通过IMR**), 则提交到处理器INTR pin上

③ 处理器将以**interrupt acknowledge cycle(中断响应周期**)作为**回复(走的是系统总线！！！**), 这个**cycle**被**host bridge(CPU到PCI桥**)传送到**PCH(Platform Controller Hub**)上

④ PCH将这个cycle**转化**为8259可以响应的两个interrupt acknowledge pulse(**中断响应脉冲**)出现在master和slave 8259**控制器**的**INTA\#pin**上.

⑤ 在接收到**第1个INTA\#脉冲**后, 8259进行**优先级的仲裁**, 最高的中断请求得到响应, **ISR寄存器相应的位置位**, **IRR寄存器**对应的位被**清0(控制器接收了请求后就将相应的IRR\<中断请求状态>寄存器位清0**).

⑥ 如果如果**slave 8259**赢了**中断仲裁**(即**slave上有优先级别高的中断请求**)则master 8259通过一条**3位宽的内部线**向slave 8259传送一个slave identification code(**从片标识码**)slave 8259会对这个code进行检查决定是否在**第2个INTA#脉冲**时**回复一个interrupt vector**当这个code与slave 8259内的**identification code**相符时(初始化时设置)slave 8259必须回复一个**interrupt vector**通过**data bus**给processor. 

⑦ 如果**master 8259**赢了中断仲裁则master 8259在**第2个INTA\#脉冲**时会回复一个**interrupt vector**通过**data bus(数据总线**)给processor. 

⑧ **中断完成**后在**AEOI(Automatic End of Interrupt)模式**里8259在**第2个INTA\#结束后**自动**清ISR相应的位**. 否则必须发送一个**EOI命令给8259**. 

## 1.3. APIC

PIC可以在UP(单处理器)平台上工作, 但无法用于MP(多处理器)平台. 因此, APIC应运而生.

APIC由位于**CPU中**的**本地高级可编程中断控制器**(Local Advanced Programmable Interrupt Controller, **LAPIC**)和位于**主板南桥**中**I/O高级可编程中断控制器**(`I/O Advanced Programmable Interrupt Controller`, **IOAPIC**)两部分构成. 

![](./images/2019-07-01-16-23-00.png)

LAPIC每CPU一个; IO APIC可以一个系统里面有多个但是KVM中只实现了一个可以根据自己的需要进行添加. 设备发送中断发送到IO APIC; IO APIC中存在着一个PRT表每个PRT的表项成为RTERTE是每个引脚一个IOAPIC引脚收到中断消息后根据RTE得到目标LAPIC并格式化出一个中断消息发送给LAPIC同时置位remote irr(level). 

中断控制器目前主要有**APIC**这种架构下**设备控制器**通过**某种触发方式**通知**IO APIC****IO APIC**根据**自身维护**的**重定向表pci irq routing table**格式化出**一条中断消息**把中断消息发送给**local APIC**local APIC局部于CPU即**每个CPU一个**local APIC 具备**传统中断控制器的相关功能**以及各个寄存器中断请求寄存器IRR中断屏蔽寄存器IMR中断服务寄存器ISR等针对这些关键部件的虚拟化是中断虚拟化的重点. 

LAPIC接受到中断消息后提取其中的VECTOR并设置IRR后进行中断的选取取得优先级最高的中断后清除IRR设置ISR提交CPU进行中断处理CPU处理完中断后写LAPIC的EOI通知IOAPIC清除remote irr(level且deassert). 


IOAPIC通常有**24个不具有！！！优先级的管脚**, 用于**连接外部设备**, LAPIC位与CPU内部. 

当**IRQ线(连接的外设线！！！**)上有中断请求发生时**I/O APIC**在**redirection table(通常是操作系统设定的**)里找到管脚对应的**RTE(redirection table entry或者说redirection table寄存器**)读取**RTE**内的**中断消息内容**, 通过其各个字段, 格式化出一条包含该中断所有信息的中断消息, 再经由**system bus(！！！老式的通过专门的APIC总线**)发送给LAPIC.

System Bus是广播总线, 特定CPU上的Local APIC先判断是否属于中断消息的目标对象. 

在**LAPIC**内部, 也有**IRR**、**ISR**和**EOI寄存器**, 其中IRR、ISR为256位, EOI为32位, 注意: **没有了IMR寄存器**, 通过**mask位实现**.

APIC系统中, 中断的发起大致流程如下.

⓵ **IOAPIC**收到**某个管脚**产生的**中断信号**

⓶ 查找PRT表获得该管脚对应的RTE. 根据RTE各字段格式化出一条中断消息, 并确定发送给哪个(或多个)CPU的LAPIC.

⓷ 通过系统总线或APIC总线发送中断消息

⓸ LAPIC收到中断消息, 判断是否由自己接收

⓹ 如确定接收, 将IRR中对应的位置1. 同时确定此时是否将该中断交给CPU处理.

⓺ 如确定提交中断给CPU处理, 从IRR获取最高优先级的中断, 将ISR中对应的位置1, 并提交中断. 对于edge触发, IRR中对应位此时清0.

⓻ CPU处理完中断, 软件写EOI寄存器告知中断处理完成, 对于level触发的中断, IRR中对应位清0. LAPIC可提交下一个中断.

## 1.4. 处理器间中断

在MP(多处理器)平台上, 多个CPU要协同工作, 处理器间中断(Inter\-processor Interrupt, IPI)提供CPU之间相互通信的手段. CPU可以通过LAPIC的ICR(Interrupt Command Register, 中断命令寄存器)向指定的一个/多个CPU发送中断.

操作系统通常使用IPI来完成诸如**进程转移**、**中断平衡**和**TLB刷新**等工作.

## 1.5. MSI

后来又出来的MSI中断设备直接如果支持MSI的话直接构造出MSI消息MSI有个字段**Address**标明了**中断目标地址**然后**设备直接发送中断给LAPIC**提交CPU这种方式下直接**绕过了IOAPIC**效率更高. 

## 1.6. 中断的重要概念

### 1.6.1. 中断的分类

中断可以从很多方面分类, 从中断源角度看, 可以分为如下几类.

⓵ 外部中断: 指连接在IOAPIC上设备产生的中断、LAPIC上连接的设备或LAPIC内部中断源产生的中断以及处理器间中断. 

⓶ 可屏蔽中断: 指可以通过某种方式(例如CLI指令、TPR)进行屏蔽的中断. 与之对应的是不可屏蔽中断.

⓷ 软件产生中断: 只通过INT n指令产生的中断.

这样分类不是绝对, 例如外部中断通常是可屏蔽中断, 但也可能属于不可屏蔽中断. 通常, 根据外部中断的触发方式, 又把它们分为如下几类.

⓵ edge触发中断: 指中断边沿方式触发(例如上升沿). ISA设备、时钟设备多使用这种触发方式. 

⓶ level触发中断: 指中断以电平方式触发, 在中断程序应答设备前, 该电平一直有效. PCI设备使用这种触发方式.

### 1.6.2. 中断触发方式

中断触发方式分为电平触发和边沿触发level触发和edge触发; 

- **level触发**就是一直将**引脚**保持在**高电平**(电平为**1**)直到**中断完成**现在**PCI/PCIE设备**都是**level触发**; 
- **edge**就是通过**一个电平边缘跳变**来触发的中断, 电平**从0到1**或者**从1到0**原来的**ISA设备**都是**edge触发**在**kvm**中通过发送**level = 0**和**level = 1**的两个中断来**模拟一个edge中断**. 

**isa设备**大多数采用**边沿触发****pci设备**采用**电平触发**. 

### 1.6.3. IRQ、GSI和中断向量

在**现代操作系统**中, 有几个概念和vector常联系在一起使用, 简单介绍下.

⓵ **IRQ**: PIC时代的产物, 由于ISA设备通常是连接到**固定PIC管脚**, 所以说一个设备的IRQ实际是指它连接的PIC管脚号. 

**IRQ暗示着中断优先级**, 例如IRQ0比IRQ3有着更高的优先级. . 

进入到APIC时代后, 仍**习惯**用**IRQ**来表示**一个设备的中断号**, 但对于**16以下的IRQ**, 它们可能**不再与IOAPIC的管脚对应！！！**例如PIT此时接的是2号管脚. 

Pin是管脚号通常它表示**IOAPIC的管脚**(前面说了PIC时代我们用IRQ). Pin的最大值受**IOAPIC管脚数限制**目前取值范围是`[0,23]`.  

⓶ **GSI**(Global System Interrupt): **ACPI引入的概念**, 它为系统中**每个中断源**指定了一个**唯一的中断号**. 

IRQ和GSI在APIC系统中常被混用, 实际上对于**15以上的IRQ**, 它**和GSI相等**.

注: ACPI Spec规定**PIC的IRQ号**必须对应到`GSI 0 -GSI 15`上. kvm默认支持最大1024个GSI. 

如果GSI base 为0每个管脚的GSI=GSI base + pin**15以上的GSI号和IRQ值相等**但是`[0~15]`是**按照ACPI 规范！！！映射**的其实试试GSI 2映射到了IRQ 0上了在KVM中引脚号就是IRQ号. 

这里, GSI和IRQ可以看作等同的概念, 表示**某个设备的中断号**. 它们与**vector的关系**由操作系统决定, 通常是在**设备驱动注册中断处理程序**时由**操作系统分配**.

⓷ 中断向量vector是针对逻辑CPU的概念用来表示中断在**IDT表的索引号**每个IRQ(或者GSI)最后都会被定向到某个Vecotor上. 

对于**PIC**上的中断中断向量vector = 32(start vector) + IRQ号. 在IOAPIC上的中断被分配的中断向量则是由**操作系统分配**. 

中断和异常会打断顺序执行的程序流, 转而进入一条完全不同的执行路径.

### 1.6.4. 中断的优先级

在使用**PIC**的系统中, PIC的**管脚**决定了**中断的优先级**, 连接**IR0**的设备具有**最高优先级**, 连接**IR7**的设备**优先级最低**. 

在**APIC**系统中, **IOAPIC的管脚**不再具备优先级, 设备的优先级由它所连接管脚对应**RTE中的vector字段**决定. **vector**是x86架构用于索引**IDT表的下标**, 范围从0\~255, **值越大优先级越高**. 其中, **32\~255**可供外部中断使用.

### 1.6.5. 中断的屏蔽

无论是在PIC收到中断信号后, 还是**LAPIC！！！收到中断消息**后, 并不一定都是马上交给CPU处理的, 这还要取决于**CPU当前是否屏蔽中断**(不可屏蔽中断除外). 

当**CPU屏蔽中断**时, **中断会被依附(pending)在PIC/LAPIC的IRR寄存器(！！！**)中, **一旦CPU开启中断**, 会在第一时间响应PIC/LAPIC所依附(pending)的中断. CPU可通过下面几种方式屏蔽/开启中断.

⓵ **CLI/STI指令**: 这是操作系统最常用的屏蔽/开启中断的方法. CLI指令将本CPU的EFLAGS寄存器的IF位清0, 阻止接收中断; STI指令将IF位置1, 允许接收中断. 这两条指令支队当前CPU起作用.

⓶ **TPR(Task Priority Register)寄存器**: 根据该寄存器值代表的优先级, 部分屏蔽外部中断.

⓷ **PIC/IOAPIC**的中断屏蔽位: 

- PIC可以通过IMR寄存器屏蔽对应管脚. 

- IOAPIC可通过**RTE中的mask位**屏蔽对应管脚. 该方法不会讲中断依附(pengding)到IRR, 而是直接忽略, 对于edge触发中断可能导致中断丢失.

### 1.6.6. IDT表

IDT实际上就是个大数组, 用于存放各种"门"(中断门、陷阱门、任务门). 这些门是中断和异常通往各自处理函数的入口. 当一个中断或异常发生, CPU用它们对应的vector号索引IDT表以获得对应的"门". 

**IDT表**的**基地址**存放在**IDTR寄存器**中该寄存器与GDTR类似由一个**基地址**字段(Base)和**长度**字段(Limit)构成. 

### 1.6.7. 中断门

"门"是入口, 中断门就是中断的入口. 中断门实际上是一种段描述符, 称为**系统描述符**, 由**段描述符的S位控制**. 格式如图.

![](./images/2019-07-01-16-23-37.png)

其中, 段选择符、偏移量字段可以看作是一个逻辑地址, 通过索引GDT将该逻辑地址转换为中断处理函数入口的线性地址. 这里特别要注意的是DPL字段, 很多操作系统会将门的**DPL设为0**. 那么有一个问题: 程序在**用户态**时(CPL=3)发生**中断**, 岂不是不能过一个DPL=0的中断门? 实际上, 中断门和陷阱门的**DPL**只在使用**INT n指令**引起中断/异常时才**检查**, **硬件产生的中断/异常不检查**. P字段代表中断门是否有效, 清0无效.

通常**操作系统的中断都用了中断门**, 没有使用陷阱门. 中断门和陷阱门唯一区别在于程序通过中断门跳转后, EFLAGS寄存器的IF位自动清0, 中断关闭. 而陷阱门没有.

# 2. 异常架构

和中断相比, 异常最大的不同在于它是在程序的执行过程中同步发生的. 例如下面

```c
void main()
{
    int a = 10;
    a = a/0;
}
```

程序运行到a=a/0一句必然引起一个**除0异常**, 但不能预料该程序在执行时是否会发生中断. 异常根据产生的原因和严重程度可分为如下三类.

⓵ 错误(Fault): 由某种错误情况引起, 一般可以被错误处理程序纠正. 错误发生时, 处理器将控制权转移给对应的处理程序, 修正后重新**回到产生异常的指令继续执行**. 例如, 常见的缺页错误就属于此类.

⓶ 陷阱(Trap): 指在执行了一条特殊指令后引起的异常, 处理器允许**忽略异常**继续往下执行. 在异常处理程序里不必修正错误, 回到发生异常指令的下一条指令继续执行. 陷阱是**有意的异常**陷阱最重要的用途是在**用户程序**和**内核**之间提供一个像过程一样的接口(即**系统调用**). 例如, Linux 32用于实现**系统调用**的`INT 80`指令就属于此类.

⓷ 终止(Abort): 指严重的不可恢复的错误, 将导致程序终止的异常. 例如MCA(Machine Check Architecture).

和中断门一样, 陷阱门存放在IDT表中. 异常发生后, CPU用该异常的vector号索引对应的陷阱门. **x86架构**将**vector 0\~19**预留给**各个异常**. 

陷阱门格式如图.

![](./images/2019-07-01-16-22-26.png)

# 3. 中断与异常总结

![](./images/2019-07-01-16-22-04.png)

# 4. 操作系统对中断/异常的处理流程

各个操作系统对于中断/异常处理实现不同, 但基本流程如下.

一个中断/异常发生, 打断正在执行的任务.

(1) CPU通过vector索引IDT表得到对应的"门", 并获得其处理函数的入口地址.

(2) 程序跳到处理函数执行, 由于处理函数存放在CPL=0的代码段, 程序可能会发生权限提升. 处理函数通常执行以下步骤.

⓵ 保存被中断任务的上下文, 并开始执行处理函数.

⓶ 如果是中断, 处理完成后需要写EOI寄存器(伪中断不需要)应答, 异常不需要.

⓷ 恢复被打断的任务的上下文, 准备返回

(3) 从中断/异常的处理函数返回, 恢复被打断的任务, 使其继续执行.

目前, 新的中断方式: MSI(Message Signalled Interrupt)已经被广泛应用, 这里先不介绍.




<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 概述](#1-概述)
  - [1.1. 页表](#11-页表)
  - [1.2. TLB](#12-tlb)
  - [1.3. 线性地址转换为物理地址的过程](#13-线性地址转换为物理地址的过程)
- [2. 32位分页](#2-32位分页)
  - [2.1. 4KB页面线性地址翻译](#21-4kb页面线性地址翻译)
  - [2.2. 4MB页面线性地址翻译](#22-4mb页面线性地址翻译)
  - [2.3. CR3和分页结构项](#23-cr3和分页结构项)
  - [2.4. 物理地址组成](#24-物理地址组成)
    - [2.4.1. CR3生成PDT物理基地址](#241-cr3生成pdt物理基地址)
    - [2.4.2. 4KB页PDE生成PT的物理基地址](#242-4kb页pde生成pt的物理基地址)
    - [2.4.3. 4KB页PTE生成页面的物理基地址](#243-4kb页pte生成页面的物理基地址)
    - [2.4.4. 4MB页PDE生成页面的物理基地址](#244-4mb页pde生成页面的物理基地址)
    - [2.4.5. 最终物理地址的生成](#245-最终物理地址的生成)
- [3. PAE分页](#3-pae分页)
  - [3.1. 4KB页面线性地址翻译](#31-4kb页面线性地址翻译)
  - [3.2. 2MB页面线性地址翻译](#32-2mb页面线性地址翻译)
  - [3.3. CR3和分页结构项](#33-cr3和分页结构项)
  - [3.4. 物理地址组成](#34-物理地址组成)
    - [3.4.1. CR3生成PDPT物理基地址](#341-cr3生成pdpt物理基地址)
    - [3.4.2. PDPTE生成PDT的物理基地址](#342-pdpte生成pdt的物理基地址)
    - [3.4.3. 4KB页PDE生成PT的物理基地址](#343-4kb页pde生成pt的物理基地址)
    - [3.4.4. 4KB页PTE生成页面的物理基地址](#344-4kb页pte生成页面的物理基地址)
    - [3.4.5. 2MB页PDE生成页面的物理基地址](#345-2mb页pde生成页面的物理基地址)
    - [3.4.6. 最终物理地址的生成](#346-最终物理地址的生成)
- [4. IA-32e分页](#4-ia-32e分页)
  - [4.1. 4KB页面线性地址翻译](#41-4kb页面线性地址翻译)
  - [4.2. 2MB页面线性地址翻译](#42-2mb页面线性地址翻译)
  - [4.3. 1GB页面线性地址翻译](#43-1gb页面线性地址翻译)
  - [4.4. CR3和分页结构项](#44-cr3和分页结构项)
  - [4.5. 物理地址组成](#45-物理地址组成)
    - [4.5.1. CR3生成PML4T物理基地址](#451-cr3生成pml4t物理基地址)
    - [4.5.2. PML4E生成PDPT的物理基地址](#452-pml4e生成pdpt的物理基地址)
    - [4.5.3. 4KB页和2MB页PDPTE生成PDT的物理基地址](#453-4kb页和2mb页pdpte生成pdt的物理基地址)
    - [4.5.4. 1GB页PDPTE生成页面的物理基地址](#454-1gb页pdpte生成页面的物理基地址)
    - [4.5.5. 4KB页PDE生成PT的物理基地址](#455-4kb页pde生成pt的物理基地址)
    - [4.5.6. 4KB页PTE生成页面的物理基地址](#456-4kb页pte生成页面的物理基地址)
    - [4.5.7. 2MB页PDE生成页面的物理基地址](#457-2mb页pde生成页面的物理基地址)
    - [4.5.8. 最终物理地址的生成](#458-最终物理地址的生成)
- [5. 分页错误代码](#5-分页错误代码)
- [6. 参考](#6-参考)

<!-- /code_chunk_output -->


# 1. 概述

分页是更加粒度化的内存管理机制, 分页是用粒度化的单位"页"来管理线性地址空间和物理地址空间. x86下一个典型的页大小是4KB, 则一个4GB的**虚拟地址空间**可以**划分为1024X1024个页面**. **物理地址空间的划分同理**. x86允许大于4KB的页面大小, 这里只介绍4KB页面.

同时, **分页机制**让操作系统中的**虚拟内存机制**称为可能. **一个页面**可以存在于**物理内存(！！！**)中, 也可以存放在**磁盘的交换区域！！！**(如**Linux下的Swap分区！！！**, **Windows的虚拟内存文件！！！**)中, 程序可以使用比机器**物理内存更大的内存区域！！！**.

分页机制的核心思想是通过**页表**将**线性地址转换为物理地址**, 并配合**旁路转换缓冲区(Translation Lookaside Buffer, TLB！！！**)来加速地址转换过程. **操作系统**在**启动过程**中, 通过将**CR0寄存器**的**PG位置1**来启动**分页机制**. 

![config](./images/43.png)

从图中看到, 分页机制主要由页表、CR3和TLB三个部件构成. 下面以4KB页面的32位分页为例进行讲解.

## 1.1. 页表

**页表(Page Table**)是用于将**线性地址转换成物理地址**的主要数据结构. **一个地址对齐到页边界(！！！**)后的值称为**页帧号**, 它实际是**该地址所在页面的基地址**. **线性地址对应的页帧号！！！**即**虚拟页帧号(Virtual Frame Number, VFN！！！**), **物理地址对应的页帧号！！！**即**物理页帧号(Physical Frame Number, PFN！！！**)或**机器页帧号(Machine Frame Number**). 页表就是存储VFN到PFN映射的数据结构. 

4KB的32位分页使用两级页表, 如图.

![config](./images/44.png)

⓵ **页目录项(Page Directory Entry**): 包含**页表的物理地址(！！！不是线性地址！！！**). **页目录项**存放在**页目录(Page Directory, 也称为页目录表PDT！！！**)中, CPU使用线性地址的22\~31位(高10位)索引页目录, 以获得该线性地址对应的页目录项. 每个页目录项为4B大小, 故页目录占用4KB大小的物理页面, 共包含1024的页目录项.

⓶ 页表项(Page Table Entry): 页表项包含**该线性地址对应的PFN(！！！物理地址页帧号！！！**). **页表项**存放在**页表(Page Table**)中, CPU使用线性地址的**12\~21位**索引页表, 获得该**线性地址**对应的**页表项**. 通过将**线性地址**的**0\~11位**偏移量和**基地址**相加, 就可以得到线性地址对应的物理地址. 页表项为4B大小, 故页表包含1024个页表项, 占用一个4KB页面.

![config](./images/45.png)

图2\-9显示了页目录项、页表项的构成, 通过其中的各个字段, 可以对页面访问权限, 缓存机制, 全局页等属性进行控制. 这里只关注P(Present)字段, 该字段使虚拟内存的实现成为可能. P根据其值不同, 可以代表两种情况:

1. P=1: 物理页面存在于物理内存中, CPU完成地址转换后, 可以直接访问该页面.
2. P=0: **页面不在物理内存**中, 当CPU访问该页面时会产生一个**缺页错误(Page Fault**)并交由**操作系统**的**缺页错误处理程序处理**. 通常**操作系统**会将**存放在磁盘上的页面(！！！**)调入**物理内存**, 使访问可以继续. **P=0**时, **页目录项**、**页表项格式**变成图2-10中的格式. 此时**1\~31位**供操作系统使用以记录物理页面在磁盘上的信息, 通常是**物理页面在磁盘上的位置！！！**.

![config](./images/46.png)

CPU在**索引页目录**前, 必须知道**页目录所在的物理地址**, 该**物理地址**存放在**CR3(Control Register 3)寄存器**中, 也称为**页目录基地址寄存器(Page\-directory base register, PDBR**). 一个**进程在运行前(！！！**), 必须将**其页目录的基地址存入CR3**. 页目录的基地址必须**对齐到4K边界**.

## 1.2. TLB

为提高地址转换效率, x86架构使用TLB对最近用到的页面映射进行缓存, 当CPU访问某个线性地址, 其所在页面的映射存在于TLB中, 无须查找页表即可进行地址转换. 注意, 很多资料说TLB存放的是线性地址到物理地址的转换, 准确来说应该是: **VFN到PFN的转换！！！**. 即, **CPU从TLB**获得一个**线性地址对应的PFN**后, 仍然要**和线性地址的偏移相加**, 才能得到**最后的物理地址**, 而**非直接从TLB中获取物理地址**.

TLB作为缓存, 其能存放的映射条目有限, 当TLB中没有空闲条目可用时, 替换哪一个旧条目由CPU决定.

**TLB**也有**缓存一致性**的问题这主要是指**TLB中的映射条目(！！！**)和**页表中的映射条目(！！！**)的一致性. 当**操作系统**对**页表进行修改**要**负责对TLB中对应条目或整个TLB进行刷新(！！！**). 从**软件的角度**来看, x86提供了**两种方式刷新TLB**:

⓵ **更新CR3**: 此操作可以**导致TLB被整体刷新**, TLB中**所有映射条目失效**(**全局TLB除外**). 操作系统将**当前CR3中的值**重新写会**CR3**以**刷新整个TLB**. 进程切换时, 新进程的页目录基地址会写入CR3而使老进程在TLB中的条目失效.

⓶ **INVLPG指令**: 这是一种更细粒度的刷新, **操作系统**用它对**TLB**中**单独的页目录项**、**页表项**进行刷新. 这通常是在**操作系统修改页表**后进行的(例如**分配/释放页面！！！**).

## 1.3. 线性地址转换为物理地址的过程

⓵ CPU访问一个线性地址, 映射在TLB中跳到⓺. 如映射不存在于TLB中, 称为TLB Miss发生, 进行下一步.

⓶ **查找页表**, **页面在物理内存！！！** 中跳到⓸, 不会再进行下一步.

⓷ 操作系统的缺页处理函数接管, 通常进行如下操作: a)将页面从磁盘复制到物理内存中; b)更改对应页表项, 设置P为1, 并对其他字段相应设置; c)**刷新TLB中对应的页表项**; d)从缺页错误处理函数中返回.

⓸ 到这一步, **页面**已经存在于**物理内存**中, 并且**页表**已经**包含了该映射**. 此时, 重新执行引发TLB Miss的指令.

⓹ **TLB Miss再次发生(！！！**), **CPU重新查页表**, 把**相应的映射插入到TLB**中.

⓺ 到这一步, **TLB**已经包含了**该线性地址对应的PFN**. 通过将**线性地址**中的**偏移部分和PFN相加**, 就得到了**对应的物理地址**.

翻译自《Intel® 64 and IA\-32 Architectures Software Developer Manual Volume 3A》

![config](./images/40.png)

![config](./images/41.png)

每个table里的entry(表项)分别被称为**PTE(Page Table Entry**)、**PDE(Page Directory Table Entry**)、**PDPE(Page Directory Pointer Table Entry**)和**PML4E(Page\-Map Leve\-4 Table Entry**). 

注: CR3存放的是物理地址, 表项中也是物理地址.

# 2. 32位分页

**线性地址是32位宽**, 采用一级或两级页转换表.

**每个表项**大小是**4字节**宽, 32位.

**CR3**使用**32位**.

## 2.1. 4KB页面线性地址翻译

使用PDT(page directory table页目录表)和PT(page table页表)两级表格. 

用32位分页的到一个4KB页面的线性地址翻译

![config](./images/1.jpg)

**4KB页面线性地址构成: 10(PDT索引, 1024个项) \+ 10(PT索引, 1024个项) \+ 12(Page offset, 4KB页**)

一个table的大小:

- 一个PDT有1024项(2^10); 占用空间: 1024 x 4字节 = 4KB.
- 一个PT有1024项(2^10); 占用空间: 1024 x 4字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PDTE可能共有: 1024(2\^10) 个; 占用空间: 1024 x 4字节 = 4KB.
- PTE可能共有: 1024(2^10) x 1024(2\^10) 个; 占用空间: 1024 x 1024 x 4字节 = 4MB.

## 2.2. 4MB页面线性地址翻译

使用PDT(page directory table)一级表格. 

用32位分页的到一个4MB页面的线性地址翻译

![config](./images/2.jpg)

**4MB页面线性地址构成: 10(PDT索引, 1024个项) \+ 22(Page offset, 4MB页**)

一个table的大小:

- 一个PDT有1024项(2^10), 占用空间: 1024 x 4字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PDTE可能共有: 1024(2\^10) 个; 占用空间: 1024 x 4字节 = 4KB.

## 2.3. CR3和分页结构项

32位分页的CR3和分页结构项的格式

![config](./images/3.jpg)

## 2.4. 物理地址组成

32位paging下**最高为40位物理地址(！！！**)(依赖于**PSE\-36**与**MAXPHYADDR**值). 如果**不使用PSE\-36机制**, 那么**最高为32位物理地址(！！！**).

4K页面能映射的**物理地址最高是32位(！！！**)

### 2.4.1. CR3生成PDT物理基地址

在32位paging模式下CR3使用**低32位**(在**Intel64或AMD64机器上64位, 只使用低32位！！！**)CR3的**Bit 31到Bit 12位**提供**20位的Page Directory Table的物理基地址(物理基地址！！！高20位！！！**). 

那么以**36位的物理基地址**为例它是这样形成的. 

① `base of PDT[35: 32]`=`0`值(**高4位Bit 35到Bit 32为0值！！！如果是40位物理地址高位也会是补0！！！**). 

② `base of PDT[31: 12]`=`CR3[31: 12]`(**中间20位**由**CR3的Page Driectory base域**提供). 

③ `base of PDT[11: 00]`=`0`值(**低12位补0！！！**). 

因此CR3提供的**PDT物理基地址(！！！**)是**4K边界对齐(！！！**)的. **和4KB分页的物理地址形成方式一致(！！！**).

### 2.4.2. 4KB页PDE生成PT的物理基地址

32位paging模式的4K页面里能映射的**物理地址最高是32位(！！！4K页最高32位物理地址！！！**)下一级**32位的page table物理地址**形成如下. 

① `base of PT[31: 12]`(**高20位**)=`PDE[31: 12]`它是**PDE的高20位值**. 

② `base of PT[11: 0]`(**低12位**)=`0`值32位地址的**低12位补0**. 

因此PDE里提供的**PT物理基地址(！！！**)是**4K边界对齐(！！！由PT物理基地址组成决定的！！！**)的. 

### 2.4.3. 4KB页PTE生成页面的物理基地址

在32位paging模式下**4K页面**使用的是**32位的最高映射物理地址(！！！只能使用最高32位物理地址！！！**). 因此page frame的形成如下. 

① `page base[31: 12]`=`PTE[31: 12]`PTE的**高20位**对应**物理页面的高20位**. 

② `page base[12: 0]`=`0`值. **物理页面的低12位补0**. 

所以**物理页面在4KB边界对齐**.

### 2.4.4. 4MB页PDE生成页面的物理基地址

4MB页面**没有PT**, **PDE直接指向页面**.

**4MB页面**的**PDE结构**提供**4MB页面的物理基地址**, 地址组成方式如下:

① 当处理器**不支持PSE\-36**功能时4M page frame只能映射到**32位的物理地址空间(！！！**)上`PDE[31: 22]`是4M `page base[31: 22]`(**高10位**), 这时候`PDE[21: 13]`共**9位是保留位**必须设置为0值. 

② 当**MAXPHYADDR**值为**36**位时`PDE[16: 13]`是`4M page base[35: 32]`位(高4位)`PDE[31: 22]`是`4M page base[31: 22]`(**中间10位**), 而`PDE[21: 17]`是保留位必须设置为0值. 

③ 当MAXPHYADDR值为**40位**时`PDE[20: 13]`是`4M page base[39: 32]`位(高8位), `PDE[31: 22]`是`4M page base[31: 22]`(**中间10位**)而`PDE[21]`位是保留位必须设置为0值. 

④ 当MAXPHYADDR值为**52位**时也**仅能使用40位的物理地址(！！！**)同③. 

因此4M page frame的基地址形成除上述所说外**36位或40位的物理地址低22位将补0(！！！**)物理页面将在**4M边界上对齐(！！！**). 

### 2.4.5. 最终物理地址的生成

上面可以看到, 所有页面基地址都是4KB或4MB边界对齐的, 再加上线性地址低位的偏移offset, 生成最终的物理地址.

# 3. PAE分页

**线性地址32位宽**, 使用两级或三级页转换表.

**每个表项8字节宽**.

新CR3仍然32位宽, 但只使用了27位, 拼凑了32位PDPT物理地址. 

## 3.1. 4KB页面线性地址翻译

使用`PDPT`(page directory pointer table页目录指针表)`PDT`和`PT`. 

用PAE分页的到一个4KB页面的线性地址翻译

![config](./images/4.jpg)

**4KB页面线性地址构成: 2(PDPT索引, 4个项) \+ 9(PDT索引, 512个项) \+ 9(PT索引, 512个项) \+ 12(Page offset, 4KB页**)

一个table的大小:

- 一个PDPT有4项(2\^2); 占用空间: 4 x 8字节 = 32字节.
- 一个PDT有512项(2^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PT有512项(2^9); 占用空间: 512 x 8字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PDPTE可能共有: 4(2\^2) 个; 占用空间: 4 x 8字节 = 32字节.
- PDE可能共有: 4(2\^2) x 512(2\^9) 个; 占用空间: 4 x 512 x 8字节 = 16KB.
- PTE可能共有: 4(2\^2) x 512(2\^9) x 512(2\^9) 个; 占用空间: 4 x 512 x 512 x 8字节 = 8MB.

## 3.2. 2MB页面线性地址翻译

使用`PDPT`和`PDT`. 

用PAE分页的到一个2MB页面的线性地址翻译

![config](./images/5.jpg)

**2MB页面线性地址构成: 2(PDPT索引, 4个项) \+ 9(PDT索引, 512个项) \+ 21(Page offset, 2MB页**)

一个table的大小:

- 一个PDPT有4项(2\^2); 占用空间: 4 x 8字节 = 32字节.
- 一个PDT有512项(2^9); 占用空间: 512 x 8字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PDPTE可能共有: 4(2\^2) 个; 占用空间: 4 x 8字节 = 32字节.
- PDE可能共有: 4(2\^2) x 512(2\^9) 个; 占用空间: 4 x 512 x 8字节 = 16KB.

## 3.3. CR3和分页结构项

![config](./images/6.jpg)

## 3.4. 物理地址组成

PAE下, **线性地址仍然32位宽(！！！**), **CR3还是32位宽**,  支持**最高52位的物理地址**依赖于**MAXPHYADDR值**. 当MAXPHYADDR为**36**时只能映射到**36位的物理地址**以此类推. 

### 3.4.1. CR3生成PDPT物理基地址

**CR3低5位被忽略**提供**27位的PDPT基地址**.

**32位的PDPT物理地址**形成如下:

① `base of PDPT[31: 5]`=`CR3[31: 5]`**高27位由CR3**提供. 

② `base of PDPT[4: 0]`=`0`值**低5位补0**. 

如果是**36位或更大物理地址**, 则进行**高位补0**.

因此PDPT的基地址是**32字节边界对齐(2\^5！！！**)的. 

### 3.4.2. PDPTE生成PDT的物理基地址

4KB页和2MB页这是一致的

在**PDT(page directory table)物理基地址**上它的地址为**52位(最高支持**)、**40位或是36位**它的形成如下. 

① 当MAXPHYADDR为**52位**时`base of PDT[51: 12]`=`PDPTE[51: 12]`由PDPTE结构的`[51: 12]`提供PDT的**高40位**. 

② 当MAXPHYADDR为**40位**时`base of PDT[39: 12]`=`PDPTE[39: 12]`由PDPTE结构的`[39: 12]`提供**PDT的高28位**. 此时`PDPTE[51: 40]`是保留位必须为0值. 

③ 当MAXPHYADDR为**36位**时`base of PDT[35: 12]`=`PDPTE[35: 12]`由PDPTE结构的`[35: 12]`提供PDT的**高24位**. 此时`PDPTE[51: 36]`是保留位必须为0值. 

**PDT的低12位(！！！)将补0值**因此**PDT物理基地址**将在**4K边界上对齐(！！！**). 

### 3.4.3. 4KB页PDE生成PT的物理基地址

`PDE[51: 12]`(**最多30位, 加上12位0, 最大52位物理地址**)提供**PT的物理基地址高位** **低12位全部补0**, PT地址为**4K边界对齐**. 

如果物理地址比较小, **bit 51往下减少**.

### 3.4.4. 4KB页PTE生成页面的物理基地址

`PTE[51: 12]`提供**4K页面的高物理地址位(最多40位**),  **低12位全部补0**,  **页面地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.4.5. 2MB页PDE生成页面的物理基地址

2MB页面**没有PT**, **PDE直接指向页面**.

① MAXPHYADDR为**52位**时`2M page frame`地址的`[51: 21]`(**高31位**)由`PDE[51: 21]`提供. 

② MAXPHYADDR为**40位**时`2M page frame`地址的`[39: 21]`(**高19位**)由`PDE[39: 21]`提供此时`PDE[51: 22]`为保留位必须为0. 

③ MAXPHYADDR为**36位**时`2M page frame`地址的`[35: 21]`(**高15位**)由`PDE[35: 21]`提供此时`PDE[51: 36]`为保留位必须为0

`2M page frame`地址的`[20: 0]`(**低21位！！！)补0**因此**2M页面**的地址**在2M边界上对齐**. 

### 3.4.6. 最终物理地址的生成

上面可以看到, 所有页面基地址都是4KB或2MB边界对齐的, 再加上线性地址低位的偏移offset, 生成最终的物理地址.

# 4. IA-32e分页

线性地址48位宽, 使用两级到四级的页转换表.

**每个表项都是8字节宽**.

CR3是64位宽, 针对是否支持PCIDE功能, CR3使用不一样. 

## 4.1. 4KB页面线性地址翻译

使用`PML4T`(page map level-4 table四层映射表)`PDPT``PDT`和`PT`. 

用IA\-32e分页的到一个4KB页面的线性地址翻译

![config](./images/7.jpg)

**4KB页面线性地址构成: 9(PML4T索引, 512个项) \+ 9(PDPT索引, 512个项) \+ 9(PDT索引, 512个项) \+ 9(PT索引, 512个项) \+ 12(Page offset, 4KB页**)

一个table的大小:

- 一个PML4T有512项(2\^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PDPT有512项(2\^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PDT有512项(2^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PT有512项(2^9); 占用空间: 512 x 8字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PML4E可能共有: 512(2\^9)个; 占用空间: 512 x 8字节 = 4KB.
- PDPTE可能共有: 512(2\^9) x 512(2\^9) 个; 占用空间: 512 x 512 x 8字节 = 2MB.
- PDE可能共有: 512(2\^9) x 512(2\^9) x 512(2\^9) 个; 占用空间: 512 x 512 x 512 x 8字节 = 1GB.
- PTE可能共有: 512(2\^9) x 512(2\^9) x 512(2\^9) x 512(2\^9)个; 占用空间: 512 x 512 x 512 x 512 x 8字节 = 512GB.

## 4.2. 2MB页面线性地址翻译

使用`PML4T``PDPT`和`PDT`. 

用IA\-32e分页的到一个2MB页面的线性地址翻译

![config](./images/8.jpg)

**2MB页面线性地址构成: 9(PML4T索引, 512个项) \+ 9(PDPT索引, 512个项) \+ 9(PDT索引, 512个项) \+ 21(Page offset, 2MB页**)

一个table的大小:

- 一个PML4T有512项(2\^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PDPT有512项(2\^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PDT有512项(2^9); 占用空间: 512 x 8字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PML4E可能共有: 512(2\^9)个; 占用空间: 512 x 8字节 = 4KB.
- PDPTE可能共有: 512(2\^9) x 512(2\^9) 个; 占用空间: 512 x 512 x 8字节 = 2MB.
- PDE可能共有: 512(2\^9) x 512(2\^9) x 512(2\^9) 个; 占用空间: 512 x 512 x 512 x 8字节 = 1GB.

## 4.3. 1GB页面线性地址翻译

使用`PML4T`和`PDPT`. 

用IA\-32e分页的到一个1GB页面的线性地址翻译

![config](./images/9.jpg)

**1GB页面线性地址构成: 9(PML4T索引, 512个项) \+ 9(PDPT索引, 512个项) \+ 30(Page offset, 1GB页**)

一个table的大小:

- 一个PML4T有512项(2\^9); 占用空间: 512 x 8字节 = 4KB.
- 一个PDPT有512项(2\^9); 占用空间: 512 x 8字节 = 4KB.

一个进程一次性全部表示需要的页表结构内存:

- PML4E可能共有: 512(2\^9)个; 占用空间: 512 x 8字节 = 4KB.
- PDPTE可能共有: 512(2\^9) x 512(2\^9) 个; 占用空间: 512 x 512 x 8字节 = 2MB.

## 4.4. CR3和分页结构项

IA\-32e分页的CR3和分页结构项的格式

![config](./images/10.jpg)

## 4.5. 物理地址组成

**线性地址48位宽(！！！**), **CR3已经是64位宽**,  支持**最高52位的物理地址**依赖于**MAXPHYADDR值**. 当MAXPHYADDR为**36**时只能映射到**36位的物理地址**以此类推. 

### 4.5.1. CR3生成PML4T物理基地址

`CR3[51: 12]`提供**PML4T的物理地址高位(最多40位**), **低12位全部补0**,  **PML4T地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.2. PML4E生成PDPT的物理基地址

`PML4E[51: 12]`提供**PDPT的物理地址高位(最多40位**),  **低12位全部补0**,  **PDPT地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.3. 4KB页和2MB页PDPTE生成PDT的物理基地址

`PDPTE[51: 12]`提供**PDT的物理地址高位(最多40位**),  **低12位全部补0**,  **PDT地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.4. 1GB页PDPTE生成页面的物理基地址

1GB页面**没有PDT**, **没有PT**, **PDPTE直接指向页面**.

`PDPTE[51: 30]`提供**PDT的物理地址高位(最多22位**),  **页面地址低30位全部补0**,  **页面地址1GB边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.5. 4KB页PDE生成PT的物理基地址

`PDE[51: 12]`提供**PT的物理地址高位(最多40位**),  **页表PT地址低12位全部补0**,  **页表PT地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.6. 4KB页PTE生成页面的物理基地址

`PTE[51: 12]`提供**页面的物理地址高位(最多40位**),  **页面地址低12位全部补0**,  **页面地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.7. 2MB页PDE生成页面的物理基地址

2MB页面**没有PT**, **PDE直接指向页面**.

`PDE[51: 21]`提供**页面的物理地址高位(最多31位**),  **页面地址低21位全部补0**,  **页面地址2MB边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 4.5.8. 最终物理地址的生成

上面可以看到, 所有页面基地址都是4KB, 2MB或1GB边界对齐的, 再加上线性地址低位的偏移offset, 生成最终的物理地址.

# 5. 分页错误代码

![config](./images/11.jpg)

# 6. 参考

https://blog.csdn.net/Firas/article/details/17207813
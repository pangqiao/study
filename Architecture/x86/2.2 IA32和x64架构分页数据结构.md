
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [概述](#概述)
  - [页表](#页表)
  - [TLB](#tlb)
  - [线性地址转换为物理地址的过程](#线性地址转换为物理地址的过程)
- [32位分页](#32位分页)
  - [4KB页面线性地址翻译](#4kb页面线性地址翻译)
  - [4MB页面线性地址翻译](#4mb页面线性地址翻译)
  - [CR3和分页结构项](#cr3和分页结构项)
  - [物理地址组成](#物理地址组成)
    - [CR3生成PDT物理基地址](#cr3生成pdt物理基地址)
    - [4KB页PDE生成PT的物理基地址](#4kb页pde生成pt的物理基地址)
    - [4KB页PTE生成页面的物理基地址](#4kb页pte生成页面的物理基地址)
    - [4MB页PDE生成页面的物理基地址](#4mb页pde生成页面的物理基地址)
    - [最终物理地址的生成](#最终物理地址的生成)
- [PAE分页](#pae分页)
  - [4KB页面线性地址翻译](#4kb页面线性地址翻译-1)
  - [2MB页面线性地址翻译](#2mb页面线性地址翻译)
  - [CR3和分页结构项](#cr3和分页结构项-1)
  - [物理地址组成](#物理地址组成-1)
    - [CR3生成PDPT物理基地址](#cr3生成pdpt物理基地址)
    - [PDPTE生成PDT的物理基地址](#pdpte生成pdt的物理基地址)
    - [4KB页PDE生成PT的物理基地址](#4kb页pde生成pt的物理基地址-1)
    - [4KB页PTE生成页面的物理基地址](#4kb页pte生成页面的物理基地址-1)
    - [2MB页PDE生成页面的物理基地址](#2mb页pde生成页面的物理基地址)
    - [最终物理地址的生成](#最终物理地址的生成-1)
- [IA-32e分页](#ia-32e分页)
  - [4KB页面线性地址翻译](#4kb页面线性地址翻译-2)
  - [3.2 2MB页面线性地址翻译](#32-2mb页面线性地址翻译)
  - [3.3 1GB页面线性地址翻译](#33-1gb页面线性地址翻译)
  - [3.4 CR3和分页结构项](#34-cr3和分页结构项)
  - [3.5 物理地址组成](#35-物理地址组成)
    - [3.5.1 CR3生成PML4T物理基地址](#351-cr3生成pml4t物理基地址)
    - [3.5.2 PML4E生成PDPT的物理基地址](#352-pml4e生成pdpt的物理基地址)
    - [3.5.3 4KB页和2MB页PDPTE生成PDT的物理基地址](#353-4kb页和2mb页pdpte生成pdt的物理基地址)
    - [3.5.4 1GB页PDPTE生成页面的物理基地址](#354-1gb页pdpte生成页面的物理基地址)
    - [3.5.5 4KB页PDE生成PT的物理基地址](#355-4kb页pde生成pt的物理基地址)
    - [3.5.6 4KB页PTE生成页面的物理基地址](#356-4kb页pte生成页面的物理基地址)
    - [3.5.7 2MB页PDE生成页面的物理基地址](#357-2mb页pde生成页面的物理基地址)
    - [3.5.8 最终物理地址的生成](#358-最终物理地址的生成)
- [4 分页错误代码](#4-分页错误代码)

<!-- /code_chunk_output -->

https://blog.csdn.net/Firas/article/details/17207813

# 概述

分页是更加粒度化的内存管理机制, 分页是用粒度化的单位"页"来管理线性地址空间和物理地址空间. x86下一个典型的页大小是4KB, 则一个4GB的**虚拟地址空间**可以**划分为1024X1024个页面**. **物理地址空间的划分同理**. x86允许大于4KB的页面大小, 这里只介绍4KB页面.

同时, **分页机制**让操作系统中的**虚拟内存机制**称为可能. **一个页面**可以存在于**物理内存(！！！**)中, 也可以存放在**磁盘的交换区域！！！**(如**Linux下的Swap分区！！！**, **Windows的虚拟内存文件！！！**)中, 程序可以使用比机器**物理内存更大的内存区域！！！**.

分页机制的核心思想是通过**页表**将**线性地址转换为物理地址**, 并配合**旁路转换缓冲区(Translation Lookaside Buffer, TLB！！！**)来加速地址转换过程. **操作系统**在**启动过程**中, 通过将**CR0寄存器**的**PG位置1**来启动**分页机制**. 

![config](./images/43.png)

从图中看到, 分页机制主要由页表、CR3和TLB三个部件构成. 下面以4KB页面的32位分页为例进行讲解.

## 页表

**页表(Page Table**)是用于将**线性地址转换成物理地址**的主要数据结构. **一个地址对齐到页边界(！！！**)后的值称为**页帧号**, 它实际是**该地址所在页面的基地址**. **线性地址对应的页帧号！！！**即**虚拟页帧号(Virtual Frame Number, VFN！！！**), **物理地址对应的页帧号！！！**即**物理页帧号(Physical Frame Number, PFN！！！**)或**机器页帧号(Machine Frame Number**). 页表就是存储VFN到PFN映射的数据结构。

4KB的32位分页使用两级页表, 如图.

![config](./images/44.png)

⓵ **页目录项(Page Directory Entry**): 包含**页表的物理地址(！！！不是线性地址！！！**). **页目录项**存放在**页目录(Page Directory, 也称为页目录表PDT！！！**)中, CPU使用线性地址的22\~31位(高10位)索引页目录, 以获得该线性地址对应的页目录项. 每个页目录项为4B大小, 故页目录占用4KB大小的物理页面, 共包含1024的页目录项.

⓶ 页表项(Page Table Entry): 页表项包含**该线性地址对应的PFN(！！！物理地址页帧号！！！**)。**页表项**存放在**页表(Page Table**)中, CPU使用线性地址的**12\~21位**索引页表, 获得该**线性地址**对应的**页表项**. 通过将**线性地址**的**0\~11位**偏移量和**基地址**相加, 就可以得到线性地址对应的物理地址. 页表项为4B大小, 故页表包含1024个页表项, 占用一个4KB页面.

![config](./images/45.png)

图2\-9显示了页目录项、页表项的构成, 通过其中的各个字段, 可以对页面访问权限, 缓存机制, 全局页等属性进行控制. 这里只关注P(Present)字段, 该字段使虚拟内存的实现成为可能. P根据其值不同, 可以代表两种情况:

1. P=1: 物理页面存在于物理内存中, CPU完成地址转换后, 可以直接访问该页面.
2. P=0: **页面不在物理内存**中, 当CPU访问该页面时会产生一个**缺页错误(Page Fault**)并交由**操作系统**的**缺页错误处理程序处理**. 通常**操作系统**会将**存放在磁盘上的页面(！！！**)调入**物理内存**, 使访问可以继续. **P=0**时, **页目录项**、**页表项格式**变成图2-10中的格式。此时**1\~31位**供操作系统使用以记录物理页面在磁盘上的信息, 通常是**物理页面在磁盘上的位置！！！**.

![config](./images/46.png)

CPU在**索引页目录**前, 必须知道**页目录所在的物理地址**, 该**物理地址**存放在**CR3(Control Register 3)寄存器**中, 也称为**页目录基地址寄存器(Page\-directory base register, PDBR**). 一个**进程在运行前(！！！**), 必须将**其页目录的基地址存入CR3**. 页目录的基地址必须**对齐到4K边界**.

## TLB

为提高地址转换效率, x86架构使用TLB对最近用到的页面映射进行缓存, 当CPU访问某个线性地址, 其所在页面的映射存在于TLB中, 无须查找页表即可进行地址转换. 注意, 很多资料说TLB存放的是线性地址到物理地址的转换, 准确来说应该是: **VFN到PFN的转换！！！**. 即, **CPU从TLB**获得一个**线性地址对应的PFN**后, 仍然要**和线性地址的偏移相加**, 才能得到**最后的物理地址**, 而**非直接从TLB中获取物理地址**.

TLB作为缓存, 其能存放的映射条目有限, 当TLB中没有空闲条目可用时, 替换哪一个旧条目由CPU决定.

**TLB**也有**缓存一致性**的问题，这主要是指**TLB中的映射条目(！！！**)和**页表中的映射条目(！！！**)的一致性。当**操作系统**对**页表进行修改**，要**负责对TLB中对应条目或整个TLB进行刷新(！！！**)。从**软件的角度**来看, x86提供了**两种方式刷新TLB**:

⓵ **更新CR3**: 此操作可以**导致TLB被整体刷新**, TLB中**所有映射条目失效**(**全局TLB除外**). 操作系统将**当前CR3中的值**重新写会**CR3**以**刷新整个TLB**. 进程切换时, 新进程的页目录基地址会写入CR3而使老进程在TLB中的条目失效.
⓶ INVLPG指令: 这是一种更细粒度的刷新, **操作系统**用它对**TLB**中**单独的页目录项**、**页表项**进行刷新. 这通常是在**操作系统修改页表**后进行的(例如**分配/释放页面！！！**).

## 线性地址转换为物理地址的过程

⓵ CPU访问一个线性地址, 映射在TLB中跳到⓺. 如映射不存在于TLB中, 称为TLB Miss发生, 进行下一步.
⓶ **查找页表**, **页面在物理内存！！！**中跳到⓸, 不会再进行下一步.
⓷ 操作系统的缺页处理函数接管, 通常进行如下操作: a)将页面从磁盘复制到物理内存中; b)更改对应页表项, 设置P为1, 并对其他字段相应设置; c)**刷新TLB中对应的页表项**; d)从缺页错误处理函数中返回.
⓸ 到这一步, **页面**已经存在于**物理内存**中, 并且**页表**已经**包含了该映射**. 此时, 重新执行引发TLB Miss的指令.
⓹ **TLB Miss再次发生(！！！**), **CPU重新查页表**, 把**相应的映射插入到TLB**中.
⓺ 到这一步, **TLB**已经包含了**该线性地址对应的PFN**. 通过将**线性地址**中的**偏移部分和PFN相加**, 就得到了**对应的物理地址**.

翻译自《Intel® 64 and IA\-32 Architectures Software Developer Manual Volume 3A》

![config](./images/40.png)

![config](./images/41.png)

每个table里的entry（表项）分别被称为**PTE（Page Table Entry**）、**PDE（Page Directory Table Entry**）、**PDPE（Page Directory Pointer Table Entry**）和**PML4E（Page\-Map Leve\-4 Table Entry**）。

CR3存放的是物理地址, 表项中也是物理地址.

# 32位分页

**线性地址是32位宽**, 采用一级或两级页转换表, 每个表项大小是4字节宽, CR3使用32位.

## 4KB页面线性地址翻译

使用PDT（page directory table，页目录表）和PT（page table，页表）两级表格。

用32位分页的到一个4KB页面的线性地址翻译

![config](./images/1.jpg)

**4KB页面线性地址构成: 10(PDT索引, 1024个项) \+ 10(PT索引, 1024个项) \+ 12(Page offset, 4KB页**)

**一个PDT和一个PT大小都是4KB**. 

## 4MB页面线性地址翻译

使用PDT（page directory table）一级表格。

用32位分页的到一个4MB页面的线性地址翻译

![config](./images/2.jpg)

**4MB页面线性地址构成: 10(PDT索引, 1024个项) \+ 22(Page offset, 4MB页**)

**一个PDT大小是4KB**

## CR3和分页结构项

32位分页的CR3和分页结构项的格式

![config](./images/3.jpg)

## 物理地址组成

32位paging下**最高为40位物理地址(！！！**)（依赖于**PSE\-36**与**MAXPHYADDR**值）。如果**不使用PSE\-36机制**, 那么**最高为32位物理地址(！！！**).

4K页面，能映射的**物理地址最高是32位(！！！**)

### CR3生成PDT物理基地址

在32位paging模式下，CR3使用**低32位**（在**Intel64或AMD64机器上64位, 只使用低32位！！！**），CR3的**Bit 31到Bit 12位**提供**20位的Page Directory Table的物理基地址(物理基地址！！！高20位！！！**)。

那么以**36位的物理基地址**为例，它是这样形成的。

① `base of PDT[35：32]=0`值（**高4位Bit 35到Bit 32为0值！！！如果是40位物理地址高位也会是补0！！！**）。

② `base of PDT[31：12]=CR3[31：12]`（**中间20位**由**CR3的Page Driectory base域**提供）。

③ `base of PDT[11：00]=0`值（**低12位补0！！！**）。

因此CR3提供的**PDT物理基地址(！！！**)是**4K边界对齐(！！！**)的。**和4KB分页的物理地址形成方式一致(！！！**).

### 4KB页PDE生成PT的物理基地址

32位paging模式的4K页面里，能映射的**物理地址最高是32位(！！！4K页最高32位物理地址！！！**)，下一级**32位的page table物理地址**形成如下。

① `base of PT[31：12]`(**高20位**)=`PDE[31：12]`，它是**PDE的高20位值**。

② `base of PT[11：0]`(**低12位**)=`0`值，32位地址的**低12位补0**。

因此，PDE里提供的**PT物理基地址(！！！**)是**4K边界对齐(！！！由PT物理基地址组成决定的！！！**)的。

### 4KB页PTE生成页面的物理基地址

在32位paging模式下**4K页面**使用的是**32位的最高映射物理地址(！！！只能使用最高32位物理地址！！！**)。因此page frame的形成如下。

① `page base[31：12]=PTE[31：12]`，PTE的**高20位**对应**物理页面的高20位**。

② `page base[12：0]=0`值。**物理页面的低12位补0**。

所以**物理页面在4KB边界对齐**.

### 4MB页PDE生成页面的物理基地址

4MB页面**没有PT**, **PDE直接指向页面**.

**4MB页面**的**PDE结构**提供**4MB页面的物理基地址**, 地址组成方式如下:

① 当处理器**不支持PSE\-36**功能时，4M page frame只能映射到**32位的物理地址空间(！！！**)上，`PDE[31: 22]`是4M `page base[31: 22]`(**高10位**), 这时候`PDE[21：13]`共**9位是保留位**，必须设置为0值。

② 当**MAXPHYADDR**值为**36**位时，`PDE[16：13]`是`4M page base[35：32]`位(高4位)，`PDE[31: 22]`是`4M page base[31: 22]`(**中间10位**), 而`PDE[21：17]`是保留位，必须设置为0值。

③ 当MAXPHYADDR值为**40位**时，`PDE[20：13]`是`4M page base[39：32]`位(高8位), `PDE[31: 22]`是`4M page base[31: 22]`(**中间10位**)，而`PDE[21]`位是保留位，必须设置为0值。

④ 当MAXPHYADDR值为**52位**时，也**仅能使用40位的物理地址(！！！**)，同③。

因此，4M page frame的基地址形成除上述所说外，**36位或40位的物理地址低22位将补0(！！！**)，物理页面将在**4M边界上对齐(！！！**)。

### 最终物理地址的生成

上面可以看到, 所有页面基地址都是4KB或4MB边界对齐的, 再加上线性地址低位的偏移offset, 生成最终的物理地址.

# PAE分页

**线性地址32位宽**, 使用两级或三级页转换表, 每个表项8字节宽, 新CR3仍然32位宽, 但只使用了27位, 拼凑了32位PDPT物理地址。

## 4KB页面线性地址翻译

使用PDPT（page directory pointer table，页目录指针表），PDT和PT。

用PAE分页的到一个4KB页面的线性地址翻译

![config](./images/4.jpg)

**4KB页面线性地址构成: 2(PDPT索引, 4个项) \+ 9(PDT索引, 512个项) \+ 9(PT索引, 512个项) \+ 12(Page offset, 4KB页**)

**PDPT大小可以是4x8=32字节**, PDT和PT仍然是4KB大小, 512x8.

## 2MB页面线性地址翻译

使用PDPT和PDT。

用PAE分页的到一个2MB页面的线性地址翻译

![config](./images/5.jpg)

**2MB页面线性地址构成: 2(PDPT索引, 4个项) \+ 9(PDT索引, 512个项) \+ 21(Page offset, 2MB页**)

**PDPT大小可以是4x8=32字节**, PDT是4KB

## CR3和分页结构项

![config](./images/6.jpg)

## 物理地址组成

PAE下, **线性地址仍然32位宽(！！！**), **CR3还是32位宽**,  支持**最高52位的物理地址**，依赖于**MAXPHYADDR值**。当MAXPHYADDR为**36**时只能映射到**36位的物理地址**，以此类推。

### CR3生成PDPT物理基地址

**CR3低5位被忽略**，提供**27位的PDPT基地址**.

**32位的PDPT物理地址**形成如下:

① `base of PDPT[31：5]`=`CR3[31：5]`，**高27位由CR3**提供。

② `base of PDPT[4：0]`=`0`值，**低5位补0**。

如果是**36位或更大物理地址**, 则进行**高位补0**.

因此，PDPT的基地址是**32字节边界对齐(2\^5！！！**)的。

### PDPTE生成PDT的物理基地址

4KB页和2MB页这是一致的

在**PDT（page directory table）物理基地址**上，它的地址为**52位（最高支持**）、**40位或是36位**，它的形成如下。

① 当MAXPHYADDR为**52位**时，`base of PDT[51：12]`=`PDPTE[51：12]`，由PDPTE结构的`[51：12]`提供PDT的**高40位**。

② 当MAXPHYADDR为**40位**时，`base of PDT[39：12]`=`PDPTE[39：12]`，由PDPTE结构的`[39：12]`提供**PDT的高28位**。此时`PDPTE[51：40]`是保留位，必须为0值。

③ 当MAXPHYADDR为**36位**时，`base of PDT[35：12]`=`PDPTE[35：12]`，由PDPTE结构的`[35：12]`提供PDT的**高24位**。此时`PDPTE[51：36]`是保留位，必须为0值。

**PDT的低12位(！！！)将补0值**，因此**PDT物理基地址**将在**4K边界上对齐(！！！**)。

### 4KB页PDE生成PT的物理基地址

`PDE[51：12]`(**最多30位, 加上12位0, 最大52位物理地址**)提供**PT的物理基地址高位**， **低12位全部补0**, PT地址为**4K边界对齐**。

如果物理地址比较小, **bit 51往下减少**.

### 4KB页PTE生成页面的物理基地址

`PTE[51：12]`提供**4K页面的高物理地址位(最多40位**),  **低12位全部补0**,  **页面地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 2MB页PDE生成页面的物理基地址

2MB页面**没有PT**, **PDE直接指向页面**.

① MAXPHYADDR为**52位**时，`2M page frame`地址的`[51：21]`(**高31位**)由`PDE[51：21]`提供。

② MAXPHYADDR为**40位**时，`2M page frame`地址的`[39：21]`(**高19位**)由`PDE[39：21]`提供，此时`PDE[51：22]`为保留位，必须为0。

③ MAXPHYADDR为**36位**时，`2M page frame`地址的`[35：21]`(**高15位**)由`PDE[35：21]`提供，此时`PDE[51：36]`为保留位，必须为0

`2M page frame`地址的`[20：0]`(**低21位！！！)补0**，因此**2M页面**的地址**在2M边界上对齐**。

### 最终物理地址的生成

上面可以看到, 所有页面基地址都是4KB或2MB边界对齐的, 再加上线性地址低位的偏移offset, 生成最终的物理地址.

# IA-32e分页

线性地址48位宽, 使用两级到四级的页转换表, 每个表项都是8字节宽, CR3是64位宽, 针对是否支持PCIDE功能, CR3使用不一样。

## 4KB页面线性地址翻译

使用`PML4T`（page map level-4 table，四层映射表），`PDPT`，`PDT`和`PT`。

用IA\-32e分页的到一个4KB页面的线性地址翻译

![config](./images/7.jpg)

**4KB页面线性地址构成: 9(PML4T索引, 512个项) \+ 9(PDPT索引, 512个项) \+ 9(PDT索引, 512个项) \+ 9(PT索引, 512个项) \+ 12(Page offset, 4KB页**)

每个table(PML4T, PDPT, PDT, PT)大小都是4KB = 512x8

## 3.2 2MB页面线性地址翻译

使用PML4T，PDPT和PDT。

用IA\-32e分页的到一个2MB页面的线性地址翻译

![config](./images/8.jpg)

**2MB页面线性地址构成: 9(PML4T索引, 512个项) \+ 9(PDPT索引, 512个项) \+ 9(PDT索引, 512个项) \+ 21(Page offset, 2MB页**)

每个table(PML4T, PDPT, PDT)大小都是4KB = 512x8

## 3.3 1GB页面线性地址翻译

使用PML4T和PDPT。

用IA\-32e分页的到一个1GB页面的线性地址翻译

![config](./images/9.jpg)

**1GB页面线性地址构成: 9(PML4T索引, 512个项) \+ 9(PDPT索引, 512个项) \+ 30(Page offset, 1GB页**)

每个table(PML4T, PDPT, PDT)大小都是4KB = 512x8

## 3.4 CR3和分页结构项

IA\-32e分页的CR3和分页结构项的格式

![config](./images/10.jpg)

## 3.5 物理地址组成

**线性地址48位宽(！！！**), **CR3已经是64位宽**,  支持**最高52位的物理地址**，依赖于**MAXPHYADDR值**。当MAXPHYADDR为**36**时只能映射到**36位的物理地址**，以此类推。

### 3.5.1 CR3生成PML4T物理基地址

CR3\[51：12\]提供**PML4T的物理地址高位(最多40位**), **低12位全部补0**,  **PML4T地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.2 PML4E生成PDPT的物理基地址

PML4E\[51：12\]提供**PDPT的物理地址高位(最多40位**),  **低12位全部补0**,  **PDPT地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.3 4KB页和2MB页PDPTE生成PDT的物理基地址

PDPTE\[51：12\]提供**PDT的物理地址高位(最多40位**),  **低12位全部补0**,  **PDT地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.4 1GB页PDPTE生成页面的物理基地址

1GB页面**没有PDT**, **没有PT**, **PDPTE直接指向页面**.

PDPTE\[51：30\]提供**PDT的物理地址高位(最多22位**),  **页面地址低30位全部补0**,  **页面地址1GB边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.5 4KB页PDE生成PT的物理基地址

PDE\[51：12\]提供**PT的物理地址高位(最多40位**),  **页表PT地址低12位全部补0**,  **页表PT地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.6 4KB页PTE生成页面的物理基地址

PTE\[51：12\]提供**页面的物理地址高位(最多40位**),  **页面地址低12位全部补0**,  **页面地址4K边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.7 2MB页PDE生成页面的物理基地址

2MB页面**没有PT**, **PDE直接指向页面**.

PDE\[51：21\]提供**页面的物理地址高位(最多31位**),  **页面地址低21位全部补0**,  **页面地址2MB边界对齐**.

如果物理地址比较小, **bit 51往下减少**.

### 3.5.8 最终物理地址的生成

上面可以看到, 所有页面基地址都是4KB, 2MB或1GB边界对齐的, 再加上线性地址低位的偏移offset, 生成最终的物理地址.

# 4 分页错误代码

![config](./images/11.jpg)
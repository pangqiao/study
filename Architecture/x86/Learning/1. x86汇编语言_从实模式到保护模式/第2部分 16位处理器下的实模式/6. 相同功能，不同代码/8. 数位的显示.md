第40行, 将保存有各个数位的数据区首地址传送到基址寄存器BX. 

一共有 5 个数字要显示, 其偏移地址分别是 BX(BX+0)、BX+1、BX+2、BX+3、BX+4. 这里, BX是基地址, 一般不变, 这里使用了SI作为索引, SI被称为索引寄存器(Index Register), 或者叫变址寄存器. 另一个常用的变址寄存器是DI. 

第41行, 初始索引值是4, 因为先显示万位上的数字. 

第43行, 偏移地址是 BX+SI. 但是, **它们之间的运算并非是在编译阶段进行的, 而是在指令实际执行的时候, 由处理器完成的**. 

第44行, 得到对应的ASCII码. 

第45行, AX中会是完整的字, AH是字符属性, AL是字. 

第46行, 在之前使用movsw传送字符串"Label offset: "也是使用DI. 传送结束后, DI指向了字符":"下一个位置. 

注意, 如图6-5, 数据的传达是按照**低端字节序**的, **寄存器的低字节传送到显示缓冲区的低地址部分**(字节), 寄存器的高字节传送到显示缓冲区的高地址部分(字节). 

第 47 行, 将 DI 的内容加上 2, 以指向显示缓冲区的下一个单元. 

第48行, 将SI内容减1, 下一次BX+SI指向千位数字. dec是减一指令, 和inc指令一样, 后面跟一个操作数, 可以是 8 位或者 16 位的通用寄存器或者内存单元. 

![config](images/3.png)

第 49 行, 指令 **jns show**, 如果**未设置符号位**, 则**转移到标号"show"所在的位置处执行**. 如图6-2, Intel处理器的标志寄存器里有**符号位 SF**(Sign Flag), 很多算术逻辑运算会影响到该位, 比如这里的**dec指令**. 如果**计算结果**的**最高位**是比特"0", 处理器把SF位置"0", 否则SF位置"1". 

SI初始值是4, 第一次执行dec si后, si内容为3, 二进制0000000000000011, 符号位是"0", 处理器将SF位清"0". 于是, 当执行jns show时, 发现未设置, 转移到标号"show"执行. 

显示完最后一个数位后, SI内容为0, 二进制0000000000000000. 执行 dec si 指令后, 由于产生了借位, 实际的运算结果是 0xffff(SI 只能容纳 16 个比特), 因其最高位是"1", 故处理器将标志位 SF 置"1", 表明当前 SI 中的结果可以理解为一个负数(－1). 于是, 执行 jns show 时, 条件不满足, 接着执行后面第 51 行的指令. 

jns是条件转移指令, 执行时要参考标志寄存器的SF位. 编译后的机器指令操作数也是一个相对偏移量, 是用标号处汇编地址减去当前指令的汇编地址, 再减去当前指令的长度得到. 
```
参考
http://blog.csdn.net/u013982161/article/details/52138155
```

## 一. 引入

保护模式下的段寄存器由 16位的选择器与64位的段描述符寄存器构成. 

段描述符寄存器:  存储段描述符

选择器: 存储段描述符的索引

![段寄存器构成](images/images11.png)

![GDTR、LDTR、IDTR、TR](images/images15.png)

PS: 原先实模式下的各个段寄存器作为保护模式下的段选择器，80486中有6个(即CS,SS,DS,ES,FS,GS)80位的段寄存器. 由选择器CS对应表示的段仍为代码段，选择器SS对应表示的段仍为堆栈段. 

## 二. 详解

### 1、全局描述符表GDT(Global Descriptor Table)

全局描述符表GDT(段)存在内存中，寄存器GDTR存放GDT的入口. 

全局描述符表GDT只有一张(**一个处理器对应一个GDT**)，GDT可以被放在内存的任何位置，但CPU必须知道GDT的入口，也就是基地址放在哪里，Intel提供了一个**寄存器GDTR用来存放GDT的入口地址**，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了. GDTR中存放的是GDT在内存中的基地址和其表长界限. 

基地址指定GDT表中字节0在**线性地址空间**中的地址，表长度指明GDT表的字节长度值. 

GDTR全局描述符寄存器: 48位，高32位存放GDT基址，低16为存放GDT限长. 

指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容. 在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF. 在保护模式初始化过程中必须给GDTR加载一个新值. 

### 2、段选择符(Selector)

段寄存器存放段选择符. 

由GDTR访问全局描述符表是通过“段选择符”(实模式下的段寄存器)来完成的. 段选择符是一个16位的寄存器(同实模式下的段寄存器相同)

![段选择符](images/images13.png)

段选择子包括三部分: 描述符索引(index)、TI、请求特权级(RPL). 

- index(描述符索引)部分表示所需要的**段的描述符在描述符表的位置**，由这个位置再根据在GDTR中存储的描述符表基址就可以找到相应的描述符. 然后用描述符表中的段基址加上逻辑地址(SEL:OFFSET)的OFFSET就可以转换成线性地址. 

- 段选择子中的TI值只有一位0或1，0代表选择子是在GDT选择，1代表选择子是在LDT选择. 

- 请求特权级(RPL)则代表选择子的特权级，共有4个特权级(0级、1级、2级、3级). 

关于特权级的说明: 任务中的每一个段都有一个特定的级别. 每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段. 系统约定，CPU只能访问同一特权级或级别较低特权级的段. 

例如给出逻辑地址: 21h:12345678h转换为线性地址

a. 选择符SEL=21h=0000000000100 0 01b 他代表的意思是: 选择子的index=4即100b选择GDT中的第4个描述符; TI=0代表选择子是在GDT选择; 左后的01b代表特权级RPL=1

b. OFFSET=12345678h若此时GDT第四个描述符中描述的段基址(Base)为11111111h，则线性地址=11111111h+12345678h=23456789h

### 3、段描述符(Segment Descriptor)

8个字节64位，每一个段都有一个对应的描述符. 

根据描述符描述符所描述的对象不同，描述符可分为三类: 储存段描述符，系统段描述符，门描述符(控制描述符). 在描述符中定义了段的基址，限长和访问内型等属性. 其中基址给出该段的基础地址，用于形成线性地址; 限长说明该段的长度，用于存储空间保护; 段属性 说明该段的访问权限、该段当前在内存中的存在性，以及该段所在的特权级. 

### 4、局部描述符表LDT(Local Descriptor Table)

局部描述符表LDT(段)存在内存中，描述这个的**描述符**存储在GDT中(也在内存中)，对应这个描述符的选择符存储在寄存器LDTR中. 

局部描述符表可以有若干张，每个任务可以有一张. 我们可以这样理解GDT和LDT: GDT为一级描述符表，LDT为二级描述符表. 如图

![LDT](images/images14.png)

LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中. 由于LDT本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在GDT中，对应这个描述符也会有一个选择子，LDTR装载的就是这样一个选择子. LDTR记录局部描述符表的起始位置，与GDTR不同，LDTR的内容是一个段选择子. 

LDTR局部描述符寄存器: 16位，高13为存放LDT在GDT中的索引值. 

LDTR可以在程序中随时改变，通过使用lldt指令. 如上图，如果装载的是Selector 2则LDTR指向的是表LDT2. 

举个例子: 如果我们想在表LDT2中选择第三个描述符所描述的段的地址12345678h. 

1. 首先需要装载LDTR使它指向LDT2 使用指令lldt将Select2装载到LDTR

2. 通过逻辑地址(SEL:OFFSET)访问时SEL的index=3代表选择第三个描述符; TI=1代表选择子是在LDT选择，此时LDTR指向的是LDT2,所以是在LDT2中选择，此时的SEL值为1Ch(二进制为11 1 00b). OFFSET=12345678h. 逻辑地址为1C:12345678h

3. 由SEL选择出描述符，由描述符中的基址(Base)加上OFFSET可得到线性地址，例如基址是11111111h，则线性地址=11111111h+12345678h=23456789h

4. 此时若再想访问LDT1中的第三个描述符，只要使用lldt指令将选择子Selector1装入再执行2、3两步就可以了(因为此时LDTR又指向了LDT1)
 
由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变LDTR就可以实现对不同进程的段进行访问. 

当进行任务切换时，处理器会把新任务LDT的**段选择符**和段描述符自动地加载进LDTR中. 在机器加电或处理器复位后，段选择符和基地址被默认地设置为0，而段长度被设置成0xFFFF. 

## 三、实例

### 1. 访问GDT

![GDT](images/images16.png)

当TI=0时表示段描述符在GDT中，如上图所示: 

①先从GDTR寄存器中获得GDT基址. 

②然后再GDT中以段选择器高13位位置索引值得到段描述符. 

③段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址(基址)，再以基址加上偏移地址yyyyyyyy才得到最后的线性地址. 

### 2. 访问LDT

![LDT](images/images17.png)

当TI=1时表示段描述符在LDT中，如上图所示: 

①还是先从GDTR寄存器中获得GDT基址. 

②从LDTR寄存器中获取LDT所在段的位置索引(LDTR高13位). 

③以这个位置索引在GDT中得到LDT段描述符从而得到LDT段基址. 

④用段选择器高13位位置索引值从LDT段中得到段描述符. 

⑤段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址(基址)，再以基址加上偏移地址yyyyyyyy才得到最后的线性地址. 

## 四、扩展

除了GDTR、LDTR外还有IDTR和TR

### 1、中断描述符表寄存器IDTR

与GDTR的作用类似，IDTR寄存器用于存放中断描述符表IDT的32位线性基地址和16位表长度值. 指令LIDT和SIDT分别用于加载和保存IDTR寄存器的内容. 在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF. 

### 2、任务寄存器TR

TR用于寻址一个特殊的任务状态段(TaskState Segment，TSS). TSS中包含着当前执行任务的重要信息. 

TR寄存器用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值. 它引用GDT表中的一个TSS类型的描述符. 指令LTR和STR分别用于加载和保存TR寄存器的段选择符部分. 当使用LTR指令把选择符加载进任务寄存器时，TSS描述符中的段基地址、段限长度以及描述符属性会被自动加载到任务寄存器中. 当执行任务切换时，处理器会把新任务的TSS的段选择符和段描述符自动加载进任务寄存器TR中. 


在nasm中可以在同一个源代码文件里同时指出16位代码、32位代码，以及64位代码。

```
bits 16￼
… …                               ; 以下是 16位代码￼
bits 32￼
… …                               ; 以下是 32位代码￼
bits 64￼
… …                               ; 以下是 64位代码
```

不用担心这里会有什么问题，**编译器**会为**每部分**生成**正确的机器指令**。关于16位机器码、32位机器码以及64位机器码，详见笔者个人网站里的《x86/x64指令系统》篇章，地址为 http://www.mouseos.com/x64/default.html 。

>16位编程、32位编程，以及64位编程有什么不同之处？

这确实需要简单了解一下。

# 通用寄存器

## 16位和32位

在16位和32位编程里，可以使用的通用寄存器是一样的，如下所示。

￼![2020-02-09-21-22-18.png](./images/2020-02-09-21-22-18.png)

在**16位编程**里可以使用**32位的寄存器**，在**32位编程**里也可以使用**16位的寄存器**，编译器会生成**正确的机器码**。

```
bits 16      ； 为16 位代码而编译￼
mov eax，1                   ； 机器码是：66 b8 01 00 00 00
```

上面这段代码为**16位代码编译**，使用了**32位的寄存器**，编译器会自动加上`default operand-size override prefix`（66H字节），这个`66H`字节用来调整为正确的操作数。

```
￼bits 32      ； 为32位代码而编译￼
mov eax，1                   ； 机器码是：b8 01 00 00 00
```

这段代码的汇编语句是完全一样的，只不过是为32位代码而编译，它们的机器码就是不一样的。

## x64体系

在**x64体系**里，在原来的**8个通用寄存器**的基础上**新增了8个寄存器**，并且原来的寄存器也得到了扩展。

在64位编程里可以使用的通用寄存器如下表所示。

￼![2020-02-09-21-24-01.png](./images/2020-02-09-21-24-01.png)

在64位编程里可以使用**20个8位寄存器**，和**16个16位**、**32位**及**64位寄存器**，寄存器体系得到了完整的补充。

**所有的16个寄存器**都可以分割出相应的8位、16位或32位寄存器。在16位编程和32位编程里，sp、bp、si及di不能使用低8位。在64位编程里，可以使用分割出的spl、bpl、sil及dil低8位寄存器。

64位的r8～r15寄存器分割出相对应的8位、16位及32位寄存器形式为：r8b～r15b、r8w～r15w，以及r8d～r15d。

```
￼bits 64      ； 为64位代码编译￼
mov r8b，1￼
mov spl，r8b
```

比如上面这两条指令必须在64位下使用，r8b和spl寄存器在16位和32位下是无效的。

# 操作数大小

在16位编程和32位编程下，寄存器没有使用上的不便，32位的操作数依旧可以在16位编程里使用，而16位的操作数也可以在32位编程下使用。

```
bits 16￼
push word 1                         ； 16位操作数￼
push dword 1                        ； 32位操作数￼
call ax       ； 16 位操作数￼
call eax       ； 32 位操作数￼
bits 32￼
push word 1                         ； 16位操作数￼
push dword 1                        ； 32位操作数￼
call ax       ； 16 位操作数￼
call eax       ； 32 位操作数
```

上面的代码完全可以用在16编程和32位编程里。在64位编程里操作数可以扩展到64位。

```
bits 64￼
mov rax，0x1122334455667788 ； 机器码是：b8 8877665544332211
```

这条指令直接使用了64位立即操作数。

# 64位模式下的内存地址

在64位编程里可以使用宽达**64位的地址值**。

## canonical地址形式

然而，在x64体系里只实现了**48位的virtual address**，高16位被用做符号扩展。这高16位必须要么全是0，要么全是1，这种形式的地址被称为canonical地址，如下所示。
￼
![2020-02-11-00-22-55.png](./images/2020-02-11-00-22-55.png)

与canonical地址形式相对的是`non-canoncial`地址形式，如下所示。在64位模式下non-canonical地址形式是不合法的。

![2020-02-11-00-23-55.png](./images/2020-02-11-00-23-55.png)
￼
在64位的线性地址空间里，

① 0x00000000_00000000到0x00007FFF_FFFFFFFF是合法的canonical地址。

② 0x00008000_00000000到0xFFFF7FFF_FFFFFFFF是非法的non-canonical地址。

③ 0xFFFF8000_00000000到0xFFFFFFFF_FFFFFFFF是合法的canonical地址。

在non-canonical地址形式里，它们的符号扩展位出现了问题。

2.4.4 内存寻址模式

在16位和32位编程里，16位和32位的寻址模式都可以使用。在64位下，32位的寻址模式被扩展为64位，而且不能使用16位的寻址模式。

16位内存寻址模式

在16位编程里，内存操作数的寻址模式如下所示。

￼
在16位寻址模式里基址只能使用bx和bp寄存器，变址只能使用si和di寄存器，displacement值使用8位或16位的偏移量。
32位内存寻址模式
在32位编程里，内存操作数的寻址模式如下所示。
￼
基址和变址可以是8个通用寄存器。displacement的值是8位或32位。
如以下指令中地址操作数的使用：
￼ mov eax，[eax + ecx*4 + 0x1c]
这是典型的“基址（base）加变址（index）寻址加上偏移量寻址”。
64位内存寻址模式
64位寻址模式形式和32位寻址模式是一致的，基址和变址寄存器默认情况下使用64位的通用寄存器。
64位寻址模式新增了一个RIP-Relative寻址形式。
RIP-Relative寻址：[rip+disp32]
这个displacement值是32位宽，地址值依赖于当前的RIP（指令指针）值。可是nasm的语法并不支持直接使用rip，像下面的用法是错误的。
￼ mov rax，[rip + 0x1c]     ； error：symbol 'rip' undefined
rip是处理器内部使用的寄存器，并不是外部编程可用的资源，但在yasm语法上是支持的。nasm中的解决方案是使用rel指示字。
￼ mov rax，[rel table]        ； rel指示字后面跟上一个地址label
这样就将编译为RIP-Relative寻址模式。RIP-Relative寻址最直接的好处是很容易构造PIC代码结构。
什么是PIC？PIC是指Position-Independent Code（不依赖于位置的代码）。
假设有一条指令调用了GetStdHandle（）函数。
￼ 00073BEC     FF15 DC810700      call  dword ptr [__imp__GetStdHandle]
call指令从 [__imp__GetStdHandle] 里读取 Kernel32.dll 库里的 GetStdHandle（） 入口地址，这里的__imp__GetStdHandle是绝对地址，地址值为 0x000781DC。

__imp__ReadFile：￼ 000781D4   A3 3E 4D 75￼ __imp__XXXX：￼ 000781D8   2C 3F 4D 75￼ __imp__GetStdHandle：￼ 000781DC   83 51 4D 75
在0x000781DC（__imp__GetStdHandle）里放着的就是GetStdHandle（）在库里的地址0x754D5183。
那么这条call指令就属于PDC（Position-Dependent Code，依赖于位置的代码）。
￼ FF15   DC810700            call   dword ptr [__imp__GetStdHandle@4 （781DCh）]￼      ----------￼   依赖于这个绝对地址
由于使用了绝对地址，当__imp__GetStdHandle的位置因重定位而有可能改变时，这条call指令就会出错，这个绝对地址已经不是__imp__GetStdHandle的地址了。
在x64体系的64位环境下，使用RIP-Relative很容易得到改善。
￼ 00073BEC  48 8d 85 e1 45 00 00  lea rbx，[rip + 0x45e1]  ； 得到 __IMP_FUNCTION_TABLE的地址￼ 00073BF3  48 03 1c c3              add rbx，[rbx + rax * 8] ； 得到 __imp_GetStdHandle 的地址￼ 00073BF7  ff 13                      call [rbx]                   ； call [__imp_GetStdHandle]￼ ... ...￼ __IMP_FUNCTION_TABLE：                               ；  函数表地址在 0x000781D4￼ 000781D4   A3 3E 4D 75￼ 000781D8   2C 3F 4D 75￼ 000781DC   83 51 4D 75                                ； GetStdHandle（）的入口地址
在nasm里应该是lea rbx，[rel__IMP_FUNCTION_TABLE]，这里使用rip是为了便于理解。使用lea指令配合RIP-Relative寻址得到的__IMP_FUNCTION_TABLE的地址不会因为重定位改变而改变，因为这里使用基于RIP的相对地址，没什么绝对地址，而这个代码的相对地址是不会变的。
内存寻址模式的使用
在16位编程和32位编程下依旧可以使用16位地址模式和32位地址模式。
￼ bits 16￼ mov ax，[bx+si]                        ； 使用 16 位地址模式￼ mov eax，[eax+ecx*4]                 ； 使用 32 位地址模式￼ bits 32￼ mov ax，[bx+si]                        ； 使用 16 位地址模式￼ mov eax，[eax+ecx*4]                 ； 使用 32 位地址模式
指令的默认地址（16位或32位）依赖于CS.D标志位（在保护模式章节会有详细的描述），CS.D=1时使用32位的寻址模式，CS.L=0使用16位的寻址模式。
上面的代码中，编译器会生成正确的机器指令，当改变default address-size（默认的地址尺寸）时，生成的机器指令会相应地插入67H（address-size override prefix）这个前缀值。
在64位模式下，也可以使用67H改变默认的64位寻址模式，改变为32位的寻址模式。
2.4.5 内存寻址范围
在正常的情况下，16位实模式编程里，虽然可以使用32位的寻址模式，可是依然逃不过64K内存空间的限制（实际上可以改变地址值大小，在后面实模式的章节里进行探讨）。
假如在16位实模式下写出如下代码。
￼ mov eax，0x200000                       ； 2M 地址￼ mov eax，[eax]                           ； 错误：> 64K￼ mov eax，0x2000￼ mov ecx，1￼ mov eax，[eax + ecx * 4]              ； 正确：<= 64K
在32位保护模式下，可以寻址4G的线性空间，OS通常的做法会使用最大的4G寻址空间；而在64位环境，寻址空间增加到了64位，这个空间大小是不会改变的。
2.4.6 使用的指令限制
有些指令在64位环境里是不可用的，在编程过程中应避免，典型的如push cs/ds/es/ss指令和pop ds/es/ss指令，这些在16位和32位下常用的指令在64位模式下是无效的。
￼ call 0x0018：0x00100000               ； 无效￼ jmp  0x0018：0x00100000                ； 无效
这些常用的direct far call/jmp（直接的远程call/jmp）也是无效的。此外还需要注意是否有权限去执行指令，像cli/sti这类指令需要0级的执行权限，in/out指令需要高于eflags.IOPL的执行权限。这里不再一一列举。
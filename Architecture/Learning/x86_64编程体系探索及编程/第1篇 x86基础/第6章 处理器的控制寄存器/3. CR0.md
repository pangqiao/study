
CR0里有许多重要的控制位，其中最重要的一个是PE控制位，它决定着处理器处于保护模式还是实模式。

# 保护模式位PE

处理器在**初始化后**，`CR0.PE=0`则处于**实模式**状态。当置`CR0.PE=1`时，表示处理器处于**保护模式**状态下，处理器将按照保护模式下的行为进行运作。

> 为处理器提供保护模式的执行环境，这是系统软件的职责。处理器只负责按照保护模式的规则运行

# x87 FPU单元的执行环境

x87 FPU的执行环境涉及4个控制位：CR0.NE，CR0.EM，CR0.TS，以及CR0.MP控制位。

## CR0.NE（bit 5）

CR0.NE决定x87 FPU单元使用哪种异常处理模式：native（原生）模式，以及DOS compatibility模式。

① CR0.NE=1时，使用native异常处理模式。当发生x87 FPU numeric异常时由处理器直接处理。

② CR0.NE=0时，使用DOS-compatibility异常处理模式。当发生x87 FPU numeric异常时，处理器的FERR# pin连接到外部的PIC（中断控制器，如8259或I/O APIC）的IRQ13有效。再经8259中断控制器发出中断请求，处理器响应执行IRQ13中断服务例程。

关于CR0.NE及x87 FPU numeric异常处理详情，请参考第20章的相关描述。

## CR0.EM（bit 2）

CR0.EM是x87 FPU执行单元模拟位，用软件形式来摸拟x87 FPU指令的执行。当CR0.EM置位时，执行x87 FPU指令会产生#NM（Device not available）异常，指示无x87 FPU单元或不可用。由软件在#NM处理程序里摸拟执行x87 FPU单元指令。

CR0.EM对两类指令产生影响，如下所示。

CR0.EM置位时，执行MMX与SSE系列指令会产生#UD（invalid opcode）异常。

## CR0.TS（bit 3）

CR0的bit3是TS（Task Switched）控制位，当处理器发生task switch（处理器提供的硬件级任务切换机制）时，会对eflags.NT标志进行置位，同时还会对CR0.TS进行置位，指示当前发生过任务切换。

值得注意的是，处理器只负责对CR0.TS置位，从不对CR0.TS清位处理。CR0.TS清位是软件的职责。软件可以使用clts指令对CR0.TS进行清位，clts指令需在0级权限下使用。

除了处理器在任务切换时自动置位，系统软件也可以在进程调度时主动使用mov cr0，reg指令对CR0.TS进行置位。

什么时候需要对CR0.TS进行置位？CR0.TS置位会有什么影响？实际上CR0.TS控制位的设立，就是处理器和系统软件的交互，让系统软件知道目前处于切换中，需要进行一些必要的工作。
这是下面将要了解的内容，CR0.TS置位对通用指令来说没什么影响，它会对x87 FPU（浮点执行单元）和MMX/SSE系列指令产生影响。

当CR0.TS=1时，执行x87 FPU指令会产生#NM异常，并且在CR0.EM=0时，执行MMX/SSE指令也会产生#NM异常。
我们看到：CR0.EM=1或者CR0.TS=1时，执行x87 FPU指令都会产生#NM异常。前面我们看到，当CR0.EM=1时，执行MMX/SSE指令会产生#UD异常。
实验6-1：测试在TS=1，EM=1时，对执行X87 FPU和MMX/SSE指令的影响
根据上面的了解，在TS=1，EM=1的时候，应该是：执行x87 FPU指令会产生#NM异常，执行MMX/SSE指令会产生#UD异常（EM=1时不受TS影响）。
在测试指令前，我们先开启TS和EM标志，同时也开启CR4.OSFXSR标志（将在后面了解）。
代码清单6-1（topic06\ex6-1\protected.asm）：

；； 开启 CR0.TS 位      mov eax，cr0      bts eax，3                                                ； CR0.TS=1      bts eax，2                                                ； CR0.EM=1      mov cr0，eax；； 开启 CR4.OSFXSR 位      mov eax，cr4      bts eax，9                                                ； CR4.OSFXSR=1      mov cr4，eax
开启CR4.OSFXSR控制位是为了可以执行MMX/SSE指令，我们在用户代码里的测试代码如下。
代码清单6-2（topic06\ex6-1\protected.asm）：
；； 通过 stack 给 interrupt handler 传递参数，下一条指令执行点      push DWORD n1；；测试 x87 fpu 指令      fild DWORD [mem32int]；； 通过 stack 给 interrupt handler 传递参数，下一条指令执行点n1：      push DWORD n2；； 测试 sse 指令      movdqu xmm1，xmm0n2：
先测试x87 FPU指令fild，再测试SSE指令movdqu，执行结果如下。

第1次产生的是#NM异常，第2次产生的是#UD异常。假如将EM标志清0，得到的结果如下。

在EM=0，TS=1的情况下，两次产生的异常都是#NM异常。
CR0.MP（bit 1）
CR0.MP是MP（Monitor Coprocessor）控制位，MP的设置是为了监控wait/fwait指令的执行，CR0.MP并不是单独使用的，必须要配合CR0.TS控制位一起使用。
当CR0.MP=1并且CR0.TS=1时，执行wait/fwait指令将产生#NM异常。
CR0.MP和CR0.TS任1个被清0都不会对wait/fwait指令进行监控。
为什么需要对这些x87 FPU/MMX/SSE系列，以及wait/fwait指令的执行进行监控呢？
我们知道，OS系统在切换进程时，需要保存被切换进程的context（上下文环境）以便可以切换回来。大多数系统实现的时候，这些进程的context并不包括进程的x87 FPU和SSE（包括AVX指令）的执行环境，这是因为：
① 在切换进程时，额外保存这些x87 FPU和SSE执行环境的context需要耗费不少的CPU时间。调度进程的时间是非常宝贵的。
② 部分软件可能会不使用x87 FPU或SSE指令，对于不使用x87 FPU和SSE指令的软件没有必要额外保存这些执行环境。
处理器提供的方案是：在进程切换完毕后，在新进程的执行过程中，遇到第1条x87 FPU/MMX/SSE以及AVX指令执行时进行监控，产生#NM异常。
在#NM处理程序里使用FXSAVE/FXRSTOR指令进行保存原进程的x87 FPU/MMX/SSE以及AVX指令（使用XSAVE指令）的执行环境context。在这种情况下，如果新进程里不包括x87 FPU/MMX/SSE以及AVX指令，软件不需要承担这些指令context的切换。同时也能及时进行进程的调度。



上面的表格对CR0.EM、CR0.TS以及CR0.MP控制位对指令的影响进行了总结。只有当CR.EM=0，CR0.TS=1以及CR0.MP=1的时候，x87 FPU/MMX/SSE和wait/fwait指令才都会产生#NM异常。
在系统初始化阶段推荐的设置是：NE=1，MP=1，以及EM=0。
EM=0保证使用native的x87 FPU/MMX/SSE指令执行环境，NE=1保证使用native的x87 FPU numeric异常处理模式，而MP=1/EM=0时，在任务切换时（TS=1）可以保证能监控x87FPU/MMX/SSE系列指令以及wait/fwait指令的执行。

# CR0.PG控制位

CR0.PG置1时将开启**页式管理机制**。开启页式管理前**必须要打开保护模式**，否则将产生`#GP`异常。显然在打开页式管理机制之前，应该先构造好整个页转换结构表，一旦CR0.PG被置位，则表示马上使用分页机制。
在页式内存管理机制中，虚拟地址被映射到物理地址上，物理地址的寻址范围可以超过虚拟地址。典型的如：可以将一个32位宽的线性地址空间映射在36位宽的物理地址空间上。

# CR0.CD与CR0.NW控制位

`CR0.CD`（**Cache Disable**）与 `CR0.NW`（**Not Write-through**）结合起来对处理器内部的cache进行控制。当`CD=1`时，memory**不被cache**，当`NW=1`时，处理器**不维护memory的一致性**。

通俗地讲：

* 当`CD=1`时表示memory的cache是disable状态，对新的memory访问时，不会被加载到cache中；

* 而`NW=1`时，表示`Not Write-through`（**不直写**），不回写memory。

CR0.CD与CR0.NW是**组合使用**的，Intel明确列出了它们组合产生的影响

* 当`CD=0`而`NW=1`时，这是错误的，会产生`#GP`异常（表明：**memory cache是开启的**，但是却**不维护memory的完整性**，显然不正确）；

* `CD=0`且`NW=0`是对cache的正常使用方法，表明：memory cache开启也需要维护memory的完整。

实验6-2：测试CD=0，NW=1

实验的源代码在topic06\ex6-2\目录下，结果如下。

当CD=0且NW=1时，产生#GP异常。

如何维护cache与memory的一致性？

Intel处理器上使用MESI（modified，exclusive，shared，invalid）协议维护处理器cache之间以及memory的一致性。

当cache line的状态是M，E，S时cache是有效的。为I状态时，cache line失效将被写往memory上，当发生cache write hit（写cache）时，S状态改为M状态（共享cache line被标记为已经改写），这时对应的memory的数据是失效的。

当这个M状态的cache line变为I（Invalid）状态时，处理器会写往memory，保证memory数据保持同步有效。系统软件也可以使用INVD指令发起置cache line无效，强迫写往memory（data cache不回写，将丢失），使用WBINVD指令回写所有Modified状态的cache line并使这些cache line置为I状态。CLFLUSH指令提供一个需要flush的地址，将包含这个地址的cache line回写到memory上。

对于S状态的cache line发生write hit时，同时也从S状态改为E（独占）状态，可以看到M状态，E状态以及S状态都不写memory，除非上述所说的发起写操作。而AMD的机器上使用了MOESI协议，多了一个Owned状态。

回到CD和NW控制位来，CD=0以及NW=0时，当发生write miss时会引起cache line fill操作，这时如果cache line是S（共享）状态的，在cache line fill操作之前，会写往memory，保证memory数据的完整性。cache write hit时，如果是S状态的，会将shared line改为modified line，cache line会被更新。当发生read hit时正常读，read miss时引发replacement操作。

当CD=1以及NW=0时，cache line不会发生新的fill操作，但是会维护现有cache line的完整性。那么当发生write miss时，处理器不会进行cache line fill操作（因为CD=1），此时处理器会直接发起访问memory操作，同样如果是修改shared line会引起回写memory操作，write hit时会正常更新cache line；而read miss时也不会引发replacement操作。

当CD=1以及NW=1时，cache line不会发生新的fill操作，也不会维护memory的完整性。read hit得到正常访问，read miss不会replacement；write hit将更新现有的cache line，如果是E状态的，将E状态改为M状态，如果是S状态的维持S状态不变；write miss将直接发起访问memory。

# CR0.WP控制位

`CR0[16]`是WP（Write Protect）控制位。当WP=1时，即使拥有supervisor权限的程序也不能修改read-only页。相反WP=0时，允许supervisor权限的程序修改read-only页。
对于页级的supervisor权限是指0，1以及2级权限，user权限是指3级权限。

# CR0.AM控制位

在上一章中，我们已经了解到：仅当CR0.AM=1并且eflags.AC=1时，可以使处理器开启地址边界对齐检查机制。当AM或AC其中一个为0时，这个对齐检查机制是关闭的。当检查不通过时会产生#AC异常，而这个#AC异常仅在3级权限下才会发生。

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. BTS机制](#1-bts机制)
  - [1.1. DS 区域](#11-ds-区域)
    - [1.1.1. 三个组成](#111-三个组成)
    - [1.1.2. 两类信息](#112-两类信息)
- [2. 检测DS(Debug Store)是否支持](#2-检测dsdebug-store是否支持)
  - [2.1. 两个寄存器](#21-两个寄存器)
- [3. Debug store 64存储格式](#3-debug-store-64存储格式)
  - [3.1. 检测是否支持DS 64位格式](#31-检测是否支持ds-64位格式)
- [4. 检测BTS(Branch Trace Store)机制是否可用](#4-检测btsbranch-trace-store机制是否可用)
- [5. 检测PEBS(Precise Event Based Sampling)机制是否可用](#5-检测pebsprecise-event-based-sampling机制是否可用)
- [6. Debug Store存储区域](#6-debug-store存储区域)
  - [6.1. DS 基地址](#61-ds-基地址)
  - [6.2. DS 组成](#62-ds-组成)
  - [6.3. DS 格式](#63-ds-格式)
  - [6.4. DS 区域基地址与 BTS 域地址](#64-ds-区域基地址与-bts-域地址)
  - [6.5. DS 管理区域](#65-ds-管理区域)
    - [6.5.1. BTS与PEBS buffer base](#651-bts与pebs-buffer-base)
    - [6.5.2. BTS与PEBS index](#652-bts与pebs-index)
    - [6.5.3. BTS与PEBS maximum](#653-bts与pebs-maximum)
    - [6.5.4. BTS与PEBS threshold](#654-bts与pebs-threshold)
    - [6.5.5. maximum值的设置](#655-maximum值的设置)
    - [6.5.6. threshold值的设置](#656-threshold值的设置)
    - [6.5.7. PEBS counter](#657-pebs-counter)
  - [6.6. BTS记录格式](#66-bts记录格式)
  - [6.7. PEBS记录格式](#67-pebs记录格式)
    - [6.7.1. 检测PEBS记录的长度](#671-检测pebs记录的长度)
- [7. 设置DS存储区域](#7-设置ds存储区域)
- [8. 使用环形回路BTS buffer](#8-使用环形回路bts-buffer)
  - [8.1. BTS threshold值的设置](#81-bts-threshold值的设置)
  - [8.2. 值得注意](#82-值得注意)
- [9. 使BTS buffer产生DS中断](#9-使bts-buffer产生ds中断)
  - [9.1. 判断中断触发的原因](#91-判断中断触发的原因)
    - [9.1.1. 确定PMI触发](#911-确定pmi触发)
    - [9.1.2. 确定BTS buffer满的DS中断触发](#912-确定bts-buffer满的ds中断触发)
    - [9.1.3. 确定PEBS buffer满时DS中断触发](#913-确定pebs-buffer满时ds中断触发)
    - [9.1.4. 确定PEBS中断触发](#914-确定pebs中断触发)
  - [9.2. 编写DS中断handler](#92-编写ds中断handler)
    - [9.2.1. 关闭功能](#921-关闭功能)
    - [9.2.2. PEBS buffer满时](#922-pebs-buffer满时)
    - [9.2.3. Counter溢出时](#923-counter溢出时)
    - [9.2.4. BTS buffer满时](#924-bts-buffer满时)
    - [9.2.5. PEBS中断](#925-pebs中断)
    - [9.2.6. 恢复原有的功能设置](#926-恢复原有的功能设置)
    - [9.2.7. 清LVT performance monitor寄存器mask位](#927-清lvt-performance-monitor寄存器mask位)
- [10. 过滤BTS记录](#10-过滤bts记录)
  - [10.1. BTS_OFF_OS](#101-bts_off_os)
  - [10.2. BTS_OFF_USR](#102-bts_off_usr)
  - [10.3. 注册中断服务例程](#103-注册中断服务例程)
  - [10.4. 在用户代码里测试](#104-在用户代码里测试)
- [11. 64位模式下的BTS机制](#11-64位模式下的bts机制)

<!-- /code_chunk_output -->

# 1. BTS机制

BTS机制允许**BTM(Branch Trace Message**)存储在**内存DS(Debug Store)save区域**里. 

我们从14.3.1节里的表14\-1知道: 

![config](./images/36.jpg)

当IA32\_DEBUGCTL寄存器的**TR=1**并且**BTS=1**时, **BTM**将存放在**DS save区域**内的**BTS buffer**里, 并且由**BTINT位**可以配置为**环状的buffer**或者**buffer满时产生DS(debug store)interrupt**. 

## 1.1. DS 区域

### 1.1.1. 三个组成

在**内存DS save区域**里包括**三部分**. 

① **DS管理配置区域**: 用来配置和管理**BTS buffer**和**PEBS buffer**区域. 

② **BTS buffer**区域: 这是**BTM记录**存放在内存中的buffer区域. 

③ **PEBS buffer区域**: **PEBS(Precise Event Based Sampling！！！**)允许处理器在**某个事件(中断)发生**后**产生PEBS记录(记录处理器状态**), PEBS记录存放在内存中的buffer区域. 

### 1.1.2. 两类信息

因此, **DS(debug store**)save 区域可以收集**两类信息**. 

① **BTS信息**: 在BTS buffer区域存储**branch记录信息**. 

② **PEBS信息**: 在PEBS buffer区域存储**处理器状态信息(！！！**), PEBS机制是**Performace monitoring(性能监控)机制里的一部分(！！！**). 

**PEBS机制**允许当**某个事件监控中的counter(计数器)溢出**时, 处理器在**debug store区域**的**PEBS buffer**保存处理器的**相关状态信息(典型地如寄存器的值**). 关于PEBS机制, 我们会在第15章里详细探讨. 

# 2. 检测DS(Debug Store)是否支持

Debug Store存储区域是**BTS机制的基石**, 因此在**软件使用前**, 必须通过`CPUID.01: EDX[21]`查询处理器**是否支持Debug Store机制**. 

代码清单14-14(lib\debug.asm): 

```assembly
; ------------------------
; support_deubg_store(): 查询是否支持 DS 区域
;  output: 
;   1-support, 0-no support
; ------------------------
support_deubg_store: 
      mov eax, 1
      cpuid
      bt edx, 21    ;  DS 位
      setc al
      movzx eax, al
      ret
```

## 2.1. 两个寄存器

当**支持Debug Store区域**时, 处理器可以使用下面的功能. 

① 使用`IA32_MISC_ENABLE`寄存器**来检测**当前BTS机制是否可用**. 

② 使用`IA32_DS_AREA`寄存器**来设置**debug store区域**. 

值得注意的是, Intel特别注明, 在**SMM模式下DS机制是不可用(！！！**)的. 

# 3. Debug store 64存储格式

Intel已经**增强了DS(debug store**)功能, 使得**无论是否开启IA\-32e模式**(longmode)都支持**64位的debug store格式**, 我们将在稍后了解64位的DS格式. 

## 3.1. 检测是否支持DS 64位格式

软件可以使用**CPUID.01: ECX\[2\].DTES64位**检测**是否支持DS64格式**, 代码如下. 

代码清单14-15(lib\debug.asm): 

```assembly
; ------------------------------------
;  support_ds64: 查询是否支持 DS save 64 位格式
;  output: 
;   1-support, 0-no support
; -----------------------------------
support_ds64: 
      mov eax, 1
      cpuid
      bt ecx, 2    ;  DEST64 位
      setc al
      movzx eax, al
      ret
```

当**DTES64位为1**时, 表明处理器支持debug store 64位格式, 而**不依赖于IA\-32e模式的开启(！！！**), 这一点非常重要, 它决定了**debug store存储区域的格式**, 包括: 

① **64位**的**DS管理记录格式**. 

② **64位**的**BTS记录格式**. 

③ **64位**的**PEBS记录格式**. 

# 4. 检测BTS(Branch Trace Store)机制是否可用

**IA32\_MISC\_ENABLE寄存器**的bit 11位指示BTS是否可用, 代码如下. 

代码清单14-16(lib\debug.asm): 

```assembly
; ---------------------------------
;  available_branch_trace_store(): 
;  output: 
;   1-available, 0-unavailable
; ---------------------------------
available_branch_trace_store: 
      mov eax, 1
      cpuid
      bt edx, 21
      setc al
      jnc available_branch_trace_store_done  ;  no-support
      mov ecx, IA32_MISC_ENABLE
      rdmsr
      bt eax, 11         ;  BTS unavailable 位
      setnc al
available_branch_trace_store_done: 
      movzx eax, al
      ret
```

这个函数先测试**是否支持DS功能**, 然后通过**IA32\_MISC\_ENABL寄存器**来测试BTS功能软件是否可用. 注意, 当IA32\_MISC\_ENABLE[11]=1时, 指示BTS机制是不可用的; 为0时BTS可用. 

# 5. 检测PEBS(Precise Event Based Sampling)机制是否可用

`IA32_MISC_ENABLE`寄存器的bit 12位还指示**PEBS功能是否可用**, 代码如下. 

代码清单14-17(lib\debug.asm): 

```assembly
; ---------------------------------
;  avaiable_pebs(): 是否支持 PEBS 机制
;  output: 
;   1-available, 0-unavailable
; --------------------------------------
available_pebs: 
      mov eax, 1
      cpuid
      bt edx, 21
      setc al
      jnc available_pebs_done
      mov ecx, IA32_MISC_ENABLE
      rdmsr
      bt eax, 12     ;  PEBS unavailable 位
      setnc al
available_pebs_done: 
      movzx eax, al
      ret
```

这个测试函数与上面的available\_branch\_trace\_store()函数原理完全一样, 只不过它是测试bit 12位的PEBS unavailable标志位. 

上面的4个测试将**影响到整个DS机制**, 我们可以写一个测试函数来检查处理器是否支持这些功能, 在笔者的Westmere架构的Corei5处理器上测试的结果为. 

![config](./images/37.jpg)

在这个结果里, 可以看到Westmere架构上支持DTES64功能, 在Nehalem架构上也应该支持. 而BTS与PEBS机制是可用的. 这个功能是调用dump\_support\_ds()来打印的, 实现在lib\debug.asm文件里, 调用了上面的4个测试函数来得到结果. 

# 6. Debug Store存储区域

BTS记录存放在DS(debug store)区域的BTS buffer里. 

## 6.1. DS 基地址

由**IA32\_DS\_AREA寄存器**设置**整个DS save area区域的base地址值**, 如下面代码所示. 

```assembly
mov ecx, IA32_DS_AREA
mov eax, DS_SAVE_BASE     ;  DS区域基地址
mov edx, 0
wrmsr         ;  写入DS地址
```

## 6.2. DS 组成

整个Debug Store区域分为三个部分. 

① DS management area(**DS管理区域**): 它包含了BTS管理区与PEBS管理区, 提供对BTS buffer与PEBS buffer的管理和设置. 

② BTS buffer: 这是**BTS记录**存放的区域. 

③ PEBS buffer: 这是**PEBS记录**存放的区域. 

## 6.3. DS 格式

从前面我们知道**DS区域**可以分为**32位**与**64位**格式, 我们在设置前必须**首先检查是否支持DTES64格式**(否则DS区域的设置将是错误的), 处理器在下面的情况下使用DS64格式. 

![config](./images/38.jpg)

下图分别是32位与64位格式的DS区域. 

![config](./images/39.jpg)

在32位与64位中的DS区域结构是一致的, 所不同的是**32位格式**的DS区域的**记录宽度是32位**的, 而**64位的DS区域(！！！**)是**64位宽**. 

在IA\-32e模式开启(无论是否支持DTES64功能)时或者在支持DTES64(64位的DS格式)功能的处理器上, 使用的都是64位的DS区域. 在不支持DTES64功能的处理器处于legacy模式时, 使用的是32位的DS区域. 

## 6.4. DS 区域基地址与 BTS 域地址

IA32\_DS\_AREA寄存器存放的值就是**DS区域地址**, 因此IA32\_DS\_AREA寄存器将指向BTS管理区地址. 如上所示, **BTS管理区的地址**就是**整个DS管理区域的基地址(相等**). 

在64位模式下IA32\_DS\_AREA寄存器可以设置64位**线性地址(！！！**)值, 32位模式下设置32位的线性地址值, 高32位被保留. 

## 6.5. DS 管理区域

**整个DS管理区域**包括了对**BTS buffer**与**PEBS buffer**的**管理和设置**, BTS buffer与PEBS buffer具有相同的设置值(除了**PEBS管理区多了4个counter reset值**). 

处理器会**自动动态地维护DS管理区域**中的**BTS buffer**与**PEBS buffer管理记录**. 这些管理记录值都是**线性地址值(！！！**). 

### 6.5.1. BTS与PEBS buffer base

BTS buffer base提供**BTS buffer的线性基地址**, 而PEBS buffer base提供**PEBS buffer线性基地址**. 

这些地址需要**在double word边界**上对齐. 

### 6.5.2. BTS与PEBS index

**BTS与PEBS**的**index值**是指向**下一条BTS记录**与**PEBS记录存放的线性地址**. 

当处理器在index指向的位置写入BTS与PEBS记录后, **index的值**将更新为**下一条记录的地址**. 处理器**自动维护这个index值(！！！**). 

BTS与PEBS的index值和LBR stack中的TOP指针是有区别的: **TOP指针**指向**当前已写记录的位置**, 而**index值**指向**下一条记录将要写的位置**. 

### 6.5.3. BTS与PEBS maximum

maximum值决定BTS buffer与PEBS buffer的**大小**, 它指向BTS buffer与PEBS buffer**最后的记录(最大可容纳记录数**)**下一个字节**的**线性地址值**. 

假设在**32位DS区域**下, BTS buffer与PEBS buffer最大可容纳10条记录, 那么: 

① **BTS** maximun值应为`BTS buffer base + 10×12`(注: **每条BTS记录是12个字节！！！**)

② **PEBS** maximum值应为`PEBS buffer base + 10×40`(注: **每条PEBS记录是40个字节！！！**)

假设在**64位DS区域**下, 同样BTS与PEBS buffer最大容纳10条记录, 那么: 

① **BTS** maximum值应为`BTS buffer base + 10×24`(注: **每条BTS记录是24个字节**)

② **PEBS** maximum值应为`PEBS buffer base + 10×144`(注: **每条PEBS记录为144个字节**, 在**增强PEBS记录下是176个字节**). 

对于BTS与PEBS记录, maximum是有一些区别的. 

① 当**BTS buffer**配置为**环形的buffer(BTINT=0**)时, index达到maximum时重置为base值, 这将会**回到base处重新继续写记录**. (前提是**threshold值大于maximum值**. )

② 当**PEBS index**达到PEBS maximum值时, **index不会被重置为base值**, 需要软件进行重置. 

我们将在后面了解到BTS与PEBS记录的结构与增强PEBS记录结构. 

### 6.5.4. BTS与PEBS threshold

**Threshold值**是个**产生DS interrupt的临界值**, 当BTS **index**或PEBS index的值达到BTS **threshold**值或PEBS threshold值时(等于或大于), 将产生**DS interrupt(debug store中断！！！**)来提示跨越了buffer maximum边界(也就是buffer溢出了). 

threshold值必须是**记录字节的倍数**, 例如: **threshold=buffer base\+11×24**(第11条记录是threshold值). maximum与threshold值的设置很关键, 将直接影响buffer区域的工作. 

BTS threshold值的设置基于**两种BTS buffer的配置**而不同. 

① 当**BTINT=0**时, BTS buffer配置为**环形回路buffer**, BTS buffer满时从头开始继续写. 

② 当**BTINT=1**时, 当**BTS buffer满**时**产生DS中断(！！！**)来提醒软件BTS buffer已满, 软件需要进行相应的处理. 

下图是一个BTS buffer区域设置的示例. 

![config](./images/40.jpg)

在这个示例里, BTS buffer可以容纳10条记录(编号从0到9), **每条记录**是**24个字节(18H宽**), 那么**整个BTS buffer的大小**为10×24=240个字节, 即**F0H(偏移量从0H到0EFH**). 

BTS maximum的值设置为base\+10×24(即F0H位置), BTS threshold的值必须大于BTS maximum值, 示例里设置为BTS maximum记录的下一条记录起始处(即108H位置). 

### 6.5.5. maximum值的设置

在上面的示例里, 由于buffer的大小是10条记录. 那么记录10的起始边界F0H(记录9下一条记录的起始字节)就可以设为BTS maximum值. 

在Intel64手册里, 对maximum值的一段话如下: 

BTS absolute maximum—Linear address of the next byte past the end of the BTS buffer. This address should be a multiple of the BTS record size (12 bytes) plus 1.

这段话的前一句比较容易理解, 而后一句话似乎表明maximum的值为记录字节倍数加上1值, 实际上在笔者的测试中并不需要加上1值(即下一条记录的起始字节就可以了). 

值得注意的是, **即使进入PMI handler**(如果**threshold小于maximum**, 由于遇到threshold而**产生DS中断**), **BTS buffer仍然被写满**, 直到BTS maximum值. 

### 6.5.6. threshold值的设置

当BTS buffer配置为环形回路buffer时, BTS threshold的值必须大于BTS maximum, 避免index达到threshold值而产生DS中断. 如上图中的环形BTS buffer配置示例所示. 

当BTS buffer配置为满产生DS中断时, BTS threshold的值应该等于BTS maximum值, 确保index达到maximum(BTS buffer写满时)产生DS中断. 

![config](./images/41.jpg)

如上所示, 这是一个**非环形BTS buffer**的配置示例, BTS threshold的值设置等于BTS maximum值. 当index写满记录9, 达到BTS maximum(BTS threshold)时产生DS中断. 

BTS buffer无论配置为**circular(环形**)还是**non\-circular(threshold中断**), BTS threshold的值都**不应该小于BTS maximum值**. 

因此, **正确的方案**是, BTS **threshold要么大于maximum(环形回路！！！**), 要么**等于maximum值(threshold中断或者说BTS buffer溢出中断！！！**). 

当BTS threshold小于BTS maximum时, index达到threshold值时产生DS中断(此时buffer未满), 而不依赖于是否配置为”满时产生中断"(即使环形的buffer也产生DS中断). 如果确实需要在buffer未满时就产生DS中断来提醒, 那么在这种情况下可以设置BTS threshold值小于BTS maximum值. 

### 6.5.7. PEBS counter

当**每个IA32\_PMC counter(通用计数器**)配置为, 因**counter(计数器**)溢出产生**PEBS中断**而**不是PMI(performance monitoring interrupt)中断**(尽管都使用**同一个中断vector**)时. 

当**产生PEBS中断**时, 相应的**IA32\_PMC(通用计数器寄存器**)值可以**从PEBS管理区中的counter值(！！！**)来得到**重置**. 

Nehalem微架构及后续架构支持4个IA32\_PMC0到IA32\_PMC3计数器**产生PEBS中断**, 因此在PEBS管理区里需要设置**4个counter值**(对应于IA32\_PMC0到IA32\_PMC3). 

## 6.6. BTS记录格式

**每条BTS记录**分为**3个部分**. 

① last branch from: 记录分支的**源地址**. 

② last branch to: 记录分支的**目标地址**. 

③ branch predicted: 这部分的**bit 4位**指示分支是属于**predicted(预测的**), 还是**non\-predicted(非预测的**). 

在**32位格式**里, **每部分为4字节**, **每条记录**为**12字节**. 在64位格式里, 每部分为8字节, 每条记录共为**24个字节**. 

![config](./images/42.jpg)

与LBR stack中的from/to地址一样, 这些BTS记录中的from和to地址都是**线性地址值**, 当BTS buffer能容纳10条记录时, 那么最多有10条这样的记录, **每条记录**按**先后顺序**存放在BTS buffer区域(**由低往高地址存放**)中. 

## 6.7. PEBS记录格式

PEBS是指**Precise Event Based Sampling**(直译为**基于抽样的精确事件！！！**), PEBS记录实际上保存着**处理器的context(上下文)状态**, 也就是包括: **EFLAGS寄存器**, **EIP值**, 以及**GPR(通用寄存器**)值. 

![config](./images/43.jpg)

在**32位**格式里, PEBS记录的**每个部分**是**32位宽**, 保存**32位的寄存器值**, 于是将**保存8个通用寄存器**. **每条PEBS记录**共**40个字节**. 

![config](./images/44.png)

上面是**64位**的PEBS记录格式, PEBS记录**每个部分**是**8字节**宽. 最初的Core架构64位PEBS记录是**144个字节**, 保存**RFLAGS寄存器**、**RIP值**, 以及**16**个**64位通用寄存器(从RAX到R15**). 

从Nehalem微架构开始, PEBS机制得到增强, **每条PEBS**记录扩展到**176个字节**, 除了保存上述的寄存器外, 新增了**4个部分**. 这些增强的功能, 我们将在15.4.1节与15.4.8节里进行探讨. 

### 6.7.1. 检测PEBS记录的长度

综合前面所述, 最终确定PEBS记录的长度由下面两个因素决定. 

① 检测是否支持DTES64格式(即64位DS区域). 

② 检测64位PEBS记录的格式是否属于增强格式. 

在不支持DTES64格式的情况下, 它属于32位的PEBS记录格式, PEBS记录为40个字节宽. 否则, 如果不支持增强记录格式, PEBS记录为144个字节(64位PEBS记录). 

而在增强PEBS记录格式下, 每个PEBS记录变成了176个字节(增加了4个部分). 

在支持DTES64格式的情况下, 软件需要从IA32\_PERF\_CAPABILITIES寄存器的[11: 8]域来查询是否支持增强格式, 如下面的support\_enhancement\_pebs()检测函数所示. 

代码清单14-18(lib\debug.asm): 

```assembly
; ------------------------------------------------------------
;  support_enhancement_pebs(): 检测是否支持增强的 PEBS 记录
;  output: 
;  1-support, 0-no support
; -----------------------------------------------------------
support_enhancement_pebs: 
      mov ecx, IA32_PERF_CAPABILITIES
      rdmsr
      shr eax, 8
      and eax, 0Fh    ;  得到 IA32_PREF_CAPABILITIES[11: 8]
      cmp eax, 0001B    ;  测试是否支持增强的 PEBS 格式
      sete al
      movzx eax, al
      ret
```

当IA32\_PERF\_CAPABILITIES[11: 8]=0001B时, 处理器将支持增强的PEBS记录格式. 否则PEBS记录只保存RFLAGS寄存器、RIP寄存器, 以及通用寄存器. 

那么, 在DS管理区设置时, 必须检测PEBS记录长度, 做出正确的设置. 

# 7. 设置DS存储区域

对于**DS存储区域的设置**, **Intel**有它推荐和建议, 例如下面几条. 

① 对于**OS**来讲, **DS区域**应分配在**non\-paged(不可换页)的区域**, 系统**不应将它换出内存(！！！**). 并且系统应**保持DS区域属于dirty(脏)页(！！！**), 即已经被写的页. 

② DS区域**可以大于4K页**, 但**必须使用相临的页(即线性地址上必须是连续的！！！**). **物理地址并没有要求**(但是出于性能的考虑, 建议不使用跨页的物理地址). 

③ 出于性能的考虑, DS区域及管理区记录应该设置在**double word边界(！！！**)上. 

④ **BTS buffer**和**PEBS buffer大小**应该使用**记录字节的倍数(例如10个记录**), 并且应确保设置的PEBS记录宽度能够容纳下整条PEBS记录(例如前面所述的检测PEBS记录宽度). 

⑤ 在**MP系统**里, 对于**所有的处理器**, 系统应该将**DS区域**映射到**同一个物理地址区域(！！！**)上. 保持**切换CR3寄存器时**, **DS区域地址不变**. 

在设置DS存储区域后, 还必须**确保local APIC是开启(！！！**)的, 并且**对LVT performance monitor寄存器进行正确的设置(！！！**), **编写相应的PMI(performance monitor interrupt)中断处理程序(！！！**). 

下面是笔者对DS存储区域的设置代码. 

代码清单14-19(lib\debug.asm): 

```assembly
; ----------------------------------------------------------------
;  set_ds_management_record() 设置管理区记录基于 DS_SAVE_BASE
;  input: 
;   esi - BTS buffer base
;   edi - PEBS buffer base
;  description: 
;   默认情况下, 配置为环形回路 buffer 形式, 
;   threshold 值大于 maximum, 避免产生 DS buffer 溢出中断
; --------------------------------------------------------------------
set_ds_management_record: 
      push ebp
      mov ebp, esp
      push ecx
      push edx
      push ebx
; ;  测试是否支持 64位的 DS save 格式
      mov eax, 1
      cpuid
      bt ecx, 2         ;  DEST64 位
      jc set_ds_management_record64
      mov DWORD [ds64_flag], 0     ;  DS64 不支持, ds64_flags 标志清0
      mov DWORD [enhancement_pebs_flag], 0  ;  不支持, enhancement_pebs_flag
标志清 0
      ; ;  设置 32位的 BTS 格式
      mov DWORD [DS_SAVE_BASE + BTS_BASE], esi
      mov DWORD [DS_SAVE_BASE + BTS_INDEX], esi
      lea eax, [esi + BTS_RECORD_MAXIMUM * 12]
      mov DWORD [DS_SAVE_BASE + BTS_MAXIMUM], eax ;  最大记录数为
BTS_RECORD_MAXIMUM 值
      ;  设置为环形回路 BTS buffer
      lea eax, [esi + BTS_RECORD_CIRCULAR_THRESHOLD * 12]
      mov DWORD [DS_SAVE_BASE + BTS_THRESHOLD], eax
      ; ;  设置 32 位的 PEBS 格式
      mov DWORD [DS_SAVE_BASE + PEBS_BASE], edi   ;  pebs buffer base
      mov DWORD [DS_SAVE_BASE + PEBS_INDEX], edi  ;  pebs buffer index
      mov DWORD [pebs_buffer_index], edi               ;  保存 index 值
      lea eax, [edi + PEBS_RECORD_MAXIMUM * 40]   ;  base + m * 40
      mov DWORD [DS_SAVE_BASE + PEBS_MAXIMUM], eax  ;  pebs buffer maximum
      lea eax, [edi + PEBS_RECORD_THRESHOLD * 40]  ;  base + t * 40
      mov DWORD [DS_SAVE_BASE + PEBS_THRESHOLD], eax ;  pebs buffer threshold
      mov DWORD [DS_SAVE_BASE + PEBS_COUNTER0], 0
      mov DWORD [DS_SAVE_BASE + PEBS_COUNTER1], 0
      mov DWORD [DS_SAVE_BASE + PEBS_COUNTER2], 0
      mov DWORD [DS_SAVE_BASE + PEBS_COUNTER3], 0
      ; ;  下面存放 BTS 管理区的 pointer 值
      mov DWORD [bts_base_pointer], DS_SAVE_BASE + BTS_BASE
      mov DWORD [bts_index_pointer], DS_SAVE_BASE + BTS_INDEX
      mov DWORD [bts_maximum_pointer], DS_SAVE_BASE + BTS_MAXIMUM
      mov DWORD [bts_threshold_pointer], DS_SAVE_BASE + BTS_THRESHOLD
      ; ;  下面存放 PEBS 管理区 pointer
      mov DWORD [pebs_base_pointer], DS_SAVE_BASE + PEBS_BASE
      mov DWORD [pebs_index_pointer], DS_SAVE_BASE + PEBS_INDEX
      mov DWORD [pebs_maximum_pointer], DS_SAVE_BASE + PEBS_MAXIMUM
      mov DWORD [pebs_threshold_pointer], DS_SAVE_BASE + PEBS_THRESHOLD
      mov DWORD [pebs_counter0_pointer], DS_SAVE_BASE + PEBS_COUNTER0
      mov DWORD [pebs_counter1_pointer], DS_SAVE_BASE + PEBS_COUNTER1
      mov DWORD [pebs_counter2_pointer], DS_SAVE_BASE + PEBS_COUNTER2
      mov DWORD [pebs_counter3_pointer], DS_SAVE_BASE + PEBS_COUNTER3
      jmp set_ds_management_record_done
set_ds_management_record64: 
      mov DWORD [ds64_flag], 1     ;  DS64 支持, ds64_flags 标志置 1
      ; ;  设置 64 位 BTS 管理区
      mov DWORD [DS_SAVE_BASE + BTS64_BASE], esi
      mov DWORD [DS_SAVE_BASE + BTS64_BASE + 4], 0
      mov DWORD [DS_SAVE_BASE + BTS64_INDEX], esi
      mov DWORD [DS_SAVE_BASE + BTS64_INDEX + 4], 0
      lea eax, [esi + BTS_RECORD_MAXIMUM * 24]
      mov DWORD [DS_SAVE_BASE + BTS64_MAXIMUM], eax
      mov DWORD [DS_SAVE_BASE + BTS64_MAXIMUM + 4], 0
      ; ;  配置为环形回路 BTS buffer
      lea eax, [esi + BTS_RECORD_CIRCULAR_THRESHOLD * 24]
      mov DWORD [DS_SAVE_BASE + BTS64_THRESHOLD], eax
      mov DWORD [DS_SAVE_BASE + BTS64_THRESHOLD + 4], 0
      ; ;  下面存放 BTS 管理区的 pointer 值
      mov DWORD [bts_base_pointer], DS_SAVE_BASE + BTS64_BASE
      mov DWORD [bts_index_pointer], DS_SAVE_BASE + BTS64_INDEX
      mov DWORD [bts_maximum_pointer], DS_SAVE_BASE + BTS64_MAXIMUM
      mov DWORD [bts_threshold_pointer], DS_SAVE_BASE + BTS64_THRESHOLD
      ; ;  设置 64 位 PEBS 管理区
      mov ecx, IA32_PERF_CAPABILITIES
      rdmsr
      shr eax, 8
      and eax, 0Fh        ;  得到
      IA32_PREF_CAPABILITIES[11: 8]
      cmp eax, 0001B        ;  测试是否支持增强的 PEBS 格式
      je enhancement_pebs64
      mov DWORD [enhancement_pebs_flag], 0  ;  不支持, enhancement_pebs_flag标志清 0
      mov DWORD [pebs_record_length], 144
      lea eax, [edi + PEBS_RECORD_MAXIMUM * 144]   ;  maximum 值
      lea edx, [edi + PEBS_RECORD_THRESHOLD * 144]
      jmp set_pebs64
enhancement_pebs64: 
      ; *
      ; * 增强的 PEBS 格式, 每条记录共 176 个字节 *
      ; *
      mov DWORD [enhancement_pebs_flag], 1 ;  支持, enhancement_pebs_flag 标志置 1
      mov DWORD [pebs_record_length], 176
      lea eax, [edi + PEBS_RECORD_MAXIMUM * 176]  ;  maximum 值
      lea edx, [edi + PEBS_RECORD_THRESHOLD * 176]   ;  threshold 值
set_pebs64: 
      mov DWORD [DS_SAVE_BASE + PEBS64_BASE], edi   ;  pebs buffer base
      mov DWORD [DS_SAVE_BASE + PEBS64_BASE + 4], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_INDEX], edi   ;  pebs buffer index
      mov DWORD [DS_SAVE_BASE + PEBS64_INDEX + 4], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_MAXIMUM], eax  ;  pebs buffer maximum
      mov DWORD [DS_SAVE_BASE + PEBS64_MAXIMUM + 4], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_THRESHOLD], edx  ;  pebs buffer threshold
      mov DWORD [DS_SAVE_BASE + PEBS64_THRESHOLD + 4], 0
      ; *
      ; * 保存 pebs index 值
      ; * 作为判断 PEBS 中断条件
      ; *
      mov DWORD [pebs_buffer_index], edi
      mov DWORD [pebs_buffer_index + 4], 0
      ; ;  设置 counter reset
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER0], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER0 + 4], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER1], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER1 + 4], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER2], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER2 + 4], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER3], 0
      mov DWORD [DS_SAVE_BASE + PEBS64_COUNTER3 + 4], 0
      ; ;  下面存放 PEBS 管理区 pointer
      mov DWORD [pebs_base_pointer], DS_SAVE_BASE + PEBS64_BASE
      mov DWORD [pebs_index_pointer], DS_SAVE_BASE + PEBS64_INDEX
      mov DWORD [pebs_maximum_pointer], DS_SAVE_BASE + PEBS64_MAXIMUM
      mov DWORD [pebs_threshold_pointer], DS_SAVE_BASE + PEBS64_THRESHOLD
      mov DWORD [pebs_counter0_pointer], DS_SAVE_BASE + PEBS64_COUNTER0
      mov DWORD [pebs_counter1_pointer], DS_SAVE_BASE + PEBS64_COUNTER1
      mov DWORD [pebs_counter2_pointer], DS_SAVE_BASE + PEBS64_COUNTER2
      mov DWORD [pebs_counter3_pointer], DS_SAVE_BASE + PEBS64_COUNTER3
set_ds_management_record_done: 
      ;  清 PEBS buffer 溢出指示位 OvfBuffer
      RESET_PEBS_BUFFER_OVERFLOW
      pop ebx
      pop edx
      pop ecx
      mov esp, ebp
      pop ebp
      ret
```

这个set\_ds\_management\_record()函数用来设置DS管理区的BTS buffer与PEBS buffer, 实现在lib\debug.asm文件里, 稍有些长, 但结构是清晰的. 它的工作是先判断是否支持DTES64格式, 根据检测的结果来选择设置32位与64位DS区域. 

在设置PEBS buffer时, 先检测是否支持扩展的格式(通过前面所述的IA32\_PERF\_CAPABILITIES寄存器来检测), 根据测试的结果来设置PEBS maximum与threshold值. 

函数需要提供两个输入参数: esi传递BTS buffer base值, edi传递PEBS buffer base值. 

代码清单14-20(lib\debug.asm): 

```assembly
; -------------------------------------------
;  set_debug_store_area(): 设置 DS 区域基地址
; -------------------------------------------
set_debug_store_area: 
      mov esi, DS_SAVE_BASE
      call clear_4K_page   ;  先清空 debug store area
;  设置 IA32_DS_AERA 寄存器
      mov ecx, IA32_DS_AREA
      mov eax, DS_SAVE_BASE  ;  DS 区域基地址
      mov edx, 0
      wrmsr
      ret
```

这个set\_debug\_store\_area()函数将设置DS存储区域的基地址, 通过**写IA32\_DS\_AREA寄存器**, 基地址固定为DS\_SAVE\_BASE值, 这是个常量值, 定义在inc\debug.inc文件里. 这个文件也定义了BTS\_BUFFER\_BASE与PEBS\_BUFFER\_BASE常量值, 对应于BTS的base与PEBS的base值. 也定义了BTS\_RECORD\_MAXIMUM与BTS\_RECORD\_CIRCULAR\_THRESHOLD值, 对应于环形BTS buffer的最大记录数与threshold值. 定义了PEBS\_RECORD\_MAXIMUM与PEBS\_RECORD_THRESHOLD值, 对应于PEBS的最大记录数与threshold值. 

函数开头使用clear\_4K\_page()函数来清空DS区域, 这个函数实现在lib\page32.asm文件里. 在inc\debug.inc文件里定义了一个宏, 来设置完整的DS存储区域. 

代码清单14-21(inc\debug.inc): 

```assembly
; ---------------------------------------------------
;  宏 SET_DS_AREA()
;  描述: 
;  用来设置完整的 DS 区域(环形回路 buffer 类型)
; ----------------------------------------------------
%macro SET_DS_AREA 0
      ; ; ;  设置 IA32_DS_AERA 寄存器
      call set_debug_store_area
      ; ; ;  设置 DS 管理区域
      SET_DS_MANAGEMENT
%endmacro
```

这个SET\_DS\_AREA宏只是依次调用set\_debug\_store\_area()和set\_ds\_management\_record()函数来设置环形的BTS buffer. 

当BTS buffer配置为满产生DS中断时, 需要做一些修改, 代码如下所示. 

代码清单14-22(inc\debug.inc): 

```assembly
; ------------------------------------------------
;  宏 SET_INT_DS_AREA()
;  描述: 
;  用来设置当 buffer 满时产生 DS buffer 中断
; ------------------------------------------------
%macro SET_INT_DS_AREA 0
      SET_DS_AREA        ;  先设置为环形回路 buffer 类型
      ;  接下来设置 threshold 值等于 maximum 值
      ;  来达到 buffer 满时产生 DS 中断
      mov esi, [bts_maximum_pointer]  ;  读 BTS maximum 地址
      mov esi, [esi]       ;  读 BTS maximum 值
      mov edi, [bts_threshold_pointer]  ;  读 BTS threshold 地址
      mov [edi], esi       ;  设 BTS threshold 等于 BTS maximum 值
%endmacro
```

这个宏SET\_INT\_DS\_AREA调用前面的宏SET\_DS\_AREA来配置一个环形的BTS buffer, 接着将BTS thershold值设置为BTS maximum值, 来达到配置BTS buffer满时产生DS中断. 

# 8. 使用环形回路BTS buffer

使用下面的IA32_DEBUGCTL寄存器设置, 将开启circular(状形)回路BTS buffer. 

![config](./images/45.jpg)

当IA32\_DEBUGCTL.TR=1, IA32\_DEBUGCTL.BTS=1, 而BTINT值为0时, branch记录将写在内存的BTS buffer区域, 这个BTS buffer是循环使用. 当BTSbuffer的index到达maximum时, index将被重置为base值, 继续从头开始记录. 

这个工作原理和LBR stack是一样的, 值得注意的是, index是指向下一条记录将要写的地址. 在初始设置里, base是第1条记录的位置, 而index一般设为与base值一样. 

## 8.1. BTS threshold值的设置

如前面所述, 对于**circular(环形)的BTS buffer**来说, **BTS threshold值必须大于BTS maximum值**. 否则(小于或等于BTS maximum), 当index遇到threshold值时会触发DS中断, 在LVT performance monitor未屏蔽时会进入PMI handler. 

并且在进入PMI handler, 可能由于新的分支引起BTS buffer继续写满后, 会重新从base位置开始进行新的记录. 

显然这是个错误的行为. 假设, BTS buffer最多能容纳10条记录, 对环形BTS buffer的64位格式下, 下面是对BTS maximum与BTS threshold的设置. 

```assembly
mov DWORD [DS_AREA_BASE + BTS_MAXIMUM], 10 * 24 ;  maximum 值为 10个BTS记录
mov DWORD [DS_AREA_BASE + BTS_THRESHOLD], 11 * 24;  threshold 值为 11 个BTS记录
```

BTS threshold值应设置为大于BTS maximum值的BTS记录整数倍位置上, 上面的代码设在记录11的位置(当然还可以设为更后的位置上). 

在正确设置BTS buffer的情况下, 环形回路BTS buffer的使用不会因为BTS buffer溢出产生DS中断而调用PMI中断handler. 但是在一个完整的OS环境里, 必须把LVT performance monitor寄存器设置好, 并组织好PMI handler及IDT. 

>实验14\-9: 测试环形回路BTS buffer的工作

按照惯例, 我们将对BTS机制进行一些实验测试. 在这里我们测试使用和观察环形回路的BTS buffer. 下面是测试的主体代码. 

代码清单14-23(topic14\ex14-9\protected.asm): 

```assembly
      call available_bts     ;  测试 bts 机制是否可用
      test eax, eax
      jz next        ;  不可用
;  设置 IA32_DS_AERA 寄存器
      call set_debug_store_area
;  设置 DS 管理区记录
      mov esi, BTS_BUFFER_BASE   ;  BTS buffer 基址
      mov edi, PEBS_BUFFER_BASE   ;  PEBS buffer 基址
      call set_ds_management_record
;  开启 BTS
      ENABLE_BTS       ;  TR=1, BTS=1
; ;  下面测试 11 条 branch
jmp l1
l1: jmp l2
l2: jmp l3
l3: jmp l4
l4: jmp l5
l5: jmp l6
l6: jmp l7
l7: jmp l8
l8: jmp l9
l9: jmp l10
l10: jmp l11
l11: 
;  关闭 BTS
      DISABLE_BTS       ;  TR=0, BTS=0
      DUMP_BTS       ;  打印 BTS buffer 信息
next: 
      jmp $
```

实验代码里, 先检则BTS机制是否可用, 在可用的情况下继续下面的设置. 代码先设置DS存储区域的基地址, 再调用前面代码清单14-20中的set\_ds\_management\_record()函数设置DS管理区的记录(BTS与PEBS buffer的相关设置). 

接着开启BTS机制, ENABLE\_BTS是宏, 实现在inc\debug.inc文件里, 对IA32\_DEBUGCTL寄存器进行设置(TR=1并且BTS=1). 

代码清单14-24(inc\debug.inc): 

```assembly
; -----------------------------------
;  ENABLE_BTS() 宏: 开启 bts, 环状回路
; -----------------------------------
%macro ENABLE_BTS 0
      mov ecx, IA32_DEBUGCTL
      mov edx, 0
      mov eax, 0C0h     ;  TR=1, BTS=1
      wrmsr
%endmacro
```

在开启BTS后, 后续代码连续使用11条jmp指令来产生分支记录. 采用这种方式比较直观, 容易观察BTS记录. 最后使用宏DISABLE\_BTS关闭BTS机制, 并使用DUMP\_BTS宏来打印BTS buffer的信息, 这些宏都实现在inc\debug.inc文件里. 

下面是在Westmere架构Core i5处理器笔记本式计算机上的运行结果. 

![config](./images/46.jpg)

在这个测试里, 笔者特意产生了11条分支记录, 在结果里我们看到: BTS buffer已经被写满, index指向记录1(下一条记录将要写的地方), 下表是这11条分支记录的描述. 

![config](./images/47.jpg)

在BTS maximum的位置上不是有效的buffer区域, 记录不能写在这个位置上. 最后一条记录由于index回绕后写在base位置(记录0)上, 接着index指向记录1的位置. 

处理器动态地维护BTS index值, 在BTS管理区里BTS index的值为00400118h(记录1地址), 记录0已经被重写(被最后一条记录覆盖了). 当然, 这个BTS buffer我们可以设得更大, 但在笔者的测试实验里, BTS和PEBS buffer最多只能容纳10条记录. 

## 8.2. 值得注意

在实验代码里, 笔者使用了宏DISABLE_BTS来关闭BTS机制, 而不使用函数的调用. 这是基于在未关闭BTS机制下, 函数调用又会产生更多的分支记录. 

代码清单14-25(inc\debug.inc): 

```assembly
; ------------------------------------------------------------
;  宏 DUMP_BTS() 用来打印 DS 管理区与 BTS buffer 记录
;  使用这个宏先关闭 BTS 避免记录函数分支
; ------------------------------------------------------------
%macro DUMP_BTS 0
      mov ecx, IA32_DEBUGCTL
      rdmsr
      mov esi, 0FF3Fh    ;  BTS=0, TR=0
      mov edi, eax
      push eax
      bt eax, 7      ;  测试 BTS 位, BTS 机制是否开启
      cmovc edi, esi     ;  如果开启就关闭它
      and eax, edi
      wrmsr
      call dump_ds_management  ;  打印 DS 管理区记录
      call dump_bts_record   ;  打印 BTS buffer 记录信息
      ;  恢复原设置
      pop eax
      mov edx, 0
      mov ecx, IA32_DEBUGCTL
      wrmsr       ;  写回原设置
%endmacro
```

宏DUMP\_BTS的编写原理是, 如果BTS是开启的, 就先关闭BTS再打印, 打印完毕后再恢复BTS的开启状态. 打印功能最终是调用dump\_ds\_management()和dump\_bts\_record()函数来实现. 这个宏的好处是在打印BTS buffer信息时, 不会产生额外的分支记录. 

# 9. 使BTS buffer产生DS中断

在开启BTS机制的同时, 设置IA32_DEBUGCTL.BTINT=1时, 将使用非环状回路的BTS buffer, 如下表的设置. 

![config](./images/48.jpg)

**BTS threshold值的设置**

为了达到BTS buffer写满时产生DS中断, 如前面所述: 此时**BTS threshold值**应该设置为**等于BTS maximum值**, 如下是一个正确的设置示例. 

![config](./images/49.jpg)

对于BTS buffer满时产生DS中断这个需求来说, 无论是threshold值小于maximum值(未满就产生中断), 或者是threshold值大于maximum值都是不正确的. 

![config](./images/50.jpg)

在笔者的测试里, 如上所示: 配置为**非环形BTS buffer时**, 当设置**threshold值大于maximum**时, 在**写满BTS buffer**, **还有分支记录时**, 将引发数次的**DS中断请求(连续调用PMI handler**). 

在**非环形BTS buffer(BTINT=1**)里, 当BTS **threshold值大于maximum值二个BTS记录以上**时, 写满Buffer后, DS中断将不会触发. 

这是在笔者的测试里的另一类情况, threshold大于maximum并且相隔不止一个记录时, index将无法达到threshold值, DS中断也不可能会发生. 

**DS中断与PMI中断**

产生DS(Debug Store)中断的根本原因是index达到了threshold值(无论是环形还是非环形BTS buffer). BTS buffer写满时回绕或者是产生中断, 这是软件的需求问题. 系统根据需求而设置合理的threshold值. BTS index达到BTS threshold或者PEBS index达到PEBS threshold值都会产生DS中断. 

而DS中断handler的vector就是LVT performance monitor寄存器里设置的vector值. 因此, DS中断handler与PMI handler使用同一个中断服务程序. 

可是, 它们的触发原因不同. 

① PMI(performance monitor interrupt)的触发, 是由于在监控事件时counter(计数器)发生了溢出. 

② DS(Debug Store)中断(或者称BTS/PEBS buffer溢出中断)的触发, 是由于BTS或PEBS的index达到了各自的threshold值. 

实际上, PEBS和PMI都使用perfmon中断handler进行处理(我们将在第15章里对PEBS机制进行详细的探讨). perfmon中断handler需要接管这些中断处理. 

## 9.1. 判断中断触发的原因

由前面所述, DS中断和PMI都使用同一个中断服务程序, 因此在DS和PMI handler里必须判断由哪种原因产生. 在OS完善的perfmon handler里还需要判断PEBS中断触发的原因, 如下表所示. 

![config](./images/51.jpg)

由上表可以看到, 引发调用LVT performance monitor寄存器设置的中断handler, 总共有4个触发原因. 其中BTS buffer满和PEBS buffer满可以归纳为DS(debug store)中断. PEBS中断在PMI的基础上配置(IA32\_PEBS\_ENABLE寄存器设置PEBS中断). 

### 9.1.1. 确定PMI触发

在PMI handler里, 可以通过IA32\_PERF\_GLOBAL_STATUS寄存器来判断是否由于counter溢出而产生中断. 

![config](./images/52.jpg)

在上面的IA32\_PERF\_GLOBAL\_STATUS寄存器里, bit 0到bit 3置位时指示相应的IA32\_PMC计数器发生了溢出. bit 32到bit 35置位时指示相应的IA32\_FIXED\_CTR计数器发生了溢出. 如下面的test\_counter\_overflow()函数所示, 实现在lib\perfmon.asm文件里. 

代码清单14-26(lib\perfmon.asm): 

```assembly
; ---------------------------------------------------
;  test_counter_overflow(): 测试是否 counter 发生溢出
;  output: 
;   1-yes, 0-no
; ---------------------------------------------------
test_counter_overflow: 
      mov ecx, IA32_PERF_GLOBAL_STATUS
      rdmsr
      test edx, 7    ;  测试 IA32_FIXED_CTRx 寄存器
      setnz dl
      jnz test_counter_overflow_done
      test eax, 0Fh   ;  测试 IA32_PMCx 寄存器
      setnz dl
test_counter_overflow_done: 
      movzx eax, dl
      ret
```

在Nehalem与Westmere架构里支持4个IA32\_PMC寄存器, 在Sandy Bridge架构里将支持更多的IA32\_PMC寄存器. 

那么, perfmon中断handler可以通过读取IA32\_PERF\_GLOBAL\_STATUS寄存器溢出标志位来判断是由于counter溢出而产生中断. 而在perfmon中断handler里需要对溢出标志位进行清位工作. 

### 9.1.2. 确定BTS buffer满的DS中断触发

那么, 如何确定产生了DS中断呢？DS中断由于BTS Buffer满或者PEBS buffer满而产生, 因此对BTS buffer可以通过index值判断. 

当BTS index等于或大于thresould值时触发BTS buffer满时中断, 因此我们可以使用下面的test\_bts\_buffer\_overflow()函数进行判断. 

代码清单14-27(lib\debug.asm): 

```assembly
; --------------------------------------------------------------
;  test_bts_buffer_overflow(): 测试是否发生 BTS buffer 溢出中断
; --------------------------------------------------------------
test_bts_buffer_overflow: 
      mov eax, [bts_index_pointer]
      mov eax, [eax]                          ;  读 BTS index 值
      mov esi, [bts_threshold_pointer]
      cmp eax, [esi]                          ;  比较 index >= threshold ？
      setae al
      movzx eax, al
      ret
```

在正确设置buffer的前提下, 使用环状回路buffer时(BTINT=0), index指向maximum时会回绕到base(第1条记录)重新开始写记录而不会产生DS中断. 而在BTS buffer满而产生中断时, perfmon中断handler里需要对index值重新设置为BTS base值, 避免重复产生DS中断. 后续的分支记录可以继续写入. 

### 9.1.3. 确定PEBS buffer满时DS中断触发

对于PEBS buffer满而引发的DS中断触发, 中断handler可以通过一个简便的方式, 而不需要通过index值. 

在上面的IA32\_PERF\_GLOBAL\_STATUS寄存器中, bit 62位是OvfBuffer位, 当置位时指示发生了PEBS buffer溢出. 因此, 可以通过OvfBuffer标志位来判断, 代码如下所示. 

代码清单14-28(lib\perfmon.asm): 

```assembly
; -------------------------------------------------------
;  test_pebs_buffer_overflow(): 测试 PEBS buffer 是否溢出
;  output: 
;  1-yes, 0-no
; -------------------------------------------------------
test_pebs_buffer_overflow: 
      mov ecx, IA32_PERF_GLOBAL_STATUS
      rdmsr
      bt edx, 30       ;  测试 OvfBuffer 位
      setc al
      movzx eax, al
      ret
```

同样, 当判断为这个原因引起的DS中断, perfmon中断handler需要对OvfBuffer标志位进行清位工作, 并且需要对PEBS index重新设置为PEBS base值, 避免重复产生DS中断. 

### 9.1.4. 确定PEBS中断触发

在排除上面的三种触发原因后, 就可以认为最后产生的是PEBS中断. 基本上没有特别的方法去判断PEBS中断. 因为counter(计数器)配置为溢出产生PEBS中断时, PEBS中断发生后并不会在IA32\_PERF\_GLOBAL\_STATUS寄存器里记录溢出的发生. 

而PMI中断会在IA32\_PERF\_GLOBAL\_STATUS寄存器里记录发生溢出. 软件可以通过PEBS index值来做判断, 代码逻辑如下. 

```c
if (new_pebs_index > old_pebs_index)
{
      /* 产生 PEBS 中断 */
}
```

软件需要记录旧的PEBS index值是多少, 然后在中断handler判断新的PEBS index是否大于旧的PEBS index, 如果大于则说明产生了PEBS中断. 因为PEBS记录写在PEBS buffer时, PEBS index值会增加. (我们将在第15章里实现测试PEBS中断触发函数. )

## 9.2. 编写DS中断handler

DS中断handler(即perfmon中断handler)的编写应该遵循下面几个原则. 

① 先关闭相应的功能, 例如: BTS机制, PEBS机制, performance counter. 

② 判断中断引发的原因, 做相应的处理. 

③ 退出前恢复原来的设置. 

④ 清LVT performance montior寄存器的mask位. 

⑤ 发送EOI命令. 

perfmon中断handler需使用Fixed delivery模式, Intel特别说明perfmon中断handler的vector在IDT里对应的描述符需要使用Interrupt-gate(中断门)描述符. 

代码清单14-29(topic14\ex14-10\protected.asm): 

```assembly
; -------------------------------
;  perfmon handler
; ------------------------------
apic_perfmon_handler: 
      jmp do_apic_perfmon_handler
ph_msg1 db '>>> now: enter PMI handler, occur at 0x', 0
ph_msg2 db 'exit the PMI handler <<<', 10, 0
ph_msg3 db '****** DS interrupt occur with BTS buffer full！ *******', 10, 0
ph_msg4 db '****** PMI interrupt occur *******', 10, 0
ph_msg5 db '****** DS interrupt occur with PEBS buffer full！ *******', 10, 0
ph_msg6 db '****** PEBS interrupt occur *******', 10, 0
do_apic_perfmon_handler: 
      ; ;  保存处理器上下文
      STORE_CONTEXT
; *
; * 下面在 handler 里关闭功能
; *
      ; ;  关闭 TR
      mov ecx, IA32_DEBUGCTL
      rdmsr
      mov [debugctl_value], eax        ;  保存原 IA32_DEBUGCTL 寄存器值, 以便恢复
      mov [debugctl_value + 4], edx
      mov eax, 0
      mov edx, 0
      wrmsr
      ; ;  关闭 pebs enable
      mov ecx, IA32_PEBS_ENABLE
      rdmsr
      mov [pebs_enable_value], eax
      mov [pebs_enable_value + 4], edx
      mov eax, 0
      mov edx, 0
      wrmsr
      ;  关闭 performance counter
      mov ecx, IA32_PERF_GLOBAL_CTRL
      rdmsr
      mov [perf_global_ctrl_value], eax
      mov [perf_global_ctrl_value + 4], edx
      mov eax, 0
      mov edx, 0
      wrmsr
      mov esi, ph_msg1
      call puts
      mov esi, [esp]
      call print_dword_value
      call println
; *
; * 接下来判断 PMI 引发原因
; *
check_pebs_interrupt: 
      ;  是否 PEBS 中断
      call test_pebs_interrupt
      test eax, eax
      jz check_counter_overflow
      ;  打印信息
      mov esi, ph_msg6
      call puts
      call dump_ds_management
      call update_pebs_index_track   ;  更新 PEBS index 的轨迹, 保持对 PEBS 中断的检测
check_counter_overflow: 
      ;  检测是否发生 PMI
      call test_counter_overflow
      test eax, eax
      jz check_pebs_buffer_overflow
      ;  打印信息
      mov esi, ph_msg4
      call puts
      call dump_perf_global_status
      RESET_COUNTER_OVERFLOW                  ;  清溢出标志
check_pebs_buffer_overflow: 
      ;  检测是否发生 PEBS buffer 溢出中断
      call test_pebs_buffer_overflow
      test eax, eax
      jz check_bts_buffer_overflow
      ;  打印信息
      mov esi, ph_msg5
      call puts
      call dump_perf_global_status
      RESET_PEBS_BUFFER_OVERFLOW             ;  清 OvfBuffer 溢出标志
      call reset_pebs_index                   ;  重置 PEBS 值
check_bts_buffer_overflow: 
      ;  检则是否发生 BTS buffer 溢出中断
      call test_bts_buffer_overflow
      test eax, eax
      jz apic_perfmon_handler_done
      ;  打印信息
      mov esi, ph_msg3
      call puts
      call dump_ds_mangement
      call dump_bts_record
      call reset_bts_index                    ;  重置 BTS index 值
apic_perfmon_handler_done: 
      mov esi, ph_msg2
      call puts
; *
; * 下面恢复功能原设置！
; *
      ;  恢复原 IA32_PERF_GLOBAL_CTRL 寄存器值
      mov ecx, IA32_PERF_GLOBAL_CTRL
      mov eax, [perf_global_ctrl_value]
      mov edx, [perf_global_ctrl_value + 4]
      wrmsr
      ;  恢复原 IA32_DEBUGCTL 设置
      mov ecx, IA32_DEBUGCTL
      mov eax, [debugctl_value]
      mov edx, [debugctl_value + 4]
      wrmsr
      ; ;  恢复 IA32_PEBS_ENABLE 寄存器
      mov ecx, IA32_PEBS_ENABLE
      mov eax, [pebs_enable_value]
      mov edx, [pebs_enable_value + 4]
      wrmsr
      RESTORE_CONTEXT                                 ;  恢复 context
      btr DWORD [APIC_BASE + LVT_PERFMON], 16    ;  清 LVT_PERFMON 寄存器 mask 位
      mov DWORD [APIC_BASE + EOI], 0               ;  写 EOI 命令
      iret
```

上面的代码清单14-30是笔者为下面的实验14-10所编写的perfmon中断handler, 这个中断handler所做的工作遵循了前面所讲的原则(我们将在15.4.6节以及15.4.7节里进行详细的探讨). 

开头的STORE\_CONTEXT与结尾的RESOTRE_CONTEXT宏用来保存和恢复处理器的上下文环境信息(8个通用寄存器的值). 它们实现在inc\lib.inc文件里. 

### 9.2.1. 关闭功能

在perfmon handler开头, 关闭了BTS机制、PEBS机制, 以及counter. 在关闭功能之前, 应先保存原有的设置, 以便于中断返回前进行恢复工作. 

关闭BTS机制, 实际上只需要清IA32\_DEBUGCTL寄存器的TR标志位就可以了, 这里统一将IA32\_DEBUG寄存器清0. IA32\_PEBS\_ENABLE寄存器清为0将关闭所有的IA32\_PMC计数器的PEBS功能. 

而关闭性能监控中的counter, 需要清IA32\_PERF\_GLOBAL\_CTRL寄存器的enable位(在这里将关闭所有的counter). 

注意: 在下面的中断触发条件判断中每个条件使用了单独的if()逻辑判断, 避免使用if-else if()逻辑进行判断. 我们将在PEBS机制里对多个中断同时触发时进行详细的探讨. 

### 9.2.2. PEBS buffer满时

代码接着判断是否由PEBS buffer满而产生DS中断, 如下. 

```assembly
check_pebs_buffer_overflow: 
      ;  检测是否发生 PEBS buffer 溢出中断
      call test_pebs_buffer_overflow
      test eax, eax
      jz check_bts_buffer_overflow
      ;  打印信息
      mov esi, ph_msg5
      call puts
      call dump_perf_global_status
      RESET_PEBS_BUFFER_OVERFLOW             ;  清 OvfBuffer 溢出标志
      call reset_pebs_index                   ;  重置 PEBS 值
```

通过调用前面所述的test\_pebs\_buffer\_overflow()函数来判断. 如果是产生了PEBS buffer满时中断, 则通过宏RESET\_PEBS\_BUFFER\_OVERFLOW来清OvfBuffer溢出标志. 

这个宏实现在inc\perfmon.inc头文件里, 它是通过向IA32\_PERF\_GLOBAL\_OVF\_CTRL寄存器的bit 62位写入1值来清OvfBuffer标志位. 关于PEBS与性能监控方面的知识, 请参考第15章. 

代码清单14-30(lib\debug.asm): 

```assembly
; ----------------------------------------------
;  reset_pebs_index(): 重置 PEBS index 值为 base
; ----------------------------------------------
reset_pebs_index: 
      mov edi, [pebs_index_pointer]
      mov esi, [pebs_base_pointer]
      mov esi, [esi]                                  ;  读取 PEBS base 值
      mov [edi], esi                                  ;  PEBS index=PEBS base
      mov [pebs_buffer_index], esi                 ;  更新保存的 PEBS index 值
      ret
```

除了清OvfBuffer标志位, 还必须对PEBS index进行重置. 上面的reset\_pebs\_index()函数实现将PEBS index重新置为PEBS base值, 以便于PEBS记录从头开始继续写. 

### 9.2.3. Counter溢出时

如果counter溢出, 则表示产生了PMI, 如下. 

```assembly
check_counter_overflow: 
      ;  检测是否发生 PMI
      call test_counter_overflow
      test eax, eax
      jz check_pebs_buffer_overflow
      ;  打印信息
      mov esi, ph_msg4
      call puts
      call dump_perf_global_status
      RESET_COUNTER_OVERFLOW                  ;  清溢出标志
```

通过调用前面介绍的test\_counter\_overflow()函数来判断counter是否溢出. 如果是, 打印全局状态寄存器的值, 接着使用宏RESET\_COUNTER\_OVERFLOW来清counter的溢出标志位. 也是通过写IA32\_PERF\_GLOBAL\_OVF\_CTRL寄存器的相应位来清位. 

### 9.2.4. BTS buffer满时

对BTS buffer满的判断, 通过前面所说的test\_bts\_buffer\_overflow()函数进行. 

```assembly
check_bts_buffer_overflow: 
      ;  检则是否发生 BTS buffer 溢出中断
      call test_bts_buffer_overflow
      test eax, eax
      jz apic_perfmon_handler_done
      ;  打印信息
      mov esi, ph_msg3
      call puts
      call dump_ds_management
      call dump_bts_record
      call reset_bts_index                    ;  重置 BTS index 值
```

当属于BTS buffer满时产生中断, handler必须要将index值重新设置, 如下面代码所示. 

代码清单14-31(lib\debug.asm): 

```assembly
; ----------------------------------------------
;  reset_bts_index(): 重置 BTS index 为 base 值
; ----------------------------------------------
reset_bts_index: 
      mov edi, [bts_index_pointer]
      mov esi, [bts_base_pointer]
      mov esi, [esi]                           ;  读取 BTS base 值
      mov [edi], esi                           ;  BTS index=BTS base
      ret
```

reset\_bts\_index()函数将index重设为base值, 让BTS记录从头开始继续写. 

### 9.2.5. PEBS中断

在这个中断handler里, 使用test\_pebs\_interrupt()函数来判断PEBS中断的发生. 

```assembly
check_pebs_interrupt: 
      ;  是否 PEBS 中断
      call test_pebs_interrupt
      test eax, eax
      jz check_counter_overflow
      ;  打印信息
      mov esi, ph_msg6
      call puts
      call dump_ds_management
      call update_pebs_index_track   ;  更新 PEBS index 的轨迹, 保持对PEBS中断的检测
```

test\_pebs\_interrupt()函数(实现在lib\perfmon.asm)的原理是: 设置一个值记录原PEBS index值, 当检测到新的BTS index大于原PEBS index值, 则表明产生了PEBS中断. 

当发生PEBS中断时, perfmon handler里可以不必进行相应的处理. 处理器会在PEBS buffer写入相应的PEBS记录. 在这里需要做的是使用updata_pebs_index_track()函数来更新原PEBS index值, 保持对PEBS中断的监控. 这个函数实现在lib\perfmon.asm文件里. 

### 9.2.6. 恢复原有的功能设置

由于在关闭前, 我们已经保存了原有的设置, 因此在恢复时逻辑就比较简单了: 通过读取原有的值写回相应的寄存器即可. 

### 9.2.7. 清LVT performance monitor寄存器mask位

由于进入PMI handler时, 处理器会对LVT performance monitor寄存器进行自动masked处理, 并且不会自动恢复non-masked状态, 因此在中断返回前需要清mask位, 使PMI handler能够响应下次的调用. 

```assembly
btr DWORD [APIC_BASE + LVT_PERFMON], 16  ;  清 LVT_PERFMON 寄存器 mask 位
mov DWORD [APIC_BASE + EOI], 0    ;  写 EOI 命令
```

除了清mask位, 最后一项工作是向local APIC发送EOI命令, 这是Fixed delivery(交付)模式local中断源所必须做的一项工作. 

关于local APIC的知识, 请参考第18章的相关探讨. 

>实验14-10: 测试BTS buffer满时的DS中断

经过前面的探讨, 现在我们需要测试DS中断, 这将会使用到前面提到过的函数代码, 实验的目录是topic14\ex14-10, 主体代码在protected.asm下. 

代码清单14-32(topic14\ex14-10\protected.asm): 

```assembly
;  ① 开启APIC
      call enable_xapic
;  ② 设置 APIC performance monitor counter handler
      mov esi, APIC_PERFMON_VECTOR
      mov edi, apic_perfmon_handler
      call set_interrupt_handler
;  设置 LVT performance monitor counter
      mov DWORD [APIC_BASE + LVT_PERFMON], FIXED_DELIVERY | APIC_PERFMON_VECTOR
      call available_bts      ;  测试 bts 是否可用
      test eax, eax
      jz next         ;  不可用
;  设置 IA32_PERF_GLOBAL_CTRL
      mov ecx, IA32_PERF_GLOBAL_CTRL
      rdmsr
      bts eax, 0        ;  PMC0 enable
      wrmsr
;  设置 counter 计数值
      mov eax, 0xffffffff - 7
      mov edx, 0        ; 写入最大值-7
      mov ecx, IA32_PMC0
      wrmsr
;  设置完整的 DS 区域
      SET_INT_DS_AREA
;  开启 BTS 并使用 BTINT
      ENABLE_BTS_BTINT      ;  TR=1, BTS=1, BTINT=1
;  设置 IA32_PERFEVTSEL0 寄存器, 开启计数
      mov ecx, IA32_PERFEVTSEL0
      mov eax, 5300c0H ;  EN=1, INT=1, USR=OS=1, umask=0, event select=c0
      mov edx, 0
      wrmsr
      jmp l1
l1: jmp l2
l2: jmp l3
l3: jmp l4
l4: jmp l5
l5: jmp l6
l6: jmp l7
l7: jmp l8
l8: jmp l9
l9: jmp l10
l10: jmp l11
l11: 
;  关闭计数器
      mov ecx, IA32_PERFEVTSEL0
      rdmsr
      btr eax, 22  ;  EN=0
      wrmsr
;  关闭 BTS
      DISABLE_BTS_BTINT ;  TR=0, BTS=0, BTINT=0
next: 
      jmp $
```

在这个测试实验里开启了两个功能: BTS机制与性能监控. 

① 使用ENABLE\_BTS\_BTINT宏开启BTS记录功能, BTS buffer满时产生DS中断. 

② 使用IA32\_PMC0计数器对执行指令数进行监控, IA32\_PMC0的值已经置为

```assembly
;  设置 counter 计数值
      mov eax, 0xffffffff - 7
      mov edx, 0        ; 写入最大值-7
      mov ecx, IA32_PMC0
      wrmsr
```

由于PMC0计数器的值为0FFFFFFFFh–7, 那么IA32\_PMC0计数器中差7条指令就会产生counter溢出. 

接着下面设置监控事件, 开启计数器. 这个监控事件是对执行的指令数进行统计. 

```assembly
;  设置 IA32_PERFEVTSEL0 寄存器, 开启计数
      mov ecx, IA32_PERFEVTSEL0
      mov eax, 5300c0H ;  EN=1, INT=1, USR=OS=1, umask=0, event select=c0
      mov edx, 0
      wrmsr
```

实验里, 同样是使用jmp指令产生了11条分支记录. 这11条分支记录如下表所示. 

![config](./images/53.jpg)

由于这些分支指令的执行, 在这个测试实验里, 将会产生两次中断. 

① 第1次中断由于IA32_PMC0溢出而产生PMI. 

② 第2次中断由于BTS buffer满时产生DS中断. 

下图是在笔者的Westmere架构Core i5处理器笔记本式计算机上的测试结果. 

![config](./images/54.jpg)

在结果里, 我们看到: 第1次产生PMI, 发生在0x00009141位置上. 由于IA32_PMC0计数器溢出而引发. 第2次产生DS中断, 也发生在0x00009141位置上, 由于BTS buffer满时引发. 

为什么两次中断在同一个位置上引发, 下面我们来看看两个中断产生的示意图. 

![config](./images/55.jpg)

我们先看看PMI是怎样产生的: 在执行到第8条jmp指令时, 会使得IA32_PMC0计数器溢出(由最大值转变为0值). 

当设置PMC0计数器时(值为0FFFFFFFFh-7), IA32\_PMC0的初始值为0000FFFF\_FFFFFFF8h(32位值符号扩展为48位的值), 再加上8条指令后

```assembly
IA32_PMC0=0000FFFF_FFFFFFF8h + 8=0    ;  IA32_PMC0值变为0
```

当IA32\_PMC0的值由最大值转变为0值时, 产生了溢出, 于是产生了PMI, 转而执行PMI handler. 

我们再来看看DS中断为什么会在同一个位置上引发: 这是由于发生PMI时, BTS buffer仍在继续记录分支情况. 由于执行到第8条jmp指令产生了PMI, BTS记录的第8条记录将从0x00009141位置转到PMI handler的入口0x0000979c地址上, 如上面的示意图所示. 

那么第9条BTS记录是一条jmp指令, 第10条BTS记录则是从PMI handler返回到引发PMI的地址. 当PMI返回时, 由于处理器检测到BTS buffer已满(index达到了threshold值)从而再次产生中断, 进入PMI handler里. 

在PMI handler里判断中断引发的原因是非常重要的. 

由于软件在开启BTS、performon monitor, 以及PEBS功能后, 可能产生多个中断, 或者同时产生多个中断. 在这个测试实验里, 可以看到判断中断引发的原因是多么重要. 

在同时由不同的原因引发多个PMI的产生, 这就产生了PMI中断优先级的问题, 我们将在第15章里探讨PEBS机制后再进行阐述. 

# 10. 过滤BTS记录

在IA32\_DEBUGCTL寄存器里, 为BTS机制提供了CPL-qualified branch record(受CPL限制的分支记录)功能, 允许软件设置哪类分支可以被记录, 由BTS\_OFF\_OS与BTS\_OFF\_USR标志位实现(标志位置位时, 关闭记录). 如下表所示. 

![config](./images/56.jpg)

BTS\_OFF\_OS与BTS\_OFF\_USR同时置位, 这是一个极端的应用, BTS buffer将不会记录任何的BTM(branch trace message)记录. 

## 10.1. BTS_OFF_OS

当分支的目标地址属于kernel层(CPL=0)时, 关闭BTS记录. 典型地, 当用户层里调用系统服务例程时, 目标地址位于CPL=0运行权限. 启用BTS_OFF_OS功能时, 将忽略这条分支记录. 

## 10.2. BTS_OFF_USR

当分支的目标地址属于user层(CPL！=0)时, 关闭BTS记录. 典型地, 从系统服务例程返回到用户代码时, 目标地址位于CPL！=0运行权限. 启用BTS_OFF_USR功能, 将忽略这条分支记录. 

因此, 在开启BTS记录机制时, 合理地利用这两个功能, 将有效地降低性能的损耗. 

CPL\-qualified branch record功能只能用于BTS机制, 对于LBR stack可以使用MSR\_LBR\_SELECT寄存器提供的过滤功能, 参考前面的14.5.1节描述. 

假设, 一个debugger(调试软件)只需记录用户层(即CPL！=0)软件的分支情况, 那么可以将BTS\_OFF\_OS置位来关闭OS kernel层的分支情况. 

>实验14-11: 测试BTS buffer的过滤功能

这个实验将在用户层里开启BTS机制, 然后测试关闭所有kernel层的分支记录, 为了在用户层(CPL=3权限)里能够开启BTS功能和关闭BTS功能, 以及打印BTS buffer记录. 下面实现了3个中断服务例程(在用户层里调用系统服务). 

代码清单14-33(topic14\ex14-11\protected.asm): 

```assembly
; ;  3个用户自定义系统服务例程号
; ;  分别对应于user_enable_bts(), user_disable_bts(), 以及 user_dump_bts() 函数
USER_ENABLE_BTS  equ USER_SYSTEM_SERVICE_0
USER_DISABLE_BTS  equ USER_SYSTEM_SERVICE_1
USER_DUMP_BTS   equ USER_SYSTEM_SERVICE_2
; ------------------------
;  在用户层里开启 BTS 功能
; -------------------------
user_enable_bts: 
      ; *
      ; * 关闭在 OS kernel 层的 BTS 记录
      ; * 使用环形 BTS buffer
      ; *
      mov ecx, IA32_DEBUGCTL
      mov edx, 0
      mov eax, 2C0h   ;  TR=1, BTS=1, BTS_OFF_OS=1
      wrmsr
      ret
; --------------------------
;  在用户层里关闭 BTS 功能
; -------------------------
user_disable_bts: 
      mov ecx, IA32_DEBUGCTL
      rdmsr
      btr eax, TR_BIT  ;  TR=0
      wrmsr
      ret
; --------------------------
;  在用户层打印 BTS buffer
; --------------------------
user_dump_bts: 
      call dump_ds_management
      call dump_bts_record
      ret
```

使用中断服务例程的方式调用这些函数, 是因为wrmsr指令必须在0级权限下使用. 中断服务例程(中断调用)使用在3级权限下也可以实现上面的函数功能. 

## 10.3. 注册中断服务例程

我们需要在kernel层里注册挂接上这3个用户自定义的中断服务例程, 这些服务例程将使用中断0x40(符号定义SYSTEM\_SERVICE\_VECTOR)来调用. 

代码清单14-34(topic14\ex14-11\protected.asm): 

```assembly
;  * 注册用户中断服务例程
;  * 挂接在 system_service_table 表上
      mov esi, USER_ENABLE_BTS   ;  功能号
      mov edi, user_enable_bts   ;  自定义例程
      call set_system_service_table
      mov esi, USER_DISABLE_BTS   ;  功能号
      mov edi, user_disable_bts   ;  自定义例程
      call set_system_service_table
      mov esi, USER_DUMP_BTS    ;  功能号
      mov edi, user_dump_bts    ;  自定义例程
      call set_system_service_table
```

set\_system\_service\_table()和system\_service\_table表结构实现在lib\lib32.asm文件里. 实际上, 这里并没有做权限控制, 在用户层里也可以调用set\_system\_service\_table()函数来添加任意的自定义服务例程. 从严格逻辑上来看, set\_system\_service\_table()函数必须控制在0层里调用. 这里只是作为演示目的, 并没有进行控制. 

## 10.4. 在用户代码里测试

实验的目的是在用户层里测试过滤kernel层分支记录, 因此需要从0层转到用户层里. 

代码清单14-35(topic14\ex14-11\protected.asm): 

```assembly
;  ** 进入 ring 3 代码 **
       push DWORD user_data32_sel | 0x3
       push DWORD USER_ESP
       push DWORD user_code32_sel | 0x3
       push DWORD user_entry
       retf
; ;  **********************************
; ;  下面是用户代码(CPL=3)
; ;  **********************************
user_entry: 
       mov ax, user_data32_sel
       mov ds, ax
       mov es, ax
user_start: 
       ;  开启 BTS
       mov eax, USER_ENABLE_BTS   ;  功能号
       int SYSTEM_SERVICE_VECTOR   ;  中断调用
       ;  调用中断来打印测试信息 ”hi, message from user.."
       mov esi, msg
       mov eax, SYS_PUTS
       int SYSTEM_SERVICE_VECTOR
       ;  关闭 BTS
       mov eax, USER_DISABLE_BTS
       int SYSTEM_SERVICE_VECTOR
       ;  打印 BTS
       mov eax, USER_DUMP_BTS
       int SYSTEM_SERVICE_VECTOR
next: 
       jmp $
```

在用户代码里, 使用中断来调用我们注册的自定义服务例程, 开启BTS并且BTS_OFF_OS=1, 然后通过中断调用来打印字符串信息. 接着关闭BTS, 最后打印BTS buffer信息. 

下面是在Westmere架构Core i5处理器笔记本式计算机上运行的结果. 

![config](./images/57.jpg)

在这个运行结果里, 由于关闭了kernel层的记录, 只捕捉到两条分支记录, 如下表所示. 

![config](./images/58.jpg)

这两条记录的源地址都是0000E883h, 这是中断服务例程中IRET指令的地址, 它返回的目标地址是用户代码地址. 

我们可以看到, 从中断返回到用户层可以被捕捉, 而从用户经中断调用进入系统服务例程的所有分支都被忽略了(包括INT指令). 

# 11. 64位模式下的BTS机制

前面关于BTS的探讨都是在legacy模式下进行的, 实际上在64位模式下BTS的工作原理是完全一样的. 只是需要注意的是, 在64位模式下固定使用64位的DS格式, 而不用检测是否支持DTES64(64位DS格式)功能. 

前面legacy模式下的BTS测试实验, 我们也可以编写一个64位的版本. 下面我们同样来测试一下64位模式下的BTS机制. 

>实验14-12: 测试64位模式下的BTS机制

现在, 我们的测试代码将来到long.asm模块里, 下面是测试的主体代码. 

代码清单14-36(topic14\ex14-12\long.asm): 

```assembly
;  复制测试函数到 0FFFFFFF8_10000000h 地址里
mov rsi, test_func
mov rdi, 0FFFFFFF810000000h
mov rcx, test_func_end - test_func
rep movsb
SET_DS_AREA64       ;  设置 DS 存储区域
ENABLE_BTS        ;  开启 BTS, 使用环形的 BTS buffer
; * 调用测试函数
; * 函数的地址在 0FFFFFFF8_10000000h 位置上
mov rax, 0FFFFFFF810000000h
call rax
DISABLE_BTS        ;  关闭 BTS
DUMP_BTS64        ;  打印 BTS buffer 信息
jmp $
```

为了直观显示64位的地址值, 笔者将测试函数复制到0FFFFFFF8\_10000000h位置上, 然后调用测试函数. 那么将会产生到地址0FFFFFFF8\_10000000h的分支记录. 

使用SET\_DS\_AREA64宏和ENABLE\_BTS宏来设置DS区域和开启BTS功能, 它们的原理与前面例子是一样的, 实现在inc\debug.inc文件里. 

代码清单14-37(topic14\ex14-12\long.asm): 

```assembly
; *
; ** 下面是测试函数 test_func()
; *
test_func: 
      ;  产生 6 条分支记录
jmp l1
l1: jmp l2
l2: jmp l3
l3: jmp l4
l4: jmp l5
l5: jmp l6
l6: 
      ret
test_func_end: 
```

这个测试函数只是执行6条JMP指令来产生6条分支记录, 然后返回调用者. 那么现在我们可以推测共有8条记录被捕捉到BTS buffer里. 下面是在Westmere架构处理器上的运行结果. 

![config](./images/59.jpg)

我们看到, 捕捉到的8条分支记录如下. 

![config](./images/60.jpg)

第1条是从000102C0h地址跳转到FFFFFFF8\_10000000h, 这是调用测试函数时产生的. 最后一条从FFFFFFF8\_1000000Ch地址返回到000102C2h, 这是测试函数返回产生的分支记录. 

我们看到, BTS机制的工作原理在64位模式下是完全一样的. DUMP_BTS宏是调用dump\_ds\_management()函数和dump\_bts\_record()函数, 这两个64位版本的打印函数实现在lib\debug64.asm文件里. 

>实验14-13: 在64位模式下统计PMI handler调用次数

现在, 我们再来测试一下64位模式下的非环形回路BTS buffer, 这个实验的原理和实验14-10是一致的. 但是这个实验的目的是, 打印一条测试信息, 统计这个打印信息过程里发生过多少次DS中断(BTS buffer满时产生的DS中断). 

这个实验也是在64位模式下进行的, 主体代码在topic14\ex14-13\long.asm文件里. 

代码清单14-38(topic14\ex14-13\long.asm): 

```assembly
; 
; * 实验 14-13: 统计 64位 模式下 PMI handler 调用的次数
; *
      ;  设置 IDT
      mov rsi, APIC_PERFMON_VECTOR
      mov rdi, apic_perfmon_handler
      call set_interrupt_descriptor
;  设置 performance monitor 寄存器
      mov DWORD [APIC_BASE + LVT_PERFMON], FIXED | APIC_PERFMON_VECTOR
      SET_INT_DS_AREA64      ;  设置 64位 模式下的 DS 存储区域
      ENABLE_BTS_BTINT      ;  开启 BTS, 使用中断型 BTS buffer
; ;  下面打印测试信息, 统计这个打印产生了多少分支
      mov esi, test_msg
      LIB32_PUTS_CALL
;  关闭 BTS
      DISABLE_BTS
;  打印结果
      mov esi, pmi_msg
      LIB32_PUTS_CALL
      mov esi, [pmi_counter]     ;  读 PMI counter 结果值
      LIB32_PRINT_DWORD_DECIMAL_CALL
      LIB32_PRINTLN_CALL
      LIB32_PRINTLN_CALL
; ;  打印 BTS buffer 信息
      DUMP_BTS64
      jmp $
test_msg  db 'this is a test message...', 10, 0
pmi_msg  db 'call PMI handler count is: ', 0
pmi_counter dq 0
```

在上面的代码里, 通过宏LIB32\_PUTS\_CALL来打印一个字符串信息, LIB32\_PUTS\_CALL宏实现在inc\lib.inc文件里, 这个文件定义了若干个调用32位lib32库的宏. 

```assembly
;  puts() 函数
%macro LIB32_PUTS_CALL 0
      mov eax, LIB32_PUTS
      call lib32_service
%endmacro
```

LIB32\_PUTS\_CALL宏实际上就是调用lib32.asm模块里的puts()函数来打印信息. pmi\_counter是一个变量, 用来记录PMI handler被调用的次数. 这个pmi_counter值将在PMI handler里每调用一次值递加一次. 

代码清单14-39(topic14\ex14-13\long.asm): 

```assembly
; -------------------------------
;  perfmon handler
; ------------------------------
apic_perfmon_handler: 
   jmp do_apic_perfmon_handler
ph_msg1 db '>>> now: enter PMI handler, occur at 0x', 0
ph_msg2 db 'exit the PMI handler <<<', 10, 0
ph_msg3 db '****** DS interrupt occur with BTS buffer full！ *******', 10, 0
ph_msg4 db '****** PMI interrupt occur *******', 10, 0
ph_msg5 db '****** DS interrupt occur with PEBS buffer full！ *******', 10, 0
ph_msg6 db '****** PEBS interrupt occur *******', 10, 0
do_apic_perfmon_handler: 
      ; ;  保存处理器上下文
      STORE_CONTEXT64
; *
; * 下面在 handler 里关闭功能
; *
      ; ;  关闭 TR
      mov ecx, IA32_DEBUGCTL
      rdmsr
      mov [debugctl_value], eax   ;  保存原 IA32_DEBUGCTL 寄存器值, 以便恢复
      mov [debugctl_value + 4], edx
      btr eax, 6       ;  TR=0
      wrmsr
      ; ;  关闭 pebs enable
      mov ecx, IA32_PEBS_ENABLE
      rdmsr
      mov [pebs_enable_value], eax
      mov [pebs_enable_value + 4], edx
      mov eax, 0
      mov edx, 0
      wrmsr
      ;  关闭 performance counter
      mov ecx, IA32_PERF_GLOBAL_CTRL
      rdmsr
      mov [perf_global_ctrl_value], eax
      mov [perf_global_ctrl_value + 4], edx
      mov eax, 0
      mov edx, 0
      wrmsr
; *
; * 接下来判断 PMI 引发原因
; *
check_pebs_buffer_overflow: 
      ;  是否 PEBS buffer 满
      call test_pebs_buffer_overflow
      test eax, eax
      jz check_counter_overflow
      ;  清 OvfBuffer 位
      RESET_PEBS_BUFFER_OVERFLOW
      call reset_pebs_index
check_counter_overflow: 
      ;  是否 counter 产生溢出
      call test_counter_overflow
      test eax, eax
      jz check_bts_buffer_overflow
      ; ;  清 overflow 标志
      RESET_COUNTER_OVERFLOW
check_bts_buffer_overflow: 
      call test_bts_buffer_overflow
      test eax, eax
      jz check_pebs_interrupt
      ; 
      ;  增调用 PMI handler 的 count 值
      ; 
      mov rax, pmi_counter
      inc QWORD [rax]
      ;  重设 index 值
      call reset_bts_index
check_pebs_interrupt: 
      call test_pebs_interrupt
      test eax, eax
      jz apic_perfmon_handler_done
      call update_pebs_index_track
apic_perfmon_handler_done: 
; *
; * 下面恢复功能原设置！
; *
      ;  恢复原 IA32_PERF_GLOBAL_CTRL 寄存器值
      mov ecx, IA32_PERF_GLOBAL_CTRL
      mov eax, [perf_global_ctrl_value]
      mov edx, [perf_global_ctrl_value + 4]
      wrmsr
      ;  恢复原 IA32_DEBUGCTL 设置
      mov ecx, IA32_DEBUGCTL
      mov eax, [debugctl_value]
      mov edx, [debugctl_value + 4]
      wrmsr
      ; ;  恢复 IA32_PEBS_ENABLE 寄存器
      mov ecx, IA32_PEBS_ENABLE
      mov eax, [pebs_enable_value]
      mov edx, [pebs_enable_value + 4]
      wrmsr
      RESTORE_CONTEXT64        ;  恢复 context
      btr DWORD [APIC_BASE + LVT_PERFMON], 16  ;  清 LVT_PERFMON 寄存器 mask 位
      mov DWORD [APIC_BASE + EOI], 0    ;  写 EOI 命令
      iret64
```

上面的PMI handler实际上就是实验14\-10里的PMI handler代码的64位版本, 结构和原理是完全一样的. 除了是64位版本外, 所不同的是: 

① 将PMI handler里所有的打印信息都注释掉了, 让这个PMI handler安静地运行, 外部代码根本觉察不到它在BTS buffer满时触发了DS中断. 

② 在PMI handler里对pmi\_counter值进行递增, 每进入PMI handler一次都增加计数值. 

下面是在Westmere架构Core i5处理器上的运行结果. 

![config](./images/61.jpg)

在这个运行结果里, 打印一条测试信息”this is a test message…", 导致产生了19次DS中断, 最后一条分支记录在记录1里. 那么我们可以得出, 一共捕捉了192条分支记录(包括中断调用和中断返回). 

图中的BTS buffer写满后从头开始重新记录, 并不是因为我们使用了环形回路的BTS buffer, 而是由于DS中断发生后, 在PMI handler里对BTS index进行重新设置, 使它从头开始记录. 

图中的BTS buffer信息是在关闭BTS机制后打印出来的, 由于中断handler的这些工作都是在默默地进行着, 看起来并没有产生过任何中断. 感觉和使用了环形回路的BTS buffer效果一样. 
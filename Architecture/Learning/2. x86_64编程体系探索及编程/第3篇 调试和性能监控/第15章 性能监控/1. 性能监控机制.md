
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. 性能监控机制: 事件监控为核心](#1-性能监控机制-事件监控为核心)
  - [1.1. 事件监控流程](#11-事件监控流程)
- [2. 性能监控事件分类](#2-性能监控事件分类)
- [3. 确定处理器的Model](#3-确定处理器的model)

<!-- /code_chunk_output -->

# 1. 性能监控机制: 事件监控为核心

**性能监控机制**中以**事件监控机制**为**核心**, 对发生的事件进行统计. 

## 1.1. 事件监控流程

典型的, **性能分析软件**可以使用**监控事件机制**, 对**目标软件**在执行过程中的**某些事件**进行监控. 性能分析软件**收集和分析目标软件**的**事件发生次数**. 

![config](./images/1.jpg)

如上所示: 对**发生事件统计前**, 要**开启计数器！！！** 和**选择监控的事件！！！**, Intel为不同架构的处理器定义了**多种多样的监控事件**. 

在Intel平台上, 使用**两种counter(计数器**). 

① general\-purpose PMC(Performance Monitor Counter): **通用的性能监控计数器**

② Fixed\-function counter(**固定用途的性能监控计数器**): Fixed\-function计数器**功能有限**, 但使用非常简单. 

**软件中可以设定**, 当**counter发生溢出**时产生**PMI！！！(Performance Monitoring Interrupt**)或者**PEBS！！！中断**来进行相应处理. **PMI中断**和**PEBS中断**都使用**PMI handler**进行处理. 

**PMI**是**可屏蔽的local APIC中的本地中断源(LVT！！！**), 在**LVT Performance monitor寄存器**中设置. 

# 2. 性能监控事件分类

在Intel处理器上, **performance monitoring机制**分为**两大类**. 

① **non\-architectural(非架构化**): 从Pentium处理器开始引入, 包括早期的P6家族、Pentium4家族和Xeon处理器. 

② **architectural(架构化**): 由Core微架构开始支持architectural化的performance monitoring机制. 从最初的Core Sole和Core Duo处理器开始支持. 

**non\-architectural**的**性能监控机制**是**与处理器Model相关**的, 也就是说**不同的处理器Model**可能会**不一致(！！！**). 而**architectural的性能监控机制**在**各个处理器Model**中保持**向下兼容**. 

而在**越往后**的微架构处理器中, **architectural化**的**性能监控机制都得到增强**, 越新的处理器所支持的功能可能会越强大. 

可以推广至其他的处理器机制, 例如: **non\-architectural化**的**MSR寄存器**在各个处理器Model中**地址是不同的**(或者不同Model的处理器提供不同的MSR寄存器), 而architectural化的MSR寄存器是保持向下兼容的, 后续的处理器将增强. 

# 3. 确定处理器的Model

我们在之前已经多次提及确定处理器的Model, 必须从**DisplayFamily\_DisplayModel**的值来确定, 请参考4.4节所述. 

在本章中主要围绕**06\_25H(即Westmere架构**)模型进行探讨, Westmere架构继承于Nehalem架构, 因此关于Nehalem架构的所有探讨均适合于Westmere架构, 同时**大部分也适合于Sandy Bridge架构**. 
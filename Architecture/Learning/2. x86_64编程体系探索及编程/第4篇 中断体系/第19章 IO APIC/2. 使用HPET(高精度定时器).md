
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 HPET寄存器基址](#1-hpet寄存器基址)
* [2 HPET的工作原理](#2-hpet的工作原理)
	* [2.1 HPET寄存器](#21-hpet寄存器)
	* [2.2 HPET counter频率](#22-hpet-counter频率)
	* [2.3 HPET配置](#23-hpet配置)
	* [2.4 Timer定时器配置寄存器](#24-timer定时器配置寄存器)
	* [2.5 Timer 0的配置](#25-timer-0的配置)
	* [2.6 HPET status寄存器](#26-hpet-status寄存器)
	* [2.7 开启和初始化HPET](#27-开启和初始化hpet)

<!-- /code_chunk_output -->

我们将了解一下HPET(high precision event timer)的使用, 作为对I/O APIC另一个补充**应用实例**的讲解。

**HPET的所有寄存器**使用**直接内存映射形式**(不像I/O APIC寄存器的**间接访问方式**), **软件直接访问寄存器所映射的地址**。

注: **外设**一般都有自己的**寄存器(配置空间**), **映射方式**不一定一致.

# 1 HPET寄存器基址

根据Intel的PCH datasheet文档介绍, **HPET寄存器基址**有**4个选择**, 如下表所示。

![config](./images/12.png)

最终的**HPET寄存器基址**由**HPET配置寄存器address select域**来决定, HPET配置寄存器结构如下所示。

![config](./images/13.png)

**HPET配置寄存器**的bit 7位是HPET寄存器**内存映射地址开启位(！！！**), 置位时**HPET地址区域可用**。bit 1和bit 0是HPET地址选择域, 在上表中的**4个HPET寄存器基址中选择一个**, 默认值为00B, 使用**FED00000h作为HPET寄存器的基址**。

**HPET配置寄存器**位于**RCBA(root complex base address**)的**3404h偏移地址**上, 和前面所说**OIC寄存器处理同一个配置空间(！！！RC配置空间中, 和OIC<IO APIC>是同等地位关系, 都是PCIE直接外设！！！**), 使用get\_root\_complex\_base\_addrss()函数获取**RCBA地址**。

**重要(！！！**):通过**PCI的宏**找到**RCBA基地址**, 然后通过**相应的偏移**找到**HPET配置寄存器(不同于HPET寄存器的configure寄存器！！！**), 通过该**寄存器的地址选择域获取HPET寄存器的基址**, HPET的**相关寄存器**都是在该**基址的相应偏移位置**.

# 2 HPET的工作原理

HPET有**1个main counter(主计数器**)寄存器和**最多8个timer(定时器**), 记为**timer 0～timer 7定时器**。**每个timer**有自己的**一对寄存器**, 分别是: **configure(timer配置寄存器**)和**comparator value(timer比较值寄存器**)。

**HPET counter**按**固定的频率进行计数**, HPET会检查**counter的值**与**timer的comparator值**进行对比。当**counter的值**达到**任何一个timer的comparator值**时将产生中断(当**配置可产生中断时**)。

那么, 如果counter**同时达到**了**多个timer所设定comparator值**就会产生**多个中断**。**HPET**的**8个timer**可以配置为使用**不同的IRQ线(！！！**), 这些**同时产生中断就可以同时进行处理(！！！**)。

## 2.1 HPET寄存器

HPET寄存器分**5组**, 分别是: **ID寄存器**, **configure寄存器**, **status寄存器**, **counter寄存器**, 以及**每个timer**的**configure/comparator寄存器对**。如下表所示。

![config](./images/14.png)

**每个HPET寄存器**都是**64位宽**, 因此, 在32位的代码下, 软件访问完整的64位寄存器需要进行**两次的32位读/写操作**。如以下代码所示。

```x86asm
mov DWORD [HPET_TIMER0_COMPARATOR + 4], 0   ； timer#0 comparator寄存器高32位
mov DWORD [HEPT_TIMER0_COMPARATOR], 1431800  ； timer#0 使用 100ms 定时
```

**HPET ID寄存器**是**只读寄存器**, 软件可以读取HPET具备哪些功能, 其中一个是得到HPET counter的**计数频率**。

## 2.2 HPET counter频率

**HPET ID寄存器**的**高32位**返回一个**32位的counter计数频率值**, 读ID寄存器时这个值将返回0429B17Fh(十进制数69841279, **固定的！！！**)。HPET counter将是**69841279 fs计数1次**, 也就是69.841279 ns计数1次。那么, 每纳秒counter计数=1/69.841279≈**0.014(次**)。

![config](./images/15.png)

上表列出了所有的**时间单位内counter的计数次数**。需要使用100ms的定时, 我们可以为timer的comparator寄存器设1431800。10us的定时comparator可以设为140。

那么**软件**上可使用的**最小定时精度是69ns(！！！**)。也就是说, **timer comparator的值设为1**时, 是**69ns产生一次中断**。

## 2.3 HPET配置

HPET的**configure寄存器**(**HPET base+10h**)对HPET进行总体上的配置, 这个寄存器**只有两个配置位**, 如下所示。

![config](./images/16.png)

Overall enable位(bit 0)**必须设为1**, 允许**HPET counter进行计数**。否则HPET counter将**停止计数也不会产生中断**。

当**legacy replacement route位(bit 1)置位**时: 

① **timer 0**固定使用**I/O APIC**的**IRQ2或8259的IRQ0**。

② **timer 1**固定使用**I/O APIC**的**IRQ8或8259的IRQ8**。

在这种情况下**timer 0**和**timer 1**将不受**timer 0 configure**和**timer 1 configure寄存器的影响(！！！**), 使用**固定的IRQ线产生中断**。否则将由各自的configure寄存器进行配置。

## 2.4 Timer定时器配置寄存器

**每个timer定时器**有自己的**配置寄存器**, 进行具体的配置和管理, 如下所示。

![config](./images/17.png)

**Bit 1**指示timer使用的**trigger模式**(0是edge, 1是level), bit 2位**开启和关闭timer的中断许可**(0是disable, 1是enable)。

每个timer的interrupt route(中断线路)配置由route capability和route两部分决定, bit 55～bit52, 以及bit 44～bit 43两个域是只读域, 决定timer具备配置到哪条IRQ线上的能力, 如下表所示。

![config](./images/18.png)

timer 0、1、2, 以及3都可以配置使用IRQ20～IRQ23。timer 2和3可以额外使用IRQ11。

timer 0和1的配置还将受制于HPET configure(HPET base+10h)寄存器的legacy replacement route位(当此位为1时, tiemr 0和1固定使用IRQ2及IRQ8)。Timer 4、5、6, 以及7不能进行配置, 将使用固定的processor message形式, 不经过IRQ线路。

当知道可以配置到哪条IRQ线上后, interrupt route(bit 13～bit 9)具体配置到哪条IRQ线上, 需要软件写入相应的数值。当legacy replacement route位为1时, 这个域对timer 0和1来说是被忽略的。

Bit 15(processor message interrupt支持位), 固定为1, 表明PCH支持processor message interrupt类型。

Bit 14(processor message interrupt开启位), 对timer 4、5、6, 以及7来说。此位固定为1, 表明timer 4、5、6、7必须使用processor message interrupt模式。

## 2.5 Timer 0的配置

在上图的timer configure寄存器里, 有部分位只针对timer 0有效, 其他timer被忽略或使用固定的设置, 如下表所示。

![config](./images/19.png)

只有timer 0才支持periodic(周期)模式, periodic enable置位时开启周期运行模式。当开启periodic模式时, timer value set(bit 6)置位, timer 0的comparator值将自动增加。

```x86asm
mov DWORD [HPET_TIMER0_CONFIG], 0000004Ch  ； 使用64位size, period
ic模式
mov DWORD [HPET_TIMER0_CONFIG + 4], 0
… …
mov DWORD [HPET_TIMER0_COMPARATOR + 4], 0
mov DWORD [HPET_TIMER0_COMPARATOR], 123h  ； comparator 值为 123h
```

在上面的代码里, timer 0使用periodic模式(并且timer value set位置位), 当HPET counter值达到123h时, timer 0产生一次中断。timer 0的comparator值将自动增加为246h。当counter又达到246h时, timer 0的comparator值又自动增加为369h, 以这种形式达到周期性产生中断的目的。

如果counter的值达到最大值回绕到0重新开始计数, 那么如果此时timer 0的comparator达到0FFFFFFFF\_FFFFFFF0h值, 又需要增加123h值, 将回绕到00000000_00000113h。这样周而复始地使用123h的间隔值产生中断, 除非软件关闭中断产生。

## 2.6 HPET status寄存器

当使用**level触发模式**时, 产生中断将记录在HPET status寄存器里, 如下所示。

![config](./images/20.png)

bit 7～bit 0每1位代表1个timer的中断状态, 对于使用edge触发模式的timer产生的中断将被忽略, 不会反映在status寄存器里。

当相应的timer interrupt active置位时, 软件需要在相应的位写入1清除active状态值。如果写入0将是无效的。

## 2.7 开启和初始化HPET

在使用HPET时必须对HPET进行初始化的配置工作, 下面的代码实现在lib\hpet.asm文件里。

代码清单19-6(lib\hpet.asm): 

```x86asm
；------------------------------------
； enable_hpet(): 开启 HPET(高精度定时器)
；------------------------------------
enable_hpet: 
；*
；* 读取 HPET 配置寄存器
；* Address Enable 位置位, 开启 HPET 地址
；* Address Select 域设置为 00B, HPET 基址位于 0FED00000h
；
       call get_root_complex_base_address
       mov esi, [eax + 3404h]
       bts esi, 7                        ； address enable 位
       and esi, 0FFFFFFFCh              ； address select=00B
       mov [eax + 3404h], esi
；*
；* 设置 HPET 的配置寄存器
；*
；* legacy replacement rout=1 时: 
；*      1. timer0 转发到 IOAPIC IRQ2
；*      2. timer1 转发到 IOAPIC IRQ8
；*
；* overall enable 必须设为 1
；*
       mov eax, 3                       ； Overall Enable=1, legacy replacement rout=1
       mov [HPET_BASE + 10h], eax
；*
；* 初始化 HPET timer 配置
；*
       call init_hpet_timer
       ret
；------------------------------------------
； init_hpet_timer(): 初始化 8 个 timer
；------------------------------------------
init_hpet_timer: 
；*
；* HPET 配置说明: 
；*
；* ①. timer 0 配置 routed 到 IO APIC 的 IRQ2 上
；* ②. timer 1 配置 routed 到 IO APIC 的 IRQ8 上
；* ③. timer 2, 3 配置 routed 到 IO APIC 的 IRQ20 上
；* ④. timer 4, 5, 6, 7 必须使用 direct processor message 方式
；*    而不是 routed 到 8259 或 IO APIC 的 IRQ
；*
       ；*
       ；* timer 0 配置为: 周期性中断, 64 位的 comparator 值
       ；*
       mov DWORD [HPET_TIMER0_CONFIG], 0000004Ch
       mov DWORD [HPET_TIMER0_CONFIG + 4], 0
       mov DWORD [HPET_TIMER1_CONFIG], 00000004h
       mov DWORD [HPET_TIMER1_CONFIG + 4], 0
       mov DWORD [HPET_TIMER2_CONFIG], 00002804h
       mov DWORD [HPET_TIMER2_CONFIG + 4], 0
       mov DWORD [HPET_TIMER3_CONFIG], 00002804h
       mov DWORD [HPET_TIMER3_CONFIG + 4], 0
       ret
```
enable\_hpet()函数先读取HPET配置寄存器(通过RCBA基址+3404h), 开启HPET基址可用, address select值设为0(使用FED00000h基址), 并对HPET的总体configure寄存器进行设置, 这里将timer 0设置为使用I/O APIC的IRQ2, timer 1使用IRQ8, 允许counter计数。最后调用init\_hpet\_timer()函数对剩余的timer进行设置。

>实验19-2: 使用HPET timer的10分钟计时器

在这个例子里, 将HPET的timer 0定时器作为一个计时器使用, 使timer每秒产生一次中断, 当达到10分钟就停止计时。下面是实验的主体代码。

代码清单19-7(topic19\ex19-2\protected.asm): 

```x86asm
； 实验19-2: 使用HPET timer的计时器
       mov esi, IOAPIC_IRQ2_VECTOR
       mov edi, ioapic_irq2_handler
       call set_interrupt_handler
       ； 设置 I/O APIC redirection table 寄存器
       mov DWORD [IOAPIC_INDEX_REG], IRQ2_INDEX
       mov DWORD [IOAPIC_DATA_REG], LOGICAL | FIXED_DELIVERY | IOAPIC_IRQ2_VECTOR
       mov DWORD [IOAPIC_INDEX_REG], IRQ2_INDEX + 1
       mov DWORD [IOAPIC_DATA_REG], 08000000h   ； 使用 processor #4
       mov esi, msg
       call puts
       call get_video_current               ； 计时器打印的当前位置
       mov [position], eax
       ；*
       ；* 开启使用 timer 0, 使用每秒中断1次
       ；*
       START_HPET_TIMER 0, HPET_COUNT_SECOND, 1
       jmp $
```

由于timer 0使用I/O APIC的IRQ2线路, 因此需要为I/O APIC IRQ2设置相关的中断服务例程。Redirection table 2寄存器使用Fixed delivery模式, edge触发。目标处理器使用logical目标模式(目标处理器为processor #4)。

最后使用START\_HPET\_TIMER宏来启动timer 0定时, 这个宏实现在inc\hpet.inc文件里。

代码清单19-8(inc\hpet.inc): 

```x86asm
；----------------------------------------------------
； 宏 START_HPET_TIMER(): 开启定时器
； input: 
；       %1 – timer
；       %2 - 时间单位
；       %3 - 单位值
；
； 示例: 
；       START_HPET_TIMER  0, HPET_COUNT_MILLISECOND, 100
；--------------------------------------------------------
%macro START_HPET_TIMER 3
      bts DWORD [HPET_BASE + 100h + (20h * %1)], 2
      mov DWORD [HPET_BASE + 108h + (20h * %1) + 4], 0
      mov DWORD [HPET_BASE + 108h + (20h * %1)], (%2 * %3)
      mov DWORD [HPET_COUNTER + 4], 0
      mov DWORD [HPET_COUNTER], 0
%endmacro
```
宏START\_HPET\_TIMER需要3个参数, 分别是timer编号、时间单位和单位值。像实验例子里的使用方法: 
```x86asm
START_HPET_TIMER 0, HPET_COUNT_SECOND, 1
```
使用timer 0, 时间单位使用秒, 单位值为1(即每秒产生中断一次)。HPET\_COUNT\_SECOND的常量值定义在inc\hpet.inc文件里, 它的值是14318179(十进制数)。

代码清单19-9(topic19\ex19-2\protected.asm): 

```x86asm
；--------------------------------------
； IOAPIC IRQ2 中断 handler
；--------------------------------------
ioapic_irq2_handler: 
      jmp do_ioapic_irq2_handler
second  dd 0
minute  dd 0
do_ioapic_irq2_handler: 
      mov ebx, [minute]
      mov edx, [second]
      cmp ebx, 10
      jb print_timer
      STOP_HPET_TIMER 0      ； 停止 timer 中断产生
      jmp ioapic_irq2_handler_done
print_timer: 
      mov esi, [position]
      call set_video_current
      cmp edx, 59        ； 是否达到 1分钟
      jb ioapic_irq2_handler_next
      inc ebx         ； 是的话minute++
      xor edx, edx
ioapic_irq2_handler_next: 
      ； 打印分钟
      mov esi, ebx
      cmp ebx, 10
      mov eax, print_byte_value
      mov edi, print_dword_decimal
      cmovae eax, edi
      call eax
      mov esi, ': '
      call putc
      ；打印秒钟
      mov esi, edx
      cmp edx, 10
      mov eax, print_byte_value
      mov edi, print_dword_decimal
      cmovae eax, edi
      call eax
      inc edx         ； second++
      mov [second], edx
      mov [minute], ebx
ioapic_irq2_handler_done: 
      mov DWORD [APIC_BASE + EOI], 0   ； 发送 EOI 命令
      iret
```

最后这是I/O APIC的IRQ2中断处理程序代码, 这个处理程序进行的处理是: 每调用一次增加一次second值。当second值大于59时, minute值增加一次。并将它们的值打印在指定的位置上(由position值得到)。

当minute达到10(即10分钟)时, 处理程序关闭timer的中断许可。在处理程序的未尾需发送EOI命令给local APIC。

![config](./images/21.png)

上图是在笔者的机器上运行的某刻抓拍的, 当显示到10: 00(满十分钟)时会停止继续计时。
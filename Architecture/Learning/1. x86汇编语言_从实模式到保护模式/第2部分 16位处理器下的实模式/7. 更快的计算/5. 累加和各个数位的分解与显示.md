```
7.5 累加和各个数位的分解与显示 
　　7.5.1 栈和栈段的初始化 
　　7.5.2 分解各个数位并压栈 
　　7.5.3 出栈并显示各个数位 
　　7.5.4 进一步认识堆栈 
```

## 1. 栈和栈段的初始化

得到累加和之后, 后面就是将它各个数位分解出来, 并准备显示在屏幕上. 

将分解出来的各个数位并不保存在数据段中, 而保存在栈中. 

数据还是在内存中, 栈(Stack)不过是一种特殊的读写方式. 

和代码段、数据段和附加段一样, 堆栈也被定义成一个内存段, 叫堆栈段(Stack Segment), 由段寄存器 SS 指向. 

堆栈的操作有两种, 分别是将数据推进堆栈(push)和从堆栈中弹出数据(pop). 堆栈指针寄存器 SP(Stack Pointer)表示栈顶. 

定义堆栈只需要初始化段寄存器SS和堆栈指针SP的内容. 

源码40 ~ 42将堆栈段的段地址设置为0x0000, 堆栈指针设为0x0000. 

我们定义了3个段了, 图7-2是当前内存布局. 总的内存容量是 1MB, 物理地址的范围是 0x00000～0xFFFFF, 其中, 假定数据段的长度是64KB(实际上它的长度无关紧要), 占据了物理地址 0x07C00～0x17BFF, 对应的逻辑地址范围是0x07C0:0x0000～0x07C0:0xFFFF; 代码段和堆栈段是同一个段, 占据着物理地址0x00000～0x0FFFF, 对应的逻辑地址范围是0x0000:0x0000～0x0000:0xFFFF. 

![config](images/1.png)

## 2. 分解各个数位并压栈

数位分解还是做除法. 每次除法结束后, 做一次判断, 如果商为0, 分解结束. 

将每次得到的数入栈, 将来还要出栈, 所以使用CX寄存器计算数位个数. 

源码48、49行, 将DX清零, 并和 AX 一起形成 32 位的被除数. 

32位除以16位, 商在AX中, 余数在DX中. 

与xor一样, or也是逻辑运算指令. 

16位处理器上, **push指令**的操作数可以是**16位寄存器或内存单元**. 对于内存单元: 

```
push word [label_a]
```

**push指令只接受16位的操作数**, 为什么要对内存操作数使用关键字”word". 事实上, 8086处理器只能压入一个字; 但其后的处理器允许压入字、双字或者四字, 因此, 关键字是必不可少的. 

就8086处理器来说, 因为压入堆栈的内容必须是字, 所以, 下面的指令都是非法的: 

```
push al
push byte [label_a]
```

处理器在执行**push指令**时: 

- **首先**将堆栈指针寄存器SP的内容**减去操作数的字长**(以字节为单位的长度, **在16位处理器上是2**), 

- 然后, 把**要压入堆栈的数据**存放到**逻辑地址SS:SP所指向的内存位置**(和其他段的读写一样, 把堆栈段寄存器 SS 的内容左移 4 位, 加上堆栈指针寄存器 SP 提供的偏移地址). 

如图7-3, 代码段和堆栈段是同一个段, CS和SS都是 0x0000. 源码第 42 行SP被置为 0. 所以, 当 push 指令第一次执行时, SP的内容减2, 即0x0000－0x0002＝0xFFFE, 借位被忽略. 被压入堆栈的数据, 在内存中的位置实际上是 0x0000:0xFFFE. push 指令的操作数是字, 而且Intel处理器是使用低端字节序的, 故低字节在低地址部分, 高字节在高地址部分, 正好占据了堆栈段的最高两个字节位置(dx的dh在高字节, dl在低字节). 

![config](images/2.png)

不同于代码段, 代码段在处理器上执行时, 是由低地址端向高地址端推进的, 而压栈操作则正好相反, 是从高地址
端向低地址端推进的. (这是一种存储器堆栈的一种方式, 堆栈向下增长, 这和处理器有关系)

push 指令不影响任何标志位. 

## 3. 出栈并显示各个数位

压栈次数(数位的个数)存在寄存器CX中. 数位是按”个位"、”十位"、”百位"、”千位"、”万位"的顺序依次压栈(实际情况取决于数的大小), 出栈正好相反. **所以可以顺序将它们弹出堆栈并显示在屏幕上**. 

源码57行, pop dx指令功能是将逻辑地址SS:SP处的一个字弹出到寄存器DX中, 并**将SP内容加上操作数的字长**(2). 

pop指令执行时, 处理器将堆栈段寄存器SS的内容左移4位, 再加上堆栈指针寄存器SP的内容, 形成20位的物理地址访问内存, 取得所需的数据. 然后, 将SP的内容加操作数的字长, 以指向下一个堆栈位置. 

pop 指令不影响任何标志位. 

第 62 行, 每次执行 loop 指令时, 处理器都是先将寄存器CX减一. 当所有的数位都弹出和显示以后, CX必定为零, 这将导致退出循环. 

当处理器最后一次执行出栈操作后, 堆栈指针寄存器 SP 的内容将恢复到最开始设置时的状态, 即它的内容重新为 0. 

## 4. 进一步认识堆栈

关于堆栈, 有几点说明. 

第一, push 指令的操作数可以是**16位寄存器**或者**指向16位实际操作数的内存单元地址**, push指令执行后, 压入堆栈中的仅仅是该寄存器或者内存单元里的数值, 与该寄存器或内存单元不再相干. 所以, 下面的指令是合法而且正确的: 

```
push cs
pop ds
```

这两条指令的意思是, 将代码段寄存器的内容压栈, 并弹出到数据段寄存器DS. 这样, 代码段和数据段将属于同一个内存段. 实际上, 这两条指令的执行结果和下面指令执行结果相同: 

```
mov ax,cx
mov ds,ax
```

第二, 堆栈在本质上也是普通的内存区域, 堆栈、push和pop指令只是方便程序开发. 

第三, 要注意保持堆栈平衡, 防止数据访问越界, 防止破坏有用的数据. 特别当堆栈段和其他段在同一个段时. 如图7-3, 堆栈段和代码段属于同一个内存段, 段地址都是0x0000, 段的长度都是64KB. 主引导程序的长度是512(0x200)字节, 从偏移地址0x7c00 延伸到0x7e00. 堆栈是向下增长的, 它们之间有0xffff－0x7e00＋1＝0x8200字节的空档. 通常来说, 我们的程序是安全的, 因为不可能压入这么多的数据. 
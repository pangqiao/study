
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [从虚拟地址到物理地址](#从虚拟地址到物理地址)
- [1. 简单的分页模型](#1-简单的分页模型)
- [2. 页目录、页表和页](#2-页目录-页表和页)
  - [页表](#页表)
  - [页目录(Page Directory Table, PDT)](#页目录page-directory-tablepdt)
- [3. 地址变换的具体过程](#3-地址变换的具体过程)

<!-- /code_chunk_output -->

Intel处理器访问内存的基本策略是分段. 在16位实模式下, 段的起始位置必须16字节对齐, 而且段的长度最大是64KB. 

进入32位保护模式之后, 强化了分段功能, 并提供了保护机制. 此时, 段可以起始于任何位置, 段长度可以扩展到处理器的最大寻址范围边界. 典型, 早期32位处理器由32根地址总线, 因此, 段的长度可以扩展到4GB. 

在32位保护模式下, 对段的访问本着"先登记, 后访问"的原则进行. 登记就是在GDT或者LDT中登记段的描述符, 规定了段的地址和边界, 以及访问权限; 访问时, 需要使用段描述符的选择子. 处理器用段界限和特权级别审查对段的访问, 任务非法访问都会被处理器阻止, 并立即产生异常中断. 

一般情况下, 先安装一个操作系统. 这时, 段是由操作系统负责管理的. 操作系统加载应用程序, 根据程序的要求, 为它创建一个或多个段, 然后将控制权交给它. 

有些资料说是为了实现"虚拟内存", 真的是这样吗？如果没有分页机制, 能否实现"虚拟内存"？答案是肯定的. 

当同时运行的程序和任务很多时, 内存可能就不够用了. 这时, 操作系统的价值就体现出来了, 每个段描述符有A位, 每当访问一个段时, 处理器会将其置位. A位的清零由操作系统定时进行, 它借此统计段的访问频度. 当内存不够用时, 它可以将那些较少访问的段换出到磁盘上, 以腾出空间来给马上运行的段使用. 一旦某个段被换到磁盘上, 操作系统应将描述符的P位清零. 当这个段又被访问, 因描述符P位是"0", 处理器引发段**不存在异常(中断号为11)**. 这类中断通常由操作系统负责处理的, 它会同样方法腾出空间, 将这个段的内容从磁盘调入内存. 当这类中断返回, 处理器会再次执行引发异常的那条指令(而不是下条指令), 于是程序又能继续执行了. 

由此可见, 即使没有分页机制, 利用"分段"也可以实现"虚拟内存". 

但是, 因为段的长度不定, 分配内存时, 可能发生内存空闲区域小于要加载的段, 或空闲区域远远大于要加载的段. 前一种情况, 需要寻找合适的空闲区域; 后一种, 分配成功, 但过于浪费. 为解决这个问题, 从80386开始, 引入了分页机制. 

分页机制简单来说, 是用长度固定的页来代替长度不定的段, 以解决因段的长度不同带来的内存空间管理变得复杂的问题. 

尽管操作系统也可以利用纯软件来实施固定长度的内存分配, 但是太过于复杂. 由处理器固件来做这件事情, 可以省去很多麻烦, 速度也可以提高. 

## 从虚拟地址到物理地址

分页机制是80x86内存管理机制的第二部分. 它在分段机制的基础上完成虚拟(逻辑)地址到物理地址转换的过程. 分段机制把逻辑地址转换成线性地址, 而分页则把线性地址转换成物理地址.  

![config](images/1.png)

分页机制会把**线性地址空间**(段已映射到其中)划分成页面, 然后这些线性地址空间的页面被映射到物理地址空间的页面上. 

![config](images/2.png)

80x86使用4K(2的12次方)字节固定大小的页面. 每个页面均是4KB, 且对齐于4K地址边界处(地址的低12位全是0). 

## 1. 简单的分页模型

一旦决定采用页式内存管理, 就应**把4GB内存分成大小相同的页**, 不是在内存中随意找个位置让页从那儿开始. 

分页机制也没有增加程序员的负担, 程序依然按照段来组织. 问题在于, 如何将较大的段, 映射到大小相同的页面上呢？

如图16-3, 内存的分配涉及段空间的分配和页分配. 左边是虚拟的4GB内存空间, 称为虚拟内存; 右边是实实在在的内存, 被分成1048576个4KB页面. 

![config](images/4.png)

在分页模式下, 操作系统可以创建一个为所有任务共用的4GB虚拟内存空间, 也可以为每个任务创建独立的4GB虚拟内存空间. 当一个程序加载时, **操作系统既要在左边的虚拟内存中分配段空间, 又要在右边的物理内存中分配相应的页面**. 因此, **第一个步骤是寻找空闲的段空间**, 该段空间既没有被其他程序使用, 也没有被同一程序的其他段使用. 比如图16-3, 假设已经找到并分配一个段空间, 基地址是0x00200000, 长度是8200字节. 

页最小4KB, 即4096字节. 因此, 8200字节的段, 需要占用3个页面(**所以内存分页管理机制的基本原理是将CPU整个线性内存区域(！！！线性地址是32位, 可寻址范围4GB)划分成4KB为1页的内存页面**), 其中最后一个页面只用了8个字节, 其他都浪费着, 如果允许页共享, 多个段或多个程序可以用同一个页来存放各自数据. 

在分段之后, 操作系统将段拆分, 并分别映射到物理页. 注意, **段必须是连续的, 但不要求所分配的页都是连续的**. 分配页面时, 操作系统会搜索那些空闲的页, 并分配给程序使用, 所分配页面的总长度要大于等于段长度. 

图中是个具体的例子. 

4GB虚拟内存空间不可能用来保存任何数据, 因为是虚拟的. 它只是指示内存的使用情况. **当操作系统加载一个程序并创建为任务时, 操作系统在虚拟内存空间寻找空闲的段, 并映射到空闲的页. 然后, 当真正开始加载程序时, 再把原本属于段的数据按页的尺寸拆分, 分开写入对应的页中**. 

4GB(2的32次方)的线性地址空间可以划分为1048576(2的20次方, 即1M)个页面. 为了根据线性地址找到对应的物理地址, 操作系统必须维护一张表(如下图所示).  

![config](images/3.png)

这个表暂且叫做"页映射表", 它一共有1048576个表项. 这是一个一维表格, **每个表项占4个字节**, 其内容是某个页的起始物理地址(共32比特, 低12位全为0). 页映射表是这样使用的: **因为页的尺寸是4KB, 所以线性地址的低12位可以作为页内偏移, 高20位可以用来索引一个表项, 找到了这个表项, 就找到了对应的物理页. 因此, 线性地址的高20位为索引, 乘以4, 作为表内偏移量, 从表中取出一个双字, 那就是该线性地址对应的页的物理地址**. 

如图16-4, 如果执行指令

```
mov edx, [0x2002]
```

段部件使用段地址0x00200000加上指令中给出的偏移量0x2002, 得到线性地址0x00202002. 线性地址的高20位是表格索引, 即0x00202. 将索引乘以4, 得到0x00808, 这就是表内偏移. 看图, 从该单元可以取出一个双字0x00007000, 这就是页物理地址. 

线性地址低12位是页内偏移量, 用页物理地址加上页内偏移量, 就是最终的物理地址. 0x00007000加上0x002, 得到0x00007002, 这就是实际要访问的物理内存地址. 

![config](images/5.png)

问题是, 为什么表内偏移量为0x00808的地方, 会恰好是页地址0x00007000, 而不是其他页地址？

**当程序加载时**, 操作系统会首先在虚拟内存中分配段. 然后, 根据段需要分成多少页, 来搜索空闲页面. 当段较大时, 要按页的尺寸分成好几个地址区段, 操作系统用每个区段的首地址, 取高20位, 乘以4, 作为偏移量访问表格, 并将分配给该区段的**页的物理地址**写入该表项. 最后, 将原本需要写入每个区段的程序数据, 写到对应的页中. 

注意, 在页式内存管理中, 页面的管理和分配是独立的, 和分段以及段地址没有关系. **操作系统所做的,  就是寻找空闲页面, 把它分配给需要的段, 并将页的物理地址填写到映射表内**. 

基于上面特点, 一般, **每个任务都可以拥有4GB的虚拟内存空间; 同时, 每个任务有自己的页映射表**, 如图16-5. 

![config](images/6.png)

## 2. 页目录、页表和页

第一个支持分页内存管理模式的Intel处理器是80386, 那时候, 分页机制很简单. 

上文提到的页映射表, 一共有1048576(=1M)个表项, 每个表项占4个字节, 所以表的大小是4MB, 在当时看来要占用相当一部分内存. 考虑到在实践中, 没有哪个任务会真的用到所有表项, 充其量只是很小一部分, 所以内存中放一个4MB的表格确实很浪费. 也许你会建议, 能不能先划出一小片内存, 只存表格用到的部分, 然后根据需要动态扩展. 的确, 这个方法可行. 但是因为特殊原因(后面我们会学习到, 整个映射表的前一半对应全局地址空间, 后一半对应局部地址空间), 这张表从一开始就必须完全定义(留够空间), 所以不可避免地要占用4MB的内存空间. 为了解决这个问题, 同时又不会浪费宝贵的内存空间, 处理器设计了层次化的分页结构. 

分页结构层次化的主要手段是不采用单一映射表, 使用页目录和页表. 

如图. 

![config](images/7.png)

### 页表

4GB(2的32次方)的线性地址空间可以划分为1048576(2的20次方, 即1M, 也可以看成是1024\*1024)个页面, 所以, 可以**随机地抽取这些页面, 每1024个页面是一组,可以分成1024组**. 对于每组中1024个页面的物理地址, 按某种顺序排列可以构成一张表(每个表项都是一个页面的物理地址), 这个表就是**页表**. **页表的大小是1024\*4字节=4KB, 刚好是一个物理页的大小**. 

注意, 页在页表中的分布是随机的, 哪个页在哪个页表中, 这是没有规律的. 

### 页目录(Page Directory Table, PDT)

因为已经分成了1024组, 每组都有一个页表(大小为4KB), 所以**这1024个页表又可以用一张表来指向, 这就是页目录**. 类似于页表, 页目录共有1024个表项(称作页目录项), 每个页目录项的内容是某个页表的物理地址. 页表的大小是1024*4字节=4KB, 刚好是一个物理页的大小. 

需要注意的是:  

1. 这样的层次化分页结构是每个任务都有的, 或者说**每个任务都有自己的页目录和页表**. 在处理器内部, 有一个控制寄存器叫CR3, 存放着**当前任务的页目录的物理地址**, 故CR3又叫做页目录基址寄存器(Page Directory Base Register, PDBR). 
2. **每个任务都有自己的TSS**, 其中就包括了**CR3寄存器域**, 存放着任务自己的页目录的物理地址. 当任务切换时, CR3寄存器的内容也会被更新, 更新为新任务的页目录的物理地址.  
3. **页目录和页表也是普通的页, 混迹于全部的物理页中**. 它们和普通的页没有什么区别, 无非就是功能不一样. 当任务被操作系统撤销后, 它们和任务所占用的**普通的物理页一样会被回收**.  
4. **页目录总是在物理内存中, 页表可以在需要时再分配, 这样就大大节省了物理内存**. 

![config](images/8.png)

## 3. 地址变换的具体过程

对于Intel处理器而言, 有关分页, 最简单和最基本的机制就是这些: **CR3寄存器给出页目录的物理基地址; 页目录给出所有页表的物理地址, 而每个页表也给出了它所包含的页的物理地址(都是物理地址！！！)**. 

具体怎么变换, 举例子来说明吧.  

假设某个任务加载后, 操作系统根据实际情况, 在其4GB的虚拟地址空间里创建了一个段, 段的起始地址是0x00800000, 界限值是0x5000, 字节粒度. 当该任务执行时, 段寄存器DS指向该段. 执行指令: 

```
mov edx, [0x1050]
```

此时, 段部件输出的线性地址是0x00801050,如果没有开启分页, 那么这个地址就是物理地址; 但是现在开启了分页, 所以要经过页部件的转换, 才能得到物理地址. 

处理器的页部件专门负责线性地址到物理地址的转换工作. 它**首先将32位的线性地址分成3段**, 分别是高10位, 中间10位和低12位. **高10位用来索引页目录, 中间10位用来索引页表, 低12位作为页内偏移**. 

1. 当前任务的页目录的物理地址在CR3寄存器中, 假设是0x00005000;
2. 段部件输出的线性地址是0x00801050,按照高10位, 中间10位和低12位分为三段, 分别是0x002,0x001,0x050;
3. 0x002乘以4(**因为每个表项占4个字节**)得到0x008,作为偏移访问页目录, 得到了0x08001000,这就是页表的物理地址. 
4. 0x001乘以4(因为每个表项占4个字节)得到0x004,作为偏移访问页表, 得到了0x0000c000,这就是我们要找的那个物理页的起始地址. 
5. 0x050作为页内偏移, 和物理页的起始地址0x0000c000相加, 得到0x0000c050,这就是最终的物理地址, 要访问的数据就在这里. 

![config](images/12.png)

注意, 这种变换不是无缘无故的, 而是事先安排好的. 当任务加载时, 操作系统先创建虚拟的段, 并根据段地址的高20位决定使用哪些页目录和页表项. 然后, 寻找空闲的页, 将原本该写入段中的数据写入到一个或多个页中, 并将页的物理地址填写到相应的页表项中. 只有这样, 当程序运行时, 才能以相反顺序进行正确的地址变换. 

在**多进程环境**下, **处理器**使用 **MMU** 机制,  使得**每一个进程**都有**独立的虚拟地址空间**, 从而各个进程运行在独立的地址空间中,  互不干扰. MMU 具有两大功能, 一是进行**地址转换**, 将分属**不同进程的虚拟地址**转换为**物理地址**; 二是**对物理地址的访问**进行**权限检查**, 判断虚实地址转换的合理性.

在多数操作系统中, **每一个进程**都具有**独立的页表**存放**虚拟地址**到**物理地址**的**映射关系和属性**. 但是如果进程每次访问物理内存时, 都需要访问页表时, 将严重影响进程的执行效率. 为此处理器设置了 **TLB**(`Translation Lookaside Buffer`) 作为页表的 Cache. 如果进程的虚拟地址在 TLB 中命中时,  则从 TLB 中直接获得物理地址,  而不需要使用页表进行虚实地址转换, 从而极大提高了访问存储器的效率.

从地址转换的角度来看, IOMMU 与 MMU 较为类似. 只是 **IOMMU** 完成的是**外部设备地址**到**存储器地址**的转换. 我们可以将一个 PCI 设备模拟成为处理器系统的一个特殊进程, 当这个进程访问存储器时使用特殊的 MMU, 即**IOMMU**, 进行**虚实地址转换**, 然后再访问存储器. 在这个 I0MMU 中, 同样存在 **IO 页表**存放虚实地址转换关系和访问权限, 而且处理器为了加速这种虚实地址的转换, 还设置了 **IOTLB** 作为 **IO 页表**的 Cache. 单纯从这个角度来看, 许多 HOST 主桥和 RC 也具备同样的功能, 如 PowerPC 处理器的 Inbound 窗口和 Out-bound 窗口, 也可以完成这种特殊的地址转换. 但是这些窗口仅能完成 PCI 总线域到一个存储器域的地址转换, 无法实现 PCI 总线域到多个存储器域的转换.

目前设置 IOMMU 的主要作用是**支持虚拟化技术**, 当然使用 IOMMU 也可以实现其他功能, 如使 "仅支持 32 位地址的 PCI 设备" 访问 4GB 以上的存储器空间. IA 处理器和 AMD 处理器分别使用 "`VT-d`" 和 "`I0MMU`", 实现外部设备的地址转换. 这两种技术都可以将 PCI 总线域地址空间转换为不同的存储器域地址空间, 便于虚拟化技术的设计与实现.

# IOMMU 的工作原理

根据虚拟化的理论, 假设在一个处理器系统中存在两个 Domain, 其中一个为 Domain1, 而另一个为 Domain2. 这两个 Domain 分别对应不同的虚拟机, 并使用独立的物理地址空间, 分别为 GPA1(Guest Physical Address) 和 GPA2 空间, 其中在 Domain1 上运行的所有进程使用 GPA1 空间, 而在 Domain2 上运行的所有进程使用 GPA2 空间.

GPA1 和 GPA2 采用独立的编码格式, 其地址都可以从各自 GPA 空间的 0x00000000 地址开始, 只是 GPA1 和 GPA2 空间在 System Memory 中占用的**实际物理地址** HPA(Host Physi-cal Address) 并不相同, HPA 也被称为 **MPA**(Machine Physical Address), 是处理器系统中真实的物理地址. 而 PCI 设备依然使用 PCI 总线域地址空间, PCI 总线地址需要通过 DMA-Remapping 逻辑转换为 HPA 地址后, 才能访问存储器. DMA-Remapping 逻辑的组成结构如图 13-1 所示.

![2022-05-04-22-33-21.png](./images/2022-05-04-22-33-21.png)


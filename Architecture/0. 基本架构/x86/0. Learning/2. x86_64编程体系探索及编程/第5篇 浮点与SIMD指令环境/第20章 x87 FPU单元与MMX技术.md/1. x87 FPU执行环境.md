
# x87 FPU的资源

为了支持浮点指令的执行, 在处理器内的x87 FPU提供了下面的硬件物理资源.

1) 8个 data register(浮点数据寄存器)​: R0 ~ R7 寄存器.

2) status register(状态寄存器)​.

3) control register(控制寄存器)​.

4) tag word register(标记字寄存器)​.

5) last instruction pointer register(最后一条指令指针寄存器)​: 其中包括 CS selector 部分.

6) last data operand pointer register(最后的 data 操作数指针寄存器)​: 包括 DS selector 部分.

7) opcode register(opcode 寄存器)​.

加入了两种浮点异常处理模式: native 模式和 DOS compatibility 模式. native 模式使用 16 号中断 vector(#MF 异常 vector)​. 而 DOS compatibility 模式使用外部的 8259 类 PIC(中断控制器)的中断请求方式来处理浮点异常.

## x87 FPU的操作 Environment(环境)信息

在 x87 FPU 中区分两大类信息: environment(环境)信息和 data 寄存器信息, 如下表所示.

![2024-09-03-10-09-15.png](./images/2024-09-03-10-09-15.png)

由 8 个 data register 组成的 FPU stack 信息区别于 environment 信息.

## x87 FPU指令支持的数据类型

x87 FPU 的指令支持下面 5 大类数据类型.

1) single precision floating-point: 32 位的单精度浮点数.

2) double-precision floating-point: 64 位的双精度浮点数.

3) double extended-precision floating-point: 80 位的扩展双精度浮点数.

4) integer: 包括 16 位、32 位, 以及 64 位的整型数.

5) packed BCD 码: 80 位的压缩 BCD 码.

## x87 FPU提供的指令

包括下面 5 大类指令.

1) data transfer(数据传送类)指令: 包括一部分 load constant(加载常数)的指令.

2) arithmetic(运算类)指令: 包括基本和复杂的运算指令.

3) comparison(比较类)指令: 提供 FPU 的比较指令.

4) transcendental(卓越的)指令: 这是 Intel 认为独特的、卓越的指令. 可以归为 arithmetic 类.

5) control(控制类)指令: 对 x87 FPU 运行环境进行控制.

在控制类指令中, 部分指令包括 wait 和 non-wait 版本.

# x87 FPU 数据寄存器

x87 FPU 所使用的 data register 是 80 位宽, 如下所示.

![2024-09-03-10-09-23.png](./images/2024-09-03-10-09-23.png)

## 扩展双精度浮点数

在 x87 FPU 的底层使用 double extended-precison floating-point(扩展双精度浮点数)格式, 我们从上图可以看到, 扩展双精度浮点数的 significand(有效数)位是 64 位, 指数位是 15 位. 关于浮点数格式, 请参考 1.2.2 节的描述.

x87 FPU 会自动处理数据格式之间的问题.

1) 当从内存中 load 数据时, 内存中的非扩展双精度数据会自动转换为扩展双精度格式, 再放入 x87 FPU stack 顶寄存器 st(0)中.

2) 当将 stack 顶寄存器 st(0)的值 store 到内存时, 扩展双精度格式会自动转换为相应的目标数据格式.

# x87 FPU 的 stack 结构

x87 FPU 浮点指令的执行基于由这 8 个 data register(R0 ~ R7 寄存器)组成的寄存器 stack 结构. x87 FPU 寄存器 stack 的操作和维护与内存中的 stack 结构类似, 如下所示.

![2024-09-03-10-09-33.png](./images/2024-09-03-10-09-33.png)

与内存 stack 不同的是, x87 FPU 寄存器 stack 以环形结构组织, 当 stack 顶位于物理 R0 寄存器时, 下一个 load 操作会使 stack 顶指针回绕到 R7 寄存器.

## Stack 顶指针

x87 FPU 寄存器 stack 顶指针名字永远都是 ST(0)​, ST(0)指针哪个物理 data 寄存器由 status 寄存器的 TOP 域(bit 13 ~ bit 11)反映出来, 如下所示.

![2024-09-03-10-09-38.png](./images/2024-09-03-10-09-38.png)

如上所示, 3 个位的 TOP 指针的值从 000B 到 111B, 允许 ST(0)指针指向 R0 ~ R7 寄存器.

在 x87 FPU 寄存器 stack 结构图中, TOP 的值为 3(011B)​, 那么 ST(0)指向 R3 寄存器, 接下来 ST(1)指向 R4 寄存器, ST(7)指向 R2 寄存器.

x87 FPU 寄存器 stack 也是向下生长. 以当前 ST(0)指向 R3 寄存器为例. 当执行 load 指令操作时(即 push 操作)​, TOP 值减 1(值为 010B)​, 那么 ST(0)将指向 R2 寄存器.

若执行 store-and-pop 类指令操作(即 pop 操作)​, ST(0)的值将被 store 到内存中, TOP 值加 1(值为 100B)​, ST(0)指向 R4 寄存器.

## Stack 的溢出

由于 x87 FPU 的 stack 由 8 个数据寄存器以环形结构组成, stack 很容易达到溢出状态. stack 的溢出包括下列类型.

1) stack overflow(栈向上溢出)​.

2) stack underflow(栈向下溢出)​.

当 load 一个数据到 stack 中(push 操作)时, 如果新的 ST(0)指针不为空, 将会产生 overflow 溢出, x87 FPU 会指示为 stack overflow 异常发生. 当使用空的 stack 寄存器时(例如 pop 操作)​, 将会产生 underflow 溢出, x87 FPU 会指示为 stack underflow 异常发生.

因此, 当 stack 中的数据不需要时, 应该主动 POP 出避免发生 overflow 溢出, 需要引用 stack 数据时要确保不为空值.

## 浮点数据寄存器值的状态

在 x87 FPU 中为每个 data 寄存器保存的值定义了一些状态值.

1) Valid(值有效)​.

2) Zero(值为 0)​.

3) Speical(特殊的值)​, 包括: invalid(无效的值, NaN 和 unsupported 类型)​, infinity(无穷大)和 denormal(不合规格的)​.

4) Empty(值为空)

这些 data 寄存器值的状态由 Tag 寄存器指示, 如下所示.

![2024-09-03-10-30-53.png](./images/2024-09-03-10-30-53.png)

16 位的 Tag 寄存器每 2 位对应一个物理的 data 寄存器. 00B 值为 Valid 状态, 01B 值为 Zero 状态, 10B 值为 Special 状态, 11B 值为 Empty 状态.

### Tag 寄存器初始值

在处理器 Power-up 或 Reset 后, Tag 寄存器的值为 5555H, 指示各个 data 寄存器为 0. 软件执行 FINIT 或 FNINIT 指令将 Tag 寄存器置为 FFFFH 值, 指示各个 data 寄存器为 Empty. 软件使用 FSAVE 或 FNSAVE 指令保存 x87 FPU 状态的同时, 也能将 Tag 寄存器置为 FFFFH 值.

### 读 Tag 寄存器值

在 x87 FPU 中并没有指令直接对 Tag 寄存器进行读/写操作, 需要通过内存 image 的 load/store 操作数来达到读/写 Tag 寄存器的目的, 如以下代码所示.

```cpp
fstenv [x87env32]    ;store x87 FPU environment 信息
mov ax, [x87env32 + 8]   ;读 Tag 寄存器值
```

可以使用 FSTENV/FNSTENV 或 FSAVE/FNSAVE 指令将 x87 FPU 的环境信息保存在内存映像中, 然后从内存映像中读取 Tag 寄存器值.

![2024-09-03-10-30-45.png](./images/2024-09-03-10-30-45.png)

上面是运行在 Bochs 中的结果图, 打印出的 tag 寄存器值为 5555H.

### 修改 Tag 寄存器值

软件可以使用 FLDENV 或 FRSTOR 指令从内存 image 中加载值到 Tag 寄存器, 如以下代码所示.

```cpp
mov WORD [x87env32 + 8], 0xFFFF  ;置内存 image 中的 Tag 寄存器值
fldenv [x87env32]      ;从内存 image 中加载 environment 信息
```

上面的代码将内存 image 中的 Tag 寄存器值设置为 FFFFH, 在加载环境信息时, x87 FPU 将使用这个值设置 Tag 寄存器.

可是, 并不是内存 image 中 tag 寄存器的任何值在 load 的时候 x87FPU 都会接受, 有下面的逻辑处理手法.

```cpp
/*
* 假如内存 image 中 tag 寄存器相应的 tag 值为 3 时
* 指示: Empty 状态
*/
if (x87env.tag[0] == 3)  /* 对应 R0 寄存器 */
{
    tag[0]=3;    /* 加载后就为 3 */
}
else
{
    /* 读 R0 寄存器的值, 检查并设置相应状态 */
    tag[0]=tag_of(R0);
}
if (x87env.tag[1] == 3)  /* 对应 R1 寄存器*/
{
    tag[1]=3;
}
else
{
    tag[1]=tag_of(R1);
}
... ...        /* 依此类推 */
```

从上面我们可以看到:

1) 内存 image 中的相应的 tag 值为 3 时, 加载后 tag 寄存器的相应值就为 3.

2) 若非 3 值(即非 Empty 状态)​, x87 FPU 会根据相应的 data 寄存器值而设置相应的状态.

假如, 像下面的代码这样设置值.

```cpp
mov WORD [x87env32 + 8], 0xFF00  ; tag[0]到tag[3]为0(valid状态)
fldenv [x87env32]      ; 从内存 image 中加载 environment 信息
```

tag[0] 到 tag[3] 的值为 0(即指示为 valid 状态)​, 加载后的 tag 寄存器可能并不是 0xff00 值, 有可能会是 0xff55 值(即 tag[0] 到 tag[3] 为 Zero 状态)​.

x87 FPU 的这个措施能有效地防止对 tag 寄存器设置错误的状态值.

## x87 FPU 寄存器 stack 的操作

在 x87 FPU 中, 并没有指令直接对物理的浮点 data 寄存器进行 load/store 操作, 这些 data 寄存器的 load/store 操作是基于对 x87FPU 寄存器 stack 的 TOP(栈顶)进行 push 与 pop 操作的基础之上.

当执行一条 load 指令时, TOP 指针值减 1, 源操作数压入 ST(0)寄存器中. x87 FPU 有三类指令对 data 寄存器进行 load 操作.

1) 提供源作数 load 进 ST(0)中.

2) load 一个浮点常数值到 ST(0)中.

3) 使用 FXCH 或 FCMOVcc(条件传送)类指令进行 ST(0)和 ST(i)交换.

x87 FPU 使用 FST 类指令将 ST(0)值 store 往内存中, 并可以选择是否从 stack 中 POP 出 ST(0)值.

### Load 指令

x87 FPU 的 load 指令支持三种数据类型: 浮点类型(包括单精度, 双精度和扩展双精度)​, 整数类型, 以及 BCD 数据类型(packed integer)​. 这些数据在 load 进 stack 寄存器时, x87 FPU 会自动将其转换为 80 位的扩展双精度浮点数.

load 操作根据数据类型产生不同的指令形式.

1) FLD 指令: load 浮点数.

2) FILD 指令: load 整数.

3) FBLD 指令: load BCD 数据.

FLD 指令支持两种操作数: 内存操作和 stack 寄存器形式, 如以下指令所示.

```cpp
fld DWORD [memfp32]  ; 32 位的内存 operand size 加载到 ST(0)里
fld QWORD [memfp64]  ; 64 位的内存 operand size 加载到 ST(0)里
fld TWORD [memfp80]  ; 80 位的内存 operand size 加载到 ST(0)里
fld st2      ; 使用 stack 寄存器操作数, ST(2) 加载到 ST(0)里
```

假如, 执行这条指令之前, TOP 值为 3, 即 ST(0)指向 R3 寄存器, 以 fld st2 指令的执行为例, 如下面示意图所示.

![2024-09-03-10-30-12.png](./images/2024-09-03-10-30-12.png)

原来的 ST(2)指向 R5 寄存器, x87 FPU 执行的操作如下.

1) ST(2)保存到 temp 值.

2) TOP 指针值减 1, 新的 TOP 指针将指向 R2 寄存器.

3) temp 值写入 ST(0)中.

这条指令的结果是, 将 R5 寄存器的值写入 R2 寄存器. 当执行 fld st0 指令时, 它的效果将等于复制 ST(0)的值.

注意: stack 寄存器的位置也会随着变化, ST(7)将指向 R1 寄存器, 而 ST(1)将指向 R3 寄存器. 也就是这个环形的 stack 整体向下移动一位.

FILD 指令从内存中 load 整数值到 ST(0)中, operand size 可以是 16 位、32 位, 以及 64 位. 这个整数值会自动转换为 80 位的扩展双精度浮点数.

```cpp
fild DWORD [memint32]   ; [memint32] 的值为 2
```

如以上代码所示, 内存操作数的值为整数 2, 当执行这条指令时, 当前 ST(0)的值将是 2.0. 在 ST(0)的十六进制值是 0x4000_80000000_00000000(80 位宽).

如以上代码所示, 内存操作数的值为整数 2, 当执行这条指令时, 当前 ST(0)的值将是 2.0. 在 ST(0)的十六进制值是 0x4000_80000000_00000000(80 位宽).

FBLD 指令将 packed BCD(压缩的 BCD 码)数据从内存 load 到 ST(0)中, FBLD 指令的内存操作数是 80 位, 如下面代码所示.

```
fbld [membcd]   ; 80 位的 BCD 转换为扩展双精度 load 进 ST(0)
; 假设内存中的 BCD 码为 10
membcd dq 10H    ; packed BCD 码 10
           dw 0     ; 80 位宽
```

当执行 FBLD 指令后, 当前的 ST(0)值将是 10.0(浮点数), 在 ST(0)的十六进制值是 0x4002_A0000000_00000000(80 位宽).

### Load 常数值

x87 FPU 中有一组常数的 load 指令.

1) FLDZ 指令: 加载 0.0 值到 ST(0).

2) FLD1 指令: 加载 1.0 值到 ST(0).

3) FLDPI 指令: 加载 Pi 值到 ST(0).

4) FLDL2T 指令: 加载 log2(10) 到 ST(0).

5) FLDL2E 指令: 加载 log2(e) 到 ST(0).

6) FLDLG2 指令: 加载 log10(2) 到 ST(0).

7) FLDLN2 指令: 加载 loge(2) 到 ST(0).

### Store 指令

与 load 指令相对应, 当 x87 FPU 执行 store 指令时, x87 FPU 会自动将 80 位宽的扩展双精度转换为目标操作数的类型(包括: 相应宽度的浮点型数据, 整型数据, 以及 80 位的 packed BCD 码数据)后, 保存在内存中.

x87 FPU 的 store 指令支持两种操作模式.

1) store 模式: 仅 ST(0)值 store 在内存中. 对应的指令有 FST 和 FIST, 支持浮点数和整型数.

2) store-and-pop 模式: ST(0)值 store 在内存中, 同时 POP 出寄存器 stack. 对应的指令有 FSTP、FISTP, 以及 FBSTP, 将支持浮点数、整型数, 以及 packed BCD 数.

FSTP 的规格对应于 FLD 指令, 操作数支持 stack 寄存器和内存操作数.

```markdown
fstp DWORD [mem]    ; store 内存 32 位浮点格式, 并 POP 栈
fstp QWORD [mem]    ; store 内存 64 位浮点格式, 并 POP 栈
fstp TWORD [mem]    ; store 内存 80 位浮点格式, 并 POP 栈
fstp st2      ; ST(0) 复制到 ST(2), 并 pop 栈
```

在 store-and-pop 操作中, ST(0)寄存器的值保存在内存中. 以 fstp DWORD [mem] 指令为例, 它执行的操作如下所示.




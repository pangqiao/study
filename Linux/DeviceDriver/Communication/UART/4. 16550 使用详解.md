
# 基本概念

16550 uart 是一个 legacy device, 通过 port I/O 驱动.

## 波特率和分频器值

计算 16550 UART 的波特率涉及几个关键步骤，‌包括设置波特率除数寄存器（‌低字节和高字节）‌以及理解波特率与分频系数的关系。

理解波特率的概念：‌波特率，‌即数据位率，‌是单位时间内传送的二进制数据的位数，‌以位/秒（‌b/s）‌表示。‌它表示了数据传输的速度。‌

1. 设置波特率除数寄存器：‌16550 UART 通过**两个 8 位**的波特率除数寄存器（‌一个低字节 DLL 和一个高字节 DLH）‌来设置波特率。‌这两个寄存器共同决定了波特率值。‌写入这两个寄存器的值将直接影响数据的传输速率。‌

16550 UART的分频器值（Divisor Latch Value）用于设置UART的波特率。分频器值是一个整数，它决定了UART内部波特率发生器的分频比例。计算分频器值的公式如下：

```
波特率 = 时钟频率 / (分频器的值 * 16)

分频器的值 = 时钟频率 / (波特率 * 16)
```

这里的16是因为16550 UART使用 16 倍过采样技术来检测接收到的信号。时钟频率是UART的输入时钟，波特率是你希望设置的通信速率。

例如，如果UART的时钟频率是1.8432 MHz（这是一个常用的频率，因为它可以方便地分频得到标准波特率），并且你想要设置波特率为9600，那么分频器值计算如下：

```
分频器值 = 1,843,200 / (9600 × 16)
分频器值 = 1,843,200 / 153,600
分频器值 = 12
```

因此，你需要将分频器设置为12来得到9600波特的通信速率。

在实际应用中，你需要通过编程方式将计算出的分频器值写入到UART的分频器锁存寄存器（Divisor Latch Registers）中。这通常涉及到设置UART的线路控制寄存器（Line Control Register）来启用对分频器锁存寄存器的访问，然后写入**高位**和**低位**分频器值。

```cpp
    uint16_t divisor = UART_CLOCK_FREQ / (16 * baud_rate);
    vuart->dll = divisor & 0xFF; // 低字节
    vuart->dlh = (divisor >> 8) & 0xFF; // 高字节
```

## 虚拟化

根据附件的 datasheet 中 Registers reset 值进行初始设置

# 配置步骤

配置 16550 模式的一般步骤:

1) 指定异步数据通信交换的格式

例如: 写入线控制寄存器来设置数据位(5、6、7或8)、打开奇偶校验并选择偶校验或奇校验、设置传输的停止位数.

通过编程线控制寄存器(Line Control Register, LCR)来设置除数锁存访问位(Divisor latch access bit).

2) 激活中断

向中断使能寄存器(Interrupt Enable register)写入值, 以允许特定的中断条件(如数据接收、发送缓冲区空等)生成中断.

3) 配置FIFO

写FIFO控制寄存器(FIFO Control register)以启用FIFOs、清除FIFOs和设置接收FIFO(RCVR FIFO)的触发级别.

4) 设置UART波特率

写除数锁存(Divisor Latch), 首先写入最低有效字节, 然后写入最高有效字节, 以正确设置UART的波特率.

5) 处理中断

当 UART 16550 触发中断时, 您的软件必须读取相关的寄存器(如接收缓冲区寄存器), 处理数据, 并清除中断标志.

# 16550 模式下的编程序列

## 设置目标

波特率: 56kbps

系统时钟: 100Mhz

使能 FIFO 接收缓冲区FIFO

异步数据传输格式: 8数据位(data bits)、偶校验(Even parity)和2停止位(stop bits)

## 设置流程

1) 写 `0x0000_0080` 到**线控制寄存器**(LCR)

设置 DLAB(Divisor Latch Access Bit)位为1, 允许写入 Divisor Latch 的值.

```cpp
//假设UART的LCR寄存器地址是0x<some_address>

uint16_t lcr_value = 0x0080; // 设置DLAB位为1

write_to_register(0x<some_address> , lcr_value); // 写入线控制寄存器
```

2) 写 `Divisor Latch` 以配置波特率

根据计算出的**分频值**设置 Divisor Latch 的**最低有效字节**(LSB)和**最高有效字节**(MSB). 分频器的值是通过时钟频率和期望的波特率计算得出的.

```
divisor = (CLK frequency/(16 × Baud Rate))
```

```cpp
// 假设UART的 Divisor Latch LSB和MSB的地址分别是0x<lsb_address>和0x<msb_address>
uint8_t divisor_lsb = 0x6F; // 分频器锁存器最低有效字节
uint8_t divisor_msb = 0x00; // 分频器锁存器最高有效字节(对于56 Kbps, 可能不需要这个字节, 取决于UART的具体实现)

write_to_register(0x<lsb_address>, divisor_lsb); // 写入分频器锁存器最低有效字节
write_to_register(0x<msb_address>, divisor_msb); // 写入分频器锁存器最高有效字节(如果需要的话)
```

注: lsb 就是 dll, msb 就是 dlh

3) 写 `0x0000_001F` 到**线控制寄存器**以设置数据格式

```cpp
// 重新设置线控制寄存器
uint16_t new_lcr_value = 0x001F; // 8数据位, 2停止位, 偶校验, DLAB=0
write_to_register(0x<some_address>, new_lcr_value); // 写入新的线控制寄存器值
```

4) 启用中断

```cpp
// 假设中断使能寄存器的地址是0x<ier_address>
uint8_t ier_value = 0x11; // 启用THRE(Transmitter Holding Register Empty)和RDA(Receive Data Available)中断
write_to_register(0x<ier_address>, ier_value); // 写入中断使能寄存器
```

5) 通过中断进行数据传输和接收

* 当THRE中断触发时, 意味着发送缓冲区为空, 可以写入新的数据到发送保持寄存器(Transmitter Holding Register).
* 当RDA中断触发时, 意味着接收缓冲区有新的数据可读, 可以从接收缓冲区寄存器(Receiver Buffer Register)中读取数据.

# 使用外部时钟时 16550 模式下的编程序列

## 设置目标

波特率: 56kbps

系统时钟: 100Mhz

外部xin时钟: 1.8432 MHz

使能 FIFO 接收缓冲区FIFO

异步数据传输格式: 8数据位(data bits)、偶校验(Even parity)和2停止位(stop bits)

## 设置流程

1) 写0x0000_0080到线控制寄存器

设置 DLAB(Divisor Latch Access Bit)位为 1, 允许写入 Divisor Latch 的值.

```
//假设UART的LCR寄存器地址是0x<some_address>
uint16_t lcr_value = 0x0080; // 设置DLAB位为1

write_to_register(0x<some_address> , lcr_value); // 写入线控制寄存器
```

2) 写Divisor Latch以配置波特率

根据计算出的分频值设置Divisor Latch的最低有效字节(LSB)和最高有效字节(MSB). 分频器的值是通过AXI时钟频率和期望的波特率计算得出的.

```
divisor = (AXI CLK frequency/(16 × Baud Rate))
```

```cpp
// 假设UART的 Divisor Latch LSB和MSB的地址分别是0x<lsb_address>和0x<msb_address>
uint8_t divisor_lsb = 0x02; // 分频器锁存器最低有效字节
uint8_t divisor_msb = 0x00; // 分频器锁存器最高有效字节(对于56 Kbps, 可能不需要这个字节, 取决于UART的具体实现)

write_to_register(0x<lsb_address>, divisor_lsb); // 写入分频器锁存器最低有效字节
write_to_register(0x<msb_address>, divisor_msb); // 写入分频器锁存器最高有效字节(如果需要的话)
```

3) 写0x0000_001F到线控制寄存器以设置数据格式

```cpp
// 重新设置线控制寄存器
uint16_t new_lcr_value = 0x001F; // 8数据位, 2停止位, 偶校验, DLAB=0
write_to_register(0x<some_address>, new_lcr_value); // 写入新的线控制寄存器值
```

4) 启用中断

```cpp
// 假设中断使能寄存器的地址是0x<ier_address>
uint8_t ier_value = 0x11; // 启用THRE(Transmitter Holding Register Empty)和RDA(Receive Data Available)中断
write_to_register(0x<ier_address>, ier_value); // 写入中断使能寄存器
```

5) 通过中断进行数据传输和接收

* 当 THRE 中断触发时, 意味着发送缓冲区为空, 可以写入新的数据到发送保持寄存器(Transmitter Holding Register).

* 当 RDA 中断触发时, 意味着接收缓冲区有新的数据可读, 可以从接收缓冲区寄存器(Receiver Buffer Register)中读取数据.

# 虚拟化支持

`kvmtool/hw/serial.c`

# reference

https://blog.csdn.net/u011565038/article/details/138845991

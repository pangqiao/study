
配置 16550 模式的一般步骤:

1) 指定异步数据通信交换的格式

例如: 写入线控制寄存器来设置数据位(5、6、7或8)、打开奇偶校验并选择偶校验或奇校验、设置传输的停止位数.

通过编程线控制寄存器(Line Control Register, LCR)来设置除数锁存访问位(Divisor latch access bit).

2) 激活中断

向中断使能寄存器(Interrupt Enable register)写入值, 以允许特定的中断条件(如数据接收、发送缓冲区空等)生成中断.

3) 配置FIFO

写FIFO控制寄存器(FIFO Control register)以启用FIFOs、清除FIFOs和设置接收FIFO(RCVR FIFO)的触发级别.

4) 设置UART波特率

写除数锁存(Divisor Latch), 首先写入最低有效字节, 然后写入最高有效字节, 以正确设置UART的波特率.

5) 处理中断

当 UART 16550 触发中断时, 您的软件必须读取相关的寄存器(如接收缓冲区寄存器), 处理数据, 并清除中断标志.

# 16550 模式下的编程序列

## 设置目标

波特率: 56kbps

系统时钟: 100Mhz

使能 FIFO 接收缓冲区FIFO

异步数据传输格式: 8数据位(data bits)、偶校验(Even parity)和2停止位(stop bits)

## 设置流程

1) 写 0x0000_0080 到线控制寄存器(LCR)

设置 DLAB(Divisor Latch Access Bit)位为1, 允许写入 Divisor Latch 的值.

```cpp
//假设UART的LCR寄存器地址是0x<some_address>

uint16_t lcr_value = 0x0080; // 设置DLAB位为1

write_to_register(0x<some_address> , lcr_value); // 写入线控制寄存器
```

2) 写 Divisor Latch 以配置波特率

根据计算出的**分频值**设置 Divisor Latch 的**最低有效字节**(LSB)和**最高有效字节**(MSB). 分频器的值是通过时钟频率和期望的波特率计算得出的.

```
divisor = (CLK frequency/(16 × Baud Rate))
```

```cpp
// 假设UART的 Divisor Latch LSB和MSB的地址分别是0x<lsb_address>和0x<msb_address>
uint8_t divisor_lsb = 0x6F; // 分频器锁存器最低有效字节
uint8_t divisor_msb = 0x00; // 分频器锁存器最高有效字节(对于56 Kbps, 可能不需要这个字节, 取决于UART的具体实现)

write_to_register(0x<lsb_address>, divisor_lsb); // 写入分频器锁存器最低有效字节
write_to_register(0x<msb_address>, divisor_msb); // 写入分频器锁存器最高有效字节(如果需要的话)
```

3) 写0x0000_001F到线控制寄存器以设置数据格式

```cpp
// 重新设置线控制寄存器
uint16_t new_lcr_value = 0x001F; // 8数据位, 2停止位, 偶校验, DLAB=0
write_to_register(0x<some_address>, new_lcr_value); // 写入新的线控制寄存器值
```

4) 启用中断

```cpp
// 假设中断使能寄存器的地址是0x<ier_address>
uint8_t ier_value = 0x11; // 启用THRE(Transmitter Holding Register Empty)和RDA(Receive Data Available)中断
write_to_register(0x<ier_address>, ier_value); // 写入中断使能寄存器
```

5) 通过中断进行数据传输和接收

* 当THRE中断触发时, 意味着发送缓冲区为空, 可以写入新的数据到发送保持寄存器(Transmitter Holding Register).
* 当RDA中断触发时, 意味着接收缓冲区有新的数据可读, 可以从接收缓冲区寄存器(Receiver Buffer Register)中读取数据.

# 使用外部时钟时 16550 模式下的编程序列

## 设置目标

波特率: 56kbps

系统时钟: 100Mhz

外部xin时钟: 1.8432 MHz

使能 FIFO 接收缓冲区FIFO

异步数据传输格式: 8数据位(data bits)、偶校验(Even parity)和2停止位(stop bits)

## 设置流程

1) 写0x0000_0080到线控制寄存器

设置 DLAB(Divisor Latch Access Bit)位为 1, 允许写入 Divisor Latch 的值.

```
//假设UART的LCR寄存器地址是0x<some_address>
uint16_t lcr_value = 0x0080; // 设置DLAB位为1

write_to_register(0x<some_address> , lcr_value); // 写入线控制寄存器
```

2) 写Divisor Latch以配置波特率

根据计算出的分频值设置Divisor Latch的最低有效字节(LSB)和最高有效字节(MSB). 分频器的值是通过AXI时钟频率和期望的波特率计算得出的.

```
divisor = (AXI CLK frequency/(16 × Baud Rate))
```

```cpp
// 假设UART的 Divisor Latch LSB和MSB的地址分别是0x<lsb_address>和0x<msb_address>
uint8_t divisor_lsb = 0x02; // 分频器锁存器最低有效字节
uint8_t divisor_msb = 0x00; // 分频器锁存器最高有效字节(对于56 Kbps, 可能不需要这个字节, 取决于UART的具体实现)

write_to_register(0x<lsb_address>, divisor_lsb); // 写入分频器锁存器最低有效字节
write_to_register(0x<msb_address>, divisor_msb); // 写入分频器锁存器最高有效字节(如果需要的话)
```

3) 写0x0000_001F到线控制寄存器以设置数据格式

```cpp
// 重新设置线控制寄存器
uint16_t new_lcr_value = 0x001F; // 8数据位, 2停止位, 偶校验, DLAB=0
write_to_register(0x<some_address>, new_lcr_value); // 写入新的线控制寄存器值
```

4) 启用中断

```cpp
// 假设中断使能寄存器的地址是0x<ier_address>
uint8_t ier_value = 0x11; // 启用THRE(Transmitter Holding Register Empty)和RDA(Receive Data Available)中断
write_to_register(0x<ier_address>, ier_value); // 写入中断使能寄存器
```

5) 通过中断进行数据传输和接收

* 当 THRE 中断触发时, 意味着发送缓冲区为空, 可以写入新的数据到发送保持寄存器(Transmitter Holding Register).

* 当 RDA 中断触发时, 意味着接收缓冲区有新的数据可读, 可以从接收缓冲区寄存器(Receiver Buffer Register)中读取数据.

# reference

https://blog.csdn.net/u011565038/article/details/138845991

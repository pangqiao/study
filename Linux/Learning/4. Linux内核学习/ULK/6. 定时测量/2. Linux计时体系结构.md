Linux必定执行与定时相关的操作. 

Linux的计时体系结构(timekeeping architecture)是一组与时间流相关的内核数据结构和函数. 实际上, 80x86多处理器机器所具有的计时体系结构与单处理器有所不同. 

- 单处理器系统, 所有计时活动由全局定时器(可编程间隔定时器或高精度事件定时器)产生的中断触发. 

- 多处理器系统, 所有普通活动(像软定时器的处理)都是由全局定时器产生的中断触发, 而具体的CPU活动(监控当前运行进程的执行时间)由本地APIC定时器产生的中断触发. 
 
Linux的计时体系结构还依赖于时间戳计数器(TSC)、ACPI电源管理定时器、高精度事件定时器(HPET)的可用性. 内核使用两个基本的计时函数: 一个保持当前最新的时间, 一个计算在当前秒内走过的纳秒数. 

## 计时体系结构的数据结构

### 定时器对象

为使用一种统一的方法来处理可能存在的定时器资源, 内核使用了”定时器对象", 它是timer_opts类型的一个描述符. 

### jiffies变量

jiffies变量是一个计数器, 用来记录自系统启动以来产生的节拍总数. 每次时钟中断发生(每个节拍)便加1. 

### xtime变量

存放当前时间和日期, 是一个timespace类型的数据结构.

xtime变量通常每个节拍更新一次. 用户程序从xtime变量获得当前时间和日期. 内核也经常引用它. 

## 单处理系统上的计时体系结构

单处理器系统上, 所有与定时器有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断出发. 同样, Linux中, 某些活动尽可能在中断产生后立即执行, 而其余的活动延迟. 

### 初始化阶段

内核初始化期间, time_init()来建立计时体系结构, 通常操作: 

(1) 初始化xtime变量

(2) 初始化wall_to_monotonic变量

(3) 如果内核支持HPET, 它将调用hpet_enable()函数来确认ACPI固件是否探测到了该芯片并将它的寄存器映射到内存地址空间中. 若是, hpet_enable()将对HPET芯片的第一个定时器编程使其以每秒1000次频率引发IRQ 0处的中断. 否则, 内核使用 PIT: 该芯片已经被init_IRQ()函数编程, 使得以每秒1000次的频率引发IRQ 0 处的中断. 

(4) 调用select_timer()来挑选系统中可利用的最好的定时器资源, 并设置cur_timer变量指向该定时器资源对应的定时器对象的地址

(5) 调用setup_irq(0, &irq0)来创建于IRQ0相应的中断门, IRQ0引脚连接着系统时钟中断源(PIT或HPET). irq0变量被静态定义如下: 

```
struct irqaction irq0 = {
    timer_interrupt, 
    SA_INTERRUPT, 
    0,
    "timer",
    NULL,
    NULL
}
```

从现在起, timer_interrupt()函数将会在每个节拍到来时被调用, 而中断被禁止, 因为IRQ0主描述符的状态字段中的SA_INTERRUPT标志被置位. 

### 时钟中断处理程序



<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [0 概述](#0-概述)
* [1 信号量](#1-信号量)
* [2 小结](#2-小结)

<!-- /code_chunk_output -->


思考如下小问题. 
- 与spinlock相比, 信号量有哪些特点？
- 请简述信号量是如何实现的. 

# 0 概述

**信号量(semaphore**)是操作系统中最常用的同步原语之一. **spinlock**是实现一种**忙等待的锁**, 而**信号量**则允许进程进入**睡眠状态**. 简单来说, **信号量**是一个**计数器**, 它支持**两个操作原语**, 即**P和V操作**. P和V是指荷兰语中的两个单词, 分别表示**减少和增加**, 后来美国人把它改成**down和up**, 现在Linux内核里也叫这两个名字. 

信号量中最经典的例子莫过于**生产者和消费者问题**, 它是一个操作系统发展历史上最经典的**进程同步问题**, 最早由Dijkstra提出. 假设**生产者生产商品**, **消费者购买商品**, 通常**消费者**需要到实体商店或者网上商城购买. 用计算机来模拟这个场景, **一个线程代表生产者**, 另外**一个线程代表消费者**, **内存buffer代表商店**. **生产者生产**的**商品**被放置到**buffer**中供**消费者线程消费**, 消费者线程从buffer中获取物品, 然后**释放buffer**. 

- 当**生**产者线程**生产商品时发现**没有空闲buffer**可用, 那么**生产者**必须等待消费者线程**释放出一个**空闲buffer**. 
- 当**消费者线程**购买商品时发现商店没货了, 那么**消费者必须等待**, 直到新的商品生产出来. 

如果是**spinlock**,当消费者发现商品没货, 那就搬个凳子坐在商店门口**一直等送货员送货过来(忙等待！！！**); 如果是**信号量**, 商店服务员会记录消费者的电话, 等**到货了通知消费者来购买(睡眠等待！！！**). 显然在现实生活中, 如果是面包等一类很快可以做好的商品, 大家愿意在商店里等, 如果是家电等商品大家肯定不会在商店里等. 

# 1 信号量

信号量数据结构定义如下: 

```c
[include/linux/semaphore.h]
struct semaphore{
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
```

- lock是**spinlock变量**, 用于对信号量数据结构里**count**和**wait\_list成员**的保护. 
- count用于表示**允许进入临界区**的**内核执行路径个数**. 
- wait\_list链表用于管理**所有在该信号量上睡眠的进程**, 没有成功获取锁的进程会睡眠在这个链表上. 

通常通过**sema\_init**()函数进行**信号量的初始化**, 其中\_\_**SEMAPHORE\_INITALIZER**()宏会完成对**信号量数据结构**的填充, val值通常**设定为1(也就是count初始为1！！！**). 

```c
[include/linux/semaphore.h]

static inline void sema_init(struct semaphore *sem, int val)
{
	static struct lock_class_key __key;
	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
	lockdep_init_map(&sem->lock.dep_map, "semaphore->lock", &__key, 0);
}

#define __SEMAPHORE_INITIALIZER(name, n)				\
{									\
	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\
	.count		= n,						\
	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\
}
```

下面来看down操作, **down()函数**有如下一些**变种**. 其中down()和**down\_interruptible**()的区别在于, down\_interruptible()在**争用信号量失败时**进入**可中断的睡眠状态**, 而down()进入**不可中断的睡眠状态**. down\_trylock()函数**返回0**表示成功**获取了锁**, 返回1表示**获取锁失败**. 

```c
void down(struct semaphore *sem);
int down_interruptible(struct semaphore *sem);
int down_kiliable(struct semaphore *sem);
int down_trylock(struct semaphore *sem);
int down_timeout(struct semaphore *sem, long jiffies);
```

接下来看down\_interruptible()函数的实现. 

```c
[kernel/locking/semaphore.c]
int down_interruptible(struct semaphore *sem)
{
	unsigned long flags;
	int result = 0;

	raw_spin_lock_irqsave(&sem->lock, flags);
	
	//位置1
	if (likely(sem->count > 0))
		sem->count--;
	else
		result = __down_interruptible(sem);
	
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return result;
}
EXPORT_SYMBOL(down_interruptible);
```

首先判断位置1代码是一个**临界区**, 注意后面的操作会**临时打开spinlock**, 涉及到对信号量中最重要的**count计数的操作**, 需要**spinlock锁来保护**, 并且在**某些中断处理函数**里也可能会**操作该信号量**, 所以需要**关闭本地CPU中断**, 因此这里采用**raw\_spin\_lock\_irqsave**()函数. 当**成功进入临界区**之后, 首先判断sem\->count是否大于0, 如果**大于0**, 则表明**当前进程可以成功地获得信号量**, 并**将sem\->count值减1**, 然后**退出**. 如果sem\->count**小于等于0**, 表明当前进程**无法获得该信号量**, 则调用\_\_down\_interruptible()函数来执行**睡眠等待操作**. 

```c
[kernel/locking/semaphore.c]
static noinline int __sched __down_interruptible(struct semaphore *sem)
{
	return __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
```

\_\_down\_interruptible()函数内部调用\_\_down\_common()函数来实现, **state参数为TASK\_INTERRUPTIBLE**, timeout参数MAX\_SCHEDULE\_TIMEOUT是一个**很大的值LONG\_MAX**.

```c
[down_interruptible() -> __down_interruptible() -> __down_common()]

[kernel/locking/semaphore.c]
static inline int __sched __down_common(struct semaphore *sem, long state,
								long timeout)
{
	struct task_struct *task = current;
	// 位置1
	struct semaphore_waiter waiter;

	list_add_tail(&waiter.list, &sem->wait_list);
	waiter.task = task;
	waiter.up = false;

	for (;;) {
		if (signal_pending_state(state, task))
			goto interrupted;
		if (unlikely(timeout <= 0))
			goto timed_out;
		__set_task_state(task, state);
		raw_spin_unlock_irq(&sem->lock);
		timeout = schedule_timeout(timeout);
		raw_spin_lock_irq(&sem->lock);
		if (waiter.up)
			return 0;
	}

 timed_out:
	list_del(&waiter.list);
	return -ETIME;

 interrupted:
	list_del(&waiter.list);
	return -EINTR;
}
```

位置1, **struct semaphore\_waiter waiter**数据结构用于描述**获取信号量失败的进程**, **每个进程**会有一个**semaphore\_waiter数据结构(！！！**), 并且把**当前进程**放到**信号量sem**的成员变量**wait\_list链表**中. 

接下来的**for循环**将**当前进程的task\_struct状态**设置成**TASKINTERRUPTIBLE**, 然后调用**schedule\_timeout()主动让出CPU**, 相当于**当前进程睡眠**. 注意schedule\_timeout()的参数是**MAX\_SCHEDULE\_TIMEOUT**, 它并**没有实际等待MAX\_SCHEDULE\_TIMEOUT的时间(！！！**). 当**进程再次被调度回来**执行时, **schedule\_timeout**()返回并**判断再次被调度的原因**, 例如**waiter.up为true**时, 说明睡眠在wait\_list队列中的进程**被该信号量的UP操作唤醒(！！！**), 进程**可以获得该信号量(！！！**). 如果进程是**被其他人发送信号(signal**)或者**超时等原因**引发的唤醒, 则跳转到**timed\_out或interrupted标签**处, 并**返回错误代码**. 

回看down\_interruptible()函数, 在调用\_\_down\_interruptible()时加了**sem\->lock的spinlock锁**, 这是**一个spinlock的临界区**. 前文中提到, spinlock临界区绝对**不能睡眠**, 难道这里是例外？仔细阅读\_\_down\_common()函数, 会发现**for循环**里在调用**schedule\_timeout()主动让出CPU时**, 先调用了raw\_spin\_unlock\_irq()**释放了该锁**, 也就是说**调用schedule\_timeout()函数时己经没有spinlock锁**了, 可以**让进程先睡眠, 醒来时再补加一把锁(！！！**), 这通常是内核编程的常用技巧. 

下面来看与down对应的**up操作函数**. 

```c
[kernel/locking/semaphore.c]
void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list)))
		sem->count++;
	else
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}
EXPORT_SYMBOL(up);
```

如果信号量上的**等待队列sem\->wait\_list为空**, 则说明**没有进程在等待该信号量**, 那么**直接把sem\->count加1**即可. 如果**不为空**, 说明**有进程在等待队列里睡眠**, 需要**调用\_\_up()函数叫醒**它们. 

```c
[kernel/locking/semaphore.c]
static noinline void __sched __up(struct semaphore *sem)
{
	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
						struct semaphore_waiter, list);
	list_del(&waiter->list);
	waiter->up = true;
	wake_up_process(waiter->task);
}
```

首先来看sem->wait\_list等待队列中第一个成员waiter, 这个**等待队列是先进先出队列**, 在**down操作**时通过list\_add\_tail()函数**添加到等待队列尾部**. waiter->up设置为**true**, 然后调用**wake\_up\_process**()函数**唤醒waiter->task进程**. 在**down()函数**中, waiter->task**进程醒来**后会判断waiter->up变量是否为true, 如果为true, 则**直接返回0**, 表示该进程成功**获取了信号量**. 

# 2 小结

信号量有一个有趣的特点, 它可以**同时允许任意数量的锁持有者(！！！取决于count值！！！**). **信号量初始化**函数为**sema\_init**(struct semaphore \*sem, int count), 其中count的值可以大于等于1. 当count大于1时, 表示允许在同一时刻至多有count个锁持有者, 操作系统书籍把这种信号量叫作**计数信号量(counting semaphore**); 当**count等于1**时, **同一时刻仅允许一个人持有锁**, 操作系统书籍把这种信号量称为**互斥信号量**或者**二进制信号量(Binary Semaphore**). 

在 Linux内核中, **大多使用count计数为1**的信号量. 相比spinlock, **信号量**是一个**允许睡眠的锁**. 信号量适用于一些**情况复杂**、**加锁时间比较长**的应用场景, 例如内核与用户空间复杂的交互行为等. 

信号量**允许进程进入睡眠状态(即睡眠等待**), 是计数器, 支持两个操作原语P(down)和V(up)

```c
struct semaphore{
    raw_spinlock_t		lock;       //对count和wait_list的保护
	unsigned int		count;      // 允许持锁数目
	struct list_head	wait_list;  // 没成功获锁的睡眠的进程链表
};
```

初始化: sema\_init()

获得锁:

- down(struct semaphore \*sem): 失败进入**不可中断的睡眠**状态
- down\_interruptible(struct semaphore \*sem): **失败**则进入**可中断的睡眠**状态. ①关闭**本地中断(防止中断来导致死锁**); ②count大于0, 当前进程获得semaphore, count减1, 退出; ③count小于等于0, 将**当前进程加入wait\_list链表**, 循环: 设置**进程TASKINTERRUPTIBLE**, 调用**schedule\_timeout()让出CPU<即睡眠**>, 判断被调度到的原因(**能走到这儿说明又被调度**到了), 如果waiter.up为true, 说明**被up操作唤醒**, 获得信号量,退出; ④打开本地中断
- 等等

释放锁:

up(struct semaphore \*sem): wait\_list为空, 说明没有进程等待信号量, count加1, 退出; wait\_list不为空, 等待队列是先进先出, 将第一个移出队列, 设置waiter.up为true, wake\_up\_process()唤醒waiter\-\>task进程

**睡眠等待, 任意数量的锁持有者**
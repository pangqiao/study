- 4.9 一个简单的多任务内核实例
    - 4.9.1 多任务程序结构和工作原理
    - 4.9.2 引导启动程序boot.s
    - 4.9.3 多任务内核程序head.s

该实例包含两个特权级3的用户任务和一个系统调用中断过程. 首先说明这个简单内核的基本结构和加载运行的基本原理, 然后描述是如何被加载进机器RAM内存中以及两个任务是如何进行切换运行的. 最后给出源码: 启动引导程序boot.s和保护模式多任务内核程序head.s. 

## 1. 多任务程序结构和工作原理

2个文件. 一个是使用as86语言编制的引导启动程序boot.s, 用于上电时从启动盘上把内核代码加载到内存中; 另一个是使用GNU as汇编编写的内核程序head.s, 其中实现了两个运行在特权级3上的任务在时钟中断控制下相互切换运行, 并且还实现了在屏幕上显示字符的一个系统调用. 这两个任务分别称为任务A和任务B, 它们会调用显示系统调用在屏幕上分别显示出字符‘A’和字符‘B’, 直到每个10毫秒切换到另一个任务. 若要终止该程序, 需要重启机器. 

boot.s编译出来的代码一共512字节, 会存放在可启动设备的第一个扇区, 如图. PC加电后, ROM BIOS会把启动盘第一个扇区加载到物理内存0x7c00(31KB)处, 并把执行权转移到0x7c00处开始运行boot程序代码. 

![可启动设备](images/34.png)

boot程序的主要功能是把head内核代码加载到内存某处, 并在设置好临时GDT表等信息后, 把处理器设置为运行在保护模式下, 然后跳转到head代码处去运行内核代码. 实际上, boot.s程序会首先利用ROM BIOS中断int 0x13把软盘中的head代码读入到内存0x10000(64KB)位置开始处, 然后把这段head代码移动到到内存0开始处. 最后设置控制器CR0中的开启保护运行模式标志, 并跳转到内存0处开始执行head代码. boot程序代码在内存中移动head代码的示意图如下. 

![kernel code](images/35.png)

把head代码移动到物理内存0开始处主要原因是为了设置GDT表可以简单点, 因而也能让head.s程序尽量短一些. 但是不能让boot程序把head代码从软盘或映像文件中直接加载到内存0处. 因为加载操作需要使用ROM BIOS提供的中断过程, 而BIOS使用的中断向量表正处于内存0开始的地方, 并且在内存1KB开始处是BIOS程序使用的数据区. 当然也可以把head代码加载到内存0x10000处就直接跳转到该处运行head代码, 使用这种方式的源码可从oldlinux.org下载, 见下面说明. 

head.s运行在32位保护模式下, 其中主要包括初始化设置的代码、时钟中断int 0x80的过程代码、系统调用中断int 0x80的过程代码和任务A和B的代码数据. 

其中初始化设置工作主要包括: 

1. 重新设置GDT表; 

2. 设置系统定时器芯片; 

3. 重新设置IDT表并设置时钟和系统调用中断; 

4. 移动到任务A中执行. 
 
在虚拟地址空间中head.s程序的内核代码和任务代码分配如图. 实际上, 该内核示例中所有代码和数据段都对应到物理内存同一个区域上, 即从物理内存0开始的区域. GDT中全局代码段和数据段描述符的内容都设置为: **基地址位0x0000; 段限长值0x07ff. 因为颗粒度为1(Granularity, 0表示单位是字节, 1表示单位是4KB), 所以实际段长度是8MB. 而全局显示数据段被设置为: 基地址0xb8000; 段限长值0x0002, 所以实际长度为8KB, 对应到显示内存区域. **(??????)

内核和任务在虚拟地址空间中的分配示意图: 

![virtual address](images/36.png)

两个任务在LDT中代码段和数据段描述符的内容也都设置为基地址0x0000; 段限长0x3ff, 实际段长度为4MB. 因此在线性地址空间中这个"内核"的代码和数据段与任务的代码和数据段都从线性地址0开始并且由于没有采用分页机制, 所以直接对应物理地址0开始. 在head编译出的目标文件中以及最终得到的映像文件中, 代码和数据的组织形式见图: 

![数据代码分布](images/37.png)

由于处于特权级0的代码不能把控制权转移到特权级3的代码中执行, 但中断返回操作是可以的, 因此当初始化GDT、IDT和定时芯片结束后, 利用中断返回指令IRET来启动运行第一个任务. 具体实现方法是在初始堆栈init\_stack中人为设置一个返回环境. 即把任务0的TSS段选择符加载到任务寄存器LTR、LDT段选择符加载到LDTR中以后, 把任务0的用户栈指针(0x17:init\_stack)和代码指针(0x0f:task0)以及标志寄存器值压栈, 然后执行中断返回指令IRET. 该指令会弹出堆栈上的堆栈指针作为任务0的用户栈指针, 恢复假设的任务0的标志寄存器内容, 并且弹出栈中代码指针放入CS:EIP寄存器中, 从而开始执行任务0的代码, 完成了从特权级0的到特权级3代码的控制转移. 

为每隔10毫秒切换运行的任务, head.s程序中把定时器芯片8253的通道0设置成每经过10毫秒就向中断控制芯片8259A发送一个时钟中断请求信号. PC的ROM BIOS开机时已经在8259A中把时钟中断请求信号设置成中断向量8, 因此需要在中断8的处理过程中执行任务切换操作. 任务切换实现是查看current变量中的当前运行任务号. 若current是0, 就利用任务1的TSS选择符作为操作数执行远跳转指令, 从而切换到任务1中执行, 否则反之. 

每个任务执行时, 会首先将一个字符的ASCII码放入寄存器AL中, 然后调用系统中断调用int 0x80, 而该系统调用处理过程则会调用一个简单的字符写屏程序, 把寄存器AL中字符显示在屏幕上, 同时把字符显示的屏幕下一个位置记录下来, 作为下一个显示字符的屏幕位置. 在显示过一个字符后, 任务代码会使用循环语句延迟一段时间, 然后又跳转到任务代码开始处循环执行, 直到运行了10毫秒而发生定时中断, 从而代码会切换到另一个任务. 对于任务A, 寄存器AL中始终存放字符"A", 而任务B运行时AL中始终存放字符"B". 效果如下图. 

![screen](images/38.png)

图中最下面一行有个字符"C", 这是因为PC机偶然产生了一个不是时钟中断和系统调用中断的其他中断. 因为我们在程序中给所有其他中断安装了一个默认中断处理程序. 当出现一个其他中断, 便会运行, 然后退出中断. 

## 2. 引导启动程序boot.s

为了让程序简单, 这个引导启动扇区程序仅能加载长度不超过16个扇区的head代码, 并且直接使用了ROM BIOS默认设置的中断向量号, 即定时中断请求处理的中断号仍是8. 这与Linux系统中使用的是不同的. Linux会在内核初始化时重新设置8259A中断控制芯片, 并把时钟中断请求信号对应到中断0x20上, 详细见"内核引导启动程序"章节. 

该文件的详细注释见代码. 

## 3. 多任务内核head.s

进入保护模式后, head.s重新设置了IDT、GDT表, 为了与后面Linux 0.12源码设置一致. 

该文件的详细注释见代码. 
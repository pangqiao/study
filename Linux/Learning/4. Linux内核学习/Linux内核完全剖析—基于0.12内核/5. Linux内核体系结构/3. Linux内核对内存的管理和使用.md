先说明Linux 0.12中比较直观的物理内存使用情况，然后结合Linux 0.12内核中应用情况，再分别概述内存的分段和分页机制以及CPU多任务操作和保护方式. 最后综合说明Linux 0.12中内核代码和数据以及各个任务的代码和数据在虚拟地址、线性地址和物理地址之间的对应关系. 

## 1. 物理内存

Linux 0.12中，为有效使用机器中的物理内存，在系统初始化阶段内存被分为几个功能区域，见图5-5. 

![config](images/4.png)

其中，Linux内核程序占据物理内存最开始部分，接下来是硬盘或软盘等快设备使用的高速缓冲区(其中要扣除显卡内存和ROM BIOS占据的内存范围640KB~1MB). 

当一个进程需要读取块设备中的数据时，系统会首先将数据读到高速缓冲区；当有数据需要写到块设备上时，系统也是先将数据写到高速缓冲区中，然后由块设备驱动程序写入到相应的设备上. 

对于含有RAM虚拟盘的系统，主内存区头部还要划去一部分，供虚拟盘存放数据. 

最后部分是可供所有程序使用的主内存区. 

Linux同时采用了内存分段和分页管理机制. 

## 2. 内存地址空间概念

Linux 0.12内核中，进行地址映射操作时，需要首先分清3种地址以及之间的变换概念: 程序(进程)的虚拟和逻辑地址、CPU的线性地址、实际物理内存地址. 

虚拟地址(Virtual Address)由程序产生的由段选择符和段内偏移地址两部分组成. 虚拟地址空间由GDT映射的全局地址空间和由LDT映射的局部地址空间组成. 最大虚拟地址空间有64TB. 

逻辑地址(Logical Address)指由程序产生的与段相关的偏移地址部分. 保护模式下即代码段或数据段的限长内的偏移地址. 应用程序仅需与逻辑地址打交道，而分段和分页机制对其是完全透明的. 有些资料不区分逻辑地址和虚拟地址，统称为逻辑地址. 

线性地址(Linear Address)是虚拟地址到物理地址变换中间层. 程序代码产生逻辑地址，或者说段中的逻辑地址，加上相应段的基地址，构成线性地址. Intel 80386的线性地址空间容量是4GB. 

物理地址(Physical Address)是出现在CPU外部地址总线桑的寻址物理内存的地址信号. 

虚拟存储(虚拟内存)(Virtual Memory)是指计算机呈现出来的要比实际拥有的内存大得多的内存量. **在Linux 0.12内核中，给每个程序(进程)都划分了总容量为64MB的虚拟内存空间**. 因此程序的逻辑地址范围是0x0000000到0x4000000. 

## 3. 内存分段机制

一个程序的逻辑地址通过分段机制自动地映射(变换)到中间层地4GB(2\^32)线性地址空间中. **程序每次对内存的引用都是对内存段中内存的引用**. 整体变换过程如下: 

![config](images/5.png)

CPU进行地址转换主要目的是为了解决虚拟内存空间到物理内存空间的映射问题。通常虚拟内存空间要比实际物理内存量大得多。

虚拟内存管理怎么实现的？首先，当一个程序需要使用一块不存在的内存时(即在内存页表项中已标出相应内存页面不在内存中)，CPU就需要一种方法来得知这种情况。通过80386的页错误异常中断来实现。当一个进程引用一个不存在页面中的地址时，就会触发CPU产生页出错异常中断，并**把引起中断的线性地址放到CR2控制寄存器中**。因此处理器中断的过程就知道发生页异常的确切地址，此时可以把进程要求的页面从二级存储空间(如硬盘)加载到物理内存中。如果此时物理内存已经被全部占用，那么可以借助二级存储空间的一部分作为交换缓冲区(Swapper)把内存中暂时不使用的页面交换到二级缓冲区中，然后把要求的页面调入内存中。这就是内存管理的**缺页加载机制**，在Linux 0.12内核中在mm/memory.c中实现。

Intel使用段(Segment)来对程序进行寻址。每个段定义了内存中的某个区域以及访问的优先级等信息。见下图。

![config](images/6.png)

保存描述符项的描述符表有三种。

**全局描述符表GDT**(Global Descriptor Table)可被所有程序用于引用访问一个内存段。

**中断描述符表IDT**(Intertupt Descriptor Table)保存定义中断或异常处理过程的段描述符。IDT表直接代替了8086(实模式)中的中断向量表(IVT)。

为了在8086保护模式下运行，必须为CPU定义一个GDT表和一个IDT表。

**局部描述符表LDT**(Local Descriptor Table)用于多任务系统，通常每个任务一个LDT表。

为了让CPU能定位GDT表、IDT表和当前的LDT表，需要为CPU分别设置GDTR、IDTR和LDTR寄存器。

每个程序都可由若干个内存段组成。程序的逻辑地址(虚拟地址)即是用于寻址这些段和段中具体地址位置。Linux 0.12中，程序逻辑地址到线性地址的变换使用了GDT和LDT。由GDT映射的地址空间称为全局地址空间，由LDT映射的地址空间称为局部地址空间，这两部分构成虚拟地址空间。使用方法如下。

![config](images/7.png)

图中画出了有两个任务时候的情况。

可看出，每个任务的LDT本身也是由GDT中描述符定义的一个内存段，在该段中存放着对应的代码段和数据段描述符，因此LDT段很短，其段限长通常只要24字节即可。

同样，每个任务的任务状态段TSS也是由GDT中描述符定义的一个内存段。、，其限长也只要满足能够存放一个TSS数据结构即可。

对于IDT(中断描述符表)，它保存在内核代码段中。

在Linux 0.12中，内核和各任务的代码段和数据段都分别被映射到线性地址空间中相同基址处，且段限长一样，因此内核的数据段和代码段是重叠的，各任务的代码段和数据段也是重叠的，参见图5-10或5-11。

任务状态段TSS(Task State Segment)用于在任务切换时CPU自动保存或恢复相关任务的当前执行上下文。

在Linux 0.12中，**每个任务的TSS段内容被保存在该任务的任务数据结构中**。

另外，Linux 0.12没有使用到GDT中第4个描述符(图中syscall描述符项)。从include/linux/sched.h文件中第201行的注释可以猜到，Linus本来想把系统调用的代码放在这个专门的段中。

```
200  /*
201  * Entry into gdt where to find first TSS. 0-nul, 1-cs, 2-ds, 3-syscall
202  * 4-TSS0, 5-LDT0, 6-TSS1 etc ...
203  */
```

## 4. 内存分页管理

内存分页管理机制的基本原理是将CPU整个**线性内存区域**(！！！线性地址是32位，可寻址范围4GB)划分成4KB为1页的内存页面，然后与物理内存地址空间的页面映射。为在8086保护模式下使用分页机制，需要将控制寄存器CR0的最高位(位31)置位。

使用内存分页管理方法，每个执行中的进程(任务)可以使用比实际内存容量大得多的连续地址空间。为能将线性地址映射在容量相对较小的物理内存空间上，80386使用了页目录表和页表。页目录表项和页表项格式基本相同，都占用4字节，并且**每个页目录表或页表必须只能包含1024个项**。一个页目录表或一个页表分别占用1页内存。两个区别在于页表项有一个已写位D(Dirty)，页目录项没有。

线性地址到物理地址变化过程如图。**一个页表1024项，一个页表映射内存1024\*4KB=4MB；一个页目录表1024项，对应1024个页表。所以一个页目录表就能映射1024\*4MB=4GB**，即一个页目录项就可以映射整个线性地址空间范围(线性地址是32位)。

![config](images/8.png)

由于Linux 0.1x系统中内核和所有任务都**共用一个页目录表**，使得**任何时刻处理器线性地址空间到物理地址空间的映射函数都一样**。因此，**为了让内核和所有任务都不互相重叠和干扰，它们必须从虚拟地址空间映射到线性地址空间的不同位置**。

对于Intel 80386，CPU提供了多达4GB的线性地址空间(32位线性地址)。为使用实际物理内存，每个进程的线性地址通过二级内存页表动态映射到主内存区域的不同物理内存页上。

由于Linux 0.12中把**每个进程最大可用虚拟内存空间定义为64MB**，因此**每个进程的逻辑地址通过加上(任务号)\*64MB，即可转换成线性地址**。

对于Linux 0.12，内核设置GDT中段描述符项数最大256，其中2项空闲，2项系统使用，每个进程使用两项(TSS和LDT)。因此，此时系统最多可以容纳(256-4)/2=126个任务，并且虚拟地址范围是((256-4)/2)\*64MB约等于8GB。但0.12内核中人工定义最大任务数NR_TASKS=64个，每个任务逻辑范围是64MB，并且**各个任务在线性地址空间中的起始位置是(任务号)\*64MB**。因此所有任务**所使用的线性地址空间范围(不是全部空间范围大小，只不过这里刚好相等了)是**64MB\*64=4GB，如图5-10。

图中是当系统具有4个任务时的情况。内核代码段和数据段被映射到线性地址空间的开始16MB部分，并且代码和数据段都映射到同一区域，完全重叠。

第一个任务(任务0)由内核“人工”启动运行的，其代码和数据包含在内核代码和数据中，因此所占的线性地址范围比较特殊。任务0的代码段和数据段长度是从线性地址0开始的640KB范围，其代码和数据段也完全重叠，并且和内核代码段和数据段有重叠。

实际上，Linux 0.12中所有任务的指令空间I(Instruction)和数据空间D(Data)都合用一块内存，即同一个进程的所有代码、数据和堆栈都处于同一内存段中。

任务1的线性地址空间范围从64MB开始的640KB长度。任务2和任务3分别被映射到线性地址128MB和192MB的地方，并且逻辑地址范围是64MB。4GB是CPU线性地址空间范围和可寻址的最大物理地址空间范围，并且把任务0和任务1的逻辑地址范围看成64MB时，系统中同时可有的任务的逻辑地址范围综合也是4GB，因此在0.12中容易混淆这三种概念。

![config](images/9.png)

下图是任务在虚拟地址空间中的示意图，所占用的虚拟空间范围也是4GB。其中没有考虑内核代码和数据在虚拟空间中所占的范围。另外，图中对于进程2和进程3还分别给出了各自逻辑空间中的代码段和数据段(包含数据和堆栈)的位置。

![config](images/10.png)

注意，进程逻辑地址空间中代码段(Code Section)和数据段(Data Section)的概念和CPU中分段机制中的代码段和数据段不是同一个概念。CPU中分段机制中段确定了在线性地址空间中一个段的用途以及被执行或访问的约束和限制，每个段可以设置在4GB线性地址空间中的任何地方，可以相互独立也可以完全重叠或部分重叠。进程在其逻辑地址空间中的代码段和数据段则是指由编译器在编译程序和操作系统在加载程序时规定的在进程逻辑空间中顺序排列的代码区域、初始化和未初始化的数据区域以及堆栈区域。进程逻辑地址空间中代码段和数据段结构如图5-12，图中的nr是任务号。有关逻辑地址空间说明见13章。

![config](images/11.png)

## 5. CPU多任务和保护方式

Linux 0.12操作系统使用了CPU的0和3两个保护级。内核代码本身会由系统中所有任务共享。而每个任务则都有自己的代码和数据区，这两个区域保存于局部地址空间，因此系统中其他任务不能访问。而内核数据和代码是所有任务共享的，因此在全局地址空间中。图5-13给出这种结构示意图。

![config](images/12.png)

## 6. 虚拟地址、线性地址和物理地址的关系

现在以Linux 0.12为例，详细说明**内核代码和数据**以及**各任务的代码和数据**在虚拟地址空间、线性地址空间和物理地址空间之间的对应关系。

### 6.1 内核代码和数据的地址

对于Linux 0.12内核代码和数据来说，**在head.s程序初始化操作中已经将内核代码段和数据段都设置为长度16MB的段**。在线性地址空间中这两个段重叠，都是**从线性地址0开始到地址0xFFFFFF共16MB**地址范围。在该范围内含有**内核所有代码**、**内核段表**(GDT、IDT、TSS)、**页目录表**和内核的二级**页表**、**内核局部数据**以及**内核临时堆栈**(将被用作第一个任务的用户堆栈)。其**页目录表**和**二级页表**已设置成**把0~16MB的线性地址空间一一对应到物理地址**上，占用了4个目录项，即4个二级页表。因此对内核代码或数据的地址，我们可以直接把它们看成物理内存中的地址。关系如图。

![config](images/13.png)

因此，默认Linux 0.12**内核**最多可以管理16MB的物理内存，共有4096个物理页面，每个页面4KB。

①内核代码段和数据段区域在线性地址空间和物理地址空间是一样的。这样简化内核的初始化操作。

②GDT和IDT在内核数据段中，因此它们的线性地址等于其物理地址。实模式下的setup.s初始化中，曾设置过临时GDT和IDT，这是进保护模式必须的。进入保护模式后，运行第1个程序head.s中需要重新设置这两个表。即设置GDTR和IDTR指向新的GDT和IDT，描述符也需要重新加载，但由于分页机制时这两个表没变动，所以不需要重新建立。

③除了任务0，所有**其他任务**使用的物理页面和线性地址页面至少有部分不同，因此**内核**需要**动态在主内存区中为它们作映射，动态建立页目录表和页表项**。

### 6.2 任务0的地址对应关系

任务0是系统中人工启动的第1个任务。代码段和数据段长度是640KB，都直接包含在内核代码和数据中，从线性地址0~640KB，可以直接用内核代码设置好的页目录和页表。代码段和数据段在线性地址空间重叠。对应的**TSS0手工预设**好的，并且位于任务0数据结构信息中，参见include/linux/sched.h第156行。TSS0段位于内核sched.c程序的代码中，长度104字节，具体位置见图5-24。

![config](images/14.png)

运行时所需的内核态堆栈和用户态堆栈空间也在内核代码区中(**不需要额外分配内存页**)，并且在内核初始化时(head.s)这些内核页面在**页表项中属性都被设成0b11**，即对应页面用户可读写并且存在，因此用户堆栈user_stack[]空间虽然在内核空间，但任务0仍然能读写(**也就是说这个堆栈存在于内核空间，但是页表项中有一个位U/S，设置为1表明所有特权级均可访问，所以用户态<特权级3>也可以访问，所以叫做内核空间的用户态堆栈**)。

### 6.3 任务1的地址对应关系

任务1也特殊。与任务0不同的是，在线性地址空间中，系统在使用fork()创建任务1(init进程)时为存放任务1的**二级页表**而**在主内存区申请了一页内存**来存放，并**复制父进程**(任务0)的**页目录和二级页表项**。因此任务1有自己的页目录和页表表项，它把任务1占用的线性空间范围64MB\~64MB+640KB同样映射到物理地址0\~640KB。此时任务1长度也是640KB，并且代码段和数据段重叠，只占用**一个页目录项和一个二级页表**。

另外，还会在主内存区中**申请一页内存**用来存放它的**任务数据结构**和用作任务1的**内核堆栈空间**。任务数据结构(也称进程控制块PCB)信息中包含任务1的TSS段结构信息，如图。

![config](images/15.png)

任务1的用户态堆栈空间将直接共享使用处于内核代码和数据区域(线性地址0\~640KB)中任务0的用户态堆栈空间user\_stack[](kernel/sched.c，第82\~87行)，因此这个堆栈需要在任务1实际使用前确保被复制用于任务1的堆栈不含无用数据。在刚开始创建任务1时，任务0的用户态堆栈user\_stack[]与任务1共享，但当任务1开始运行，由于任务1映射到user\_stack[]处的页表项被设为只读，使得任务1在执行堆栈操作时会引起写页面异常，从而由内核**另行分配主内存区页面作为堆栈空间**使用。

### 6.4 其他任务的地址对应关系

从任务2开始，它们的父进程都是init(任务1)进程。上面说过，Linux 0.12中共可以有64个进程同时存在。下面以任务2为例说明。

从任务2开始，如果任务号以nr表示，那么任务nr在线性地址空间中起始位置将被设定在nr\*64MB。例如任务2的开始位置=nr\*64MB=2\*64MB=128MB。任务代码段和数据段最大程度被设为64MB，因此任务2占有的线性地址空间范围是128MB\~192MB，共占用64MB/4MB(一个页面内存4KB，使用4字节<32位>表示一个页面项，一个页表<4KB,一页内存>有4KB/4字节=1024个页面项，共计1024\*4KB=4MB空间。一个目录项指向一个页表)=16个页目录项(！！！目录项，不是目录)，一个页目录项4字节，总64字节。

虚拟空间中任务代码段和数据段也是完全重叠。

任务2被创建出来后，将在其中运行execve()函数来执行shell程序。当内核通过复制任务1创建任务2时，除了占用线性地址空间范围不同，其他类似。当任务2的代码(init())调用execve()系统调用开始加载并执行shell程序时，该系统调用会释放从任务1复制的页目录和页表表项以及相应内存页面，然后重新设置。

下图给出任务2中开始执行shell时情况，即任务2原先复制2的代码和数据被shell替换后的情况。图中显示出已经映射一页物理内存页面的情况。这里注意，执行execve()函数时，系统虽然在线性地址空间为任务2分配了64MB空间，但内核**并不会立刻分配和映射物理内存页面**。**只有当任务2开始执行时由于缺页异常才会由内存管理程序为其在主内存区中分配并映射一页物理内存到线性地址空间**。详见13章。

![config](images/16.png)

从Linux内核0.99后，对内存空间使用方式变化很大。每个进程可以单独享用这个4GB地址空间范围。

## 7. 用户申请内存的动态分配

当用户程序使用C函数库中内存分配函数malloc()申请内存时，这些**动态申请的内存容量或大小均由高层次的C函数malloc()管理，内核本身不管理**。因为内核已经为每个进程(除了任务0和任务1，它们和内核代码一样常驻内存中)在CPU的4GB**线性地址空间中分配了64MB的空间**，所以只要进程执行时寻址范围在64MB范围内，内核页同样会通过内存缺页管理机制自动为寻址对应的页面分配物理内存页面并进行映射。

但是内核会为进程使用的代码和数据空间维护一个当前位置值brk，这个值保存在每个进程的数据结构中。**它指出进程代码和数据(包括动态分配的数据空间)在进程地址空间中的末端位置**。当malloc为程序分配内存时，它会通过系统调用brk()把程序要求新增的空间长度通知内核，内核从而根据malloc()提供的信息更新brk值，但此时不会为新申请的空间映射物理内存页面。只有当程序寻址到某个不存在对应物理页面的地址时，内核才进行相关物理页面的映射操作。

**若进程代码寻址的某个数据所在的页面不存在，并且该页面所处位置在进程堆范围，即不属于其执行文件映像文件对应的内存范围，CPU会产生一个缺页异常，并在异常处理程序中为指定的页面分配并映射一页物理内存页面。至于用户程序申请内存的字节长度数量和在对应物理页面中的具体位置，均由C库中内存分配函数malloc()负责管理。内核以页面为单位分配和映射物理内存，该函数则具体记录用户程序使用了一页内存的多少字节。剩余容量将保留城程序再申请内存时使用**。

用户使用free()动态释放已申请的内存块时，C库中的内存管理函数就把所释放的内存块标记为空闲，以备程序再次申请内存时使用。这个过程中内核为该进程所分配的这个物理页面不会被释放掉。只有当进程最终结束内核才会全面回收已分配和映射到该进程地址空间范围的所有物理内存页面。

具体代码查看lib/malloc.c。
本节概要描述Linux内核从开机引导到系统正常运行过程中对堆栈的使用方式. 

Linux 0.12中共用了4种堆栈. 第1种是系统引导初始化时临时使用的堆栈; 第2种是保护模式后提供内核程序初始化使用的堆栈, 位于内核代码地址空间固定位置处. 该堆栈也是任务0使用的用户态堆栈; 第3种是每个任务通过系统调用, 执行内核程序时使用的堆栈, 任务的内核态堆栈. 每个任务都有自己独立的内核态堆栈; 第4种是任务在用户态执行的堆栈, 位于任务(进程)逻辑地址空间近末端处. 

## 1. 初始化阶段

(1)开机初始化时(bootsect.S, setup.s)

当bootsect代码被ROM BIOS加载到物理内存0x7c00时, 并没有设置堆栈段. 直到bootsect被移动到0x9000:0时, 才把堆栈段寄存器SS设置为0x9000, 堆栈指针esp设为0xff00, 参见boot/bootsect.s第61、62行. setup.s也沿用了这个. 这就是系统初始化时临时使用的堆栈. 

(2)进入保护模式时(head.s)

从head.s起, 系统正式在保护模式下运行. 此时堆栈段被设为内核数据段(0x10), 堆栈指针esp设置成指向user\_stack数组的顶端(head.s, 31行), 保留1页内存(4KB)作为堆栈使用. user\_stack数组定义在sched.c的67\~72行, 共1024个长字. 它在物理内存位置见下图. 此时该堆栈是内核程序自己使用的堆栈. 其中地址是大约值, 取决于编译时实际设置参数. **这些地址位置从编译内核时生成的system.map文件中查到**. 

![config](images/29.png)

(3)初始化时(main.c)

在init/main.c中, 执行move\_to\_user\_mode()代码把控制权移交给任务0之前, 系统一直使用上述堆栈. 而在执行move\_to\_user\_mode()后, main.c的代码被“切换”成任务0中执行. 通过执行fork()系统调用, main.c中init()将在任务1中执行, 并使用任务1的堆栈. 而main()本身则在被“切换”成任务0后, 仍然继续使用上述内核程序自己的堆栈作为任务0的用户态堆栈. 

## 2. 任务的堆栈

每个任务有两个堆栈, 分别用于用户态和内核态程序的执行, 并且分别称为用户态堆栈和内核态堆栈. 除了处于不同CPU特权级, 主要区别在于任务的内核态堆栈很小, 所保存的数据量最多不能超过4096-任务数据结构块个字节, 约3KB. 而任务的用户态堆栈却可以在用户的64MB空间内延伸. 

(1)在用户态运行时

除了任务0和1, 每个任务有自己的64MB地址空间. 当一个任务(进程)刚被创建时, 它的用户态堆栈指针被设置在其地址空间靠近末端(64MB)部分. 实际上末端先是执行程序的参数和环境变量, 然后是用户堆栈空间. 如下图. 实际使用的物理内存则由CPU分页机制确定. 由于Linux写时复制(Copy On Write), 因此, 进程创建后, 若该进程以及父进程没有使用堆栈, 则两者共享同一堆栈对应的物理内存页面. 只有当其中一个进程执行堆栈写操作(如push)内核内存管理才会为写操作进程分配新内存页面. 进程0和1的用户栈比较特殊. 

![config](images/30.png)

(2)在内核态运行时

每个任务有自己的内核态堆栈, 用于任务在内核代码中执行. 在线性地址中位置由该任务TSS段中ss0和esp0指定. ss0是内核态堆栈的段选择符, esp0是栈底指针. 因此每当任务从用户代码转移到内核代码中执行(纯控制转移, 不涉及任务切换), 任务的内核态栈总是空的. 任务内核态堆栈被设置在位于其任务数据结构(stask\_struct)所在页面的末端(同一页面). 这是fork()程序在任务tss段的内核级堆栈字段(tss.esp0和tss.ss0)中设置的, 参见kernel/fork.c, 92行: 

```
p->tss.esp0 = PAGE_SIZE + (long)p;
p->tss.ss0 = 0x10;  //内核数据段描述符
```

其中, p是新任务的任务数据结构指针. 

![config](images/31.png)

为何从主内存区申请的用来保存任务数据结构的一页内存也能被设置成内核数据段中的数据呢, 即tss.ss0为何可被设为0x10？因为用户内核态栈仍属于内核数据空间. 在head.s末端, 分别设置了内核代码段和数据段的描述符, 段长度都被设为16MB. 这个长度是Linux 0.12内核所能支持的最大物理内存长度(head.s, 110行开始的注释). 因此, 内核代码可寻址到整个物理内存范围, 也包括了主内存区. 每当任务执行内核程序而使用其内核栈时, CPU就会利用TSS结构把它的内核态堆栈设为由tss.ss0和tss.esp0两个值构成. 任务切换时, 旧任务的内核栈指针esp0不会被保存. 对CPU, 这两个值只读. 所以每当一个任务进入内核态执行时, 其内核态堆栈总是空的. 

(3)任务0和任务1的堆栈

任务0(空闲进程idle)和任务1(初始化进程init)堆栈特殊. **任务0和任务1**的代码段和数据段相同, 限长也都是640KB, 但**映射到不同线性地址范围**. 任务0的段基地址从线性地址0开始, 而任务1的段基地址从64MB开始. 但它们**全映射到物理地址0\~640KB**. 这个范围也就是内核代码和基本数据所存放的地方. 

任务1创建时复制任务0的用户堆栈, 所以刚开始任务0和任务1共享使用同一个用户堆栈空间. 但当任务1开始运行时, 由于任务1映射到user\_stack[]处的页表项被设为只读, 使得任务1在执行堆栈操作时将引起写页面异常, 从而内核会使用写时复制为任务另行分配主内存区页面作为堆栈空间使用. 此时, 任务1才开始使用自己独立的用户堆栈内存页面. 所以任务0的堆栈需要在任务1实际开始使用前保持“干净”, 即任务0此时不能使用堆栈, 以确保复制的堆栈页面中不含任务0的数据. 

## 3. 任务内核态堆栈和用户态堆栈之间的切换

Linux 0.12中, 所有中断服务程序都是内核代码. 若一个中断的产生时任务正在用户代码中执行, 则中断会引起CPU特权级从3到0的变化, 此时CPU就会进行用户态堆栈到内核态堆栈的切换操作. CPU会从当前任务的TSS中取得新堆栈的段选择符和偏移值. 因为中断服务程序在内核中, 属于0级特权级代码, 所以48位内核态堆栈指针会从TSS的ss0和esp0字段获得. 在定位了新堆栈(内核态堆栈)后, CPU先把原用户态堆栈指针ss和esp压入内核态堆栈, 然后将eflags和返回位置cs、eip压入内核态堆栈. 

内核的系统调用是个软中断, 所以任务调用系统调用会进入内核并执行内核的中断服务代码. 此时内核代码就会使用该任务的内核态堆栈进行操作(这是常规中断处理过程, 也可以执行任务切换, 这里不会存在任务切换！！！). 内核态和用户态堆栈会发生切换. iret(远跳转返回指令)退出内核返回到用户程序. 

![config](images/32.png)

**若一个任务正在内核态, 那么CPU响应中断就不需要堆栈切换, CPU仅把eflags和cs、eip压入当前内核态堆栈, 然后执行中断服务过程**. 


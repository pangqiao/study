## 1. 系统时间

PC/AT系统中提供了**用电池供电的实时钟(Real Time, RT)电路支持**. 通常, **这部分电路与保存系统信息的CMOS RAM集成在一个芯片上, 因此这部分电路被称为RT/CMOS RAM电路**. PC/AT微机或其兼容机使用了Motorala的MC146818芯片. 

初始化时, Linux 0.12通过init/main.c的time\_init()函数读取这块芯片中保存的当前时间和日期信息, 并通过kernel/mktime.c中的kernel\_mktime()函数转换成从1970年1月1日午夜0时开始到当前的以秒为单位的时间, 称为UNIX日历时间. 该时间确定了系统开始运行的日历时间, 被保存在全局变量startup\_time中供内核所有代码使用. 用户程序可以通过系统调用time()来读取startup\_time的值, 而超级用户可以通过系统调用stime()来修改这个系统时间值. 

另外, 再通过下面介绍的从系统启动开始计数的系统滴答值jiffies, 程序就可以唯一地确定运行时刻的当前时间值. 由于每个滴答定时值是10ms, 因此内核代码定义了一个宏来方便代码对当前时间的访问. 这个宏定义在include/linux/sched.h文件在192行, 形式如下: 

```
#define CURRENT_TIME (startup_time + jiffies/HZ)
```

其中, HZ=100, 是内核系统时钟频率. 当前时间宏CURRENT\_TIME被定义为系统开机时间startup_time加上开机后系统运行的时间jiffies/100. 在修改一个文件的被访问时间或其i节点的被修改时间时均使用了这个宏. 

## 2. 系统定时

在Linux 0.12内核初始化过程中, **PC的可编程定时芯片Intel 8253(8254)的计数器通道0被设置为运行在方式3下**(方波发生器方式), 并且初始计数值LATCH被设置为每隔10ms在通道0输出端OUT发一个方波上升沿. 由于8254芯片的时钟输入频率时1.193180MHZ, 因此初始计数值LATCH=1193180/100, 约为11931. **由于OUT引脚被连接到PIC的0级上(也就是说连接在中断控制器上)**, 因此每隔10ms会发出一个时钟中断请求(IRQ0)信号. 这个时间节拍就是操作系统运行的脉搏, 称为1个系统滴答或一个系统时钟周期. 因此, 每隔1个滴答时间, 系统就会调用一次时钟中断处理程序. 

时钟中断处理程序timer\_interrupt主要用来通过jiffies变量来累计自系统启动以来经过的时钟滴答数. 一次时钟中断jiffies就加1. 然后调用C函数do\_timer()进一步处理. 调用时的参数CPL是从被中断程序的段选择符(保存在堆栈中的CS段寄存器值)中取得当前代码特权级CPL. 

do\_timer()函数则根据特权级对当前进程运行时间作累计. 若CPL=0, 表示进程运行在内核态时被中断, 因此内核就会把进程的内核态运行时间统计数stime加1, 否则把进程用户态运行时间统计数加1. 

如果软盘处理程序floppy.c在操作过程中添加定时器, 则对定时器链表进行处理. 若某个定时器时间到(递减后等于0), 则调用该定时器的处理函数. 然后对当前进程运行时间进行处理, 把当前进程运行时间减1. 时间片是一个进程在被切换掉之前所能持续运行的CPU时间, 其单位是上面定义的滴答数. 如果时间片值递减后还大于0, 表示其时间片还没用完, 于是退出do\_timer()继续运行当前进程. 若此时进程时间片已经递减为0, 表示进程用完了此次时间片, 于是程序就会根据被中断程序的级别来确定进一步处理的方法. 若被中断的当前进程是工作在用户态的(特权级别大于0), 则do\_timer()就会调用调度程序schedule()切换到其他进程去运行. 内核态, 即在内核程序中运行时被中断, 则do\_timer()会立即退出. 因此这样的处理方式决定了Linux系统的进程在内核态运行时不会被调度程序切换. 即进程在内核态程序中运行时是不可抢占的(nonpreemptive), 但当处于用户态程序中运行时则是可以被抢占的(preemptive). 


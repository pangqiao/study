linux/kernel目录. 

该目录下代码从功能上可分为三类，一类是硬件(异常)中断处理程序文件，一类是系统调用服务处理程序文件，还有进程调度等通用功能. 

![config](images/1.png)

## 1. 中断处理程序

主要两个文件: asm.s和traps.c. asm.s实现大部分硬件异常所引起的中断的汇编语言处理程序. traps.c则实现了asm.s的中断处理过程中调用的C函数. 另外几个硬件中断处理过程在文件sys\_call.s和mm/page.s中实现. 关于PC中825A可编程中断控制芯片见其他章节. 

在用户程序(进程)将控制权交给中断处理程序前，CPU会首先将至少12字节(EFLAGS、CS和EIP)信息压入中断处理程序的堆栈中，即**进程的内核态栈中(这不是任务切换，只是控制权转移，详细见Assembly相应内容！！！)**. 见图8-2a所示，这与一个远调用(段间子程序调用)类似. CPU会将代码段选择符CS和返回地址的偏移值压入堆栈. 另一个与段间调用相似地方是将信息压入到目的代码(中断处理程序代码)的堆栈上，而不是被中断代码的堆栈中. 

若优先级变化，例如从用户级改变到内核系统级，CPU还会将原代码的堆栈段值和堆栈指针压入中断程序的堆栈中. 但内核初始化完成后，内核代码执行使用的是进程的内核态栈，而被中断代码的堆栈当然也就是指进程的用户态堆栈了. 所以发生中断时，中断处理过程使用的是进程的内核态堆栈. 另外，CPU还总将EFLAGS内容压入隧站. 

![config](images/2.png)

asm.s主要涉及对Intel保留中断int0\~int16的处理，其余保留的中断int17\~int31由Intel保留. Linux系统调用中断int128(0x80)处理将在kernel/sys\_call.s给出. 

有些异常的中断，CPU内部产生一个出错码压入堆栈(异常中断int8和int10\~int14)，如图8-2b，而其他中断并不带有这个出错码，因此，asm.s中会根据是否携带出错码将中断分为两类处理. 但处理流程还是一样. 

一个硬件异常引起的中断处理过程如图8-3. 

![config](images/3.png)

## 2. 系统调用处理相关程序

Linux中应用调用内核的功能是通过中断调用int 0x80进行的，寄存器eax放调用号，若带参数，ebx、ecx和edx用于存放调用参数. 因此该中断调用被称为系统调用. 实现系统调用相关文件包括sys\_call.s、fork.c、signal.c、sys.c和exit.c文件. 

sys\_call.s类似于硬件中断处理中asm.s的作用，另外还对时钟中断和硬盘、软盘中断进行处理. fork.c提供了两个C处理函数: find\_empty\_process()和copy\_process(). signal.c还提供了一个处理有关进程信号的函数do\_gignal()，在系统调用中断过程中被调用. 另外还有4个系统调用sys\_xxx()函数. 

sys.c和exit.c程序实现了一些sys\_xxx()系统调用函数. 这都是相应系统调用所需的处理函数. 

## 3. 其他通用类程序

schedule.c、mktime.c、panic.c、printk.c和vsprintf.c. 

schedule.c包含内核的核心调度程序，用于对进程的执行进行切换或改变执行状态. 另外还有系统时钟中断和软盘驱动器定时函数. 

mktime.c仅有一个内核使用的时间函数mktime()，仅在init/main.c中被调用一次. 

panic.c包含一个panic()函数，用于在内核运行出错时显示出错信息并停机. 

printk.c和vsprintf.c是内核显示信息的支持程序，实现内核专用显示函数printk()和字符串格式化输出函数vsprintf(). 

# 概述

wakeup events framework 包括wake lock、wakeup count、autosleep等机制。

# wakeup events framework要解决的问题

我们知道，系统处于suspend状态，可通过wakeup events唤醒。具体的wakeup events可以是按键按下，可以是充电器插入，等等。但是，如果在suspend的过程中，产生了 wakeup events，怎么办？答案很肯定，"wakeup"系统。由于此时系统没有真正 suspend，所以这的 "wakeup" 是个假动作，实际上只是终止suspend。

但由于系统在 suspend 的过程中，会进行 process freeze、 device suspend 等操作，而这些操作可能导致**内核**或**用户空间**程序**不能及时获取 wakeup events**，从而使系统不能正确 wakeup，这就是 wakeup events framework 要解决的问题: system suspend 和 system wakeup events 之间的同步问题。

# wakeup events framework的功能总结

仔细推敲一下，上面所讲的同步问题包括两种情况: 

情况1: 内核空间的同步

wakeup events 产生后，通常是以**中断的形式**通知 device driver。driver 会处理 events，处理的过程中，系统不能 suspend。

注1：同步问题只存在于中断开启的情况，因为若中断关闭，就不会产生wakeup events，也就不存在同步的概念。

情况2：用户空间的同步

一般情况下，driver对wakeup events处理后，会交给用户空间程序继续处理，处理的过程，也不允许suspend。这又可以分为两种情况：

1）进行后续处理的用户进程，根本没有机会被调度，即该wakeup events无法上报到用户空间。

2）进行后续处理的用户进程被调度，处理的过程中（以及处理结束后，决定终止suspend操作），系统不能suspend。

因此，wakeup events framework就包括3大功能：

* 解决内核空间同步问题（framework的核心功能）；

* 解决用户空间同步问题的情景1（wakeup count功能）；

* 解决用户空间同步问题的情景2（wake lock功能）。

注2：

用户空间同步的两种情况，咋一看，非常合乎情理，kernel你得好好处理！但事实上，该同步问题牵涉到了另外一个比较有争议的话题：日常的电源管理机制。是否要基于suspend实现？系统何时进入低功耗状态，应该由谁决定？kernel还是用户空间程序？

这最终会决定是否存在用空间同步问题。但是，在当前这个时间点，对这个话题，Linux kernel developers和Android developers持相反的观点。这也造成了wakeup events framework在实现上的撕裂。Kernel的本意是不愿处理用户空间同步问题的，但为了兼容Android平台，不得不增加相关的功能（Wakeup count和Wake lock）。

在下一篇文章和大家探讨该话题，本文就先focus在wakeup events framework上。 

# 架构

下面图片描述了 wakeup events framework 的 architecture：

![2024-03-19-12-17-57.png](./images/2024-03-19-12-17-57.png)

图片中红色边框的block是wakeup events相关的block:

1. wakeup events framework core，在 drivers/base/power/wakeup.c 中实现，提供了 wakeup events framework 的核心功能，包括：

* 抽象wakeup source和wakeup event的概念；

* 向各个device driver提供wakeup source的注册、使能等接口；

* 向各个device driver提供wakeup event的上报、停止等接口；

* 向上层的PM core（包括wakeup count、auto sleep、suspend、hibernate等模块）提供wakeup event的查询接口，以判断是否可以suspend、是否需要终止正在进行的suspend。

2. wakeup events framework sysfs，将设备的wakeup信息，以sysfs的形式提供到用户空间，供用户空间程序查询、配置。在drivers/base/power/sysfs.c中实现。

3. wake lock/unlock，为了兼容Android旧的wakeup lock机制而留下的一个后门，扩展wakeup events framework的功能，允许用户空间程序报告/停止wakeup events。换句话说，该后门允许用户空间的任一程序决定系统是否可以休眠。

4. wakeup count，基于wakeup events framework，解决用户空间同步的问题。

5. auto sleep，允许系统在没有活动时（即一段时间内，没有产生wakeup event），自动休眠。

注3：在Linux kernel看来，power是系统的核心资源，不应开放给用户程序随意访问（wake lock机制违背了这个原则）。而在运行时的电源管理过程中，系统何时进入低功耗状态，也不是用户空间程序能决定的（auto sleep中枪了）。因此，kernel对上述功能的支持，非常的不乐意，我们可以从kernel/power/main.c中sysfs attribute文件窥见一斑（只要定义了PM_SLEEP，就一定支持wakeup count功能，但autosleep和wake lock功能，由另外的宏定义控制）：

```cpp
static struct attribute * g[] = {
	&state_attr.attr,
#ifdef CONFIG_PM_TRACE
	&pm_trace_attr.attr,
	&pm_trace_dev_match_attr.attr,
#endif
#ifdef CONFIG_PM_SLEEP
	&pm_async_attr.attr,
	&wakeup_count_attr.attr,
#ifdef CONFIG_SUSPEND
	&mem_sleep_attr.attr,
	&sync_on_suspend_attr.attr,
#endif
#ifdef CONFIG_PM_AUTOSLEEP
	&autosleep_attr.attr,
#endif
#ifdef CONFIG_PM_WAKELOCKS
	&wake_lock_attr.attr,
	&wake_unlock_attr.attr,
#endif
#ifdef CONFIG_PM_SLEEP_DEBUG
	&pm_test_attr.attr,
	&pm_print_times_attr.attr,
	&pm_wakeup_irq_attr.attr,
	&pm_debug_messages_attr.attr,
#endif
#endif
#ifdef CONFIG_FREEZER
	&pm_freeze_timeout_attr.attr,
#endif
	NULL,
};
```

# 代码分析



起初 autosleep 是在 Android 上的 wakelocks patchset(https://lwn.net/Articles/479711/)演化而来的，当时名字叫做 "Opportunistic sleep"，翻译过来叫做"机会主义睡眠"，也就是有机会就睡。因为此名字比较有争议，最后修改为 autosleep。

autosleep 用于取代 wakelock 中的自动休眠功能。它基于 wakeup source 实现。从代码逻辑上讲， autosleep 是一个简单的功能，但是背后却埋藏这一个令人深思的问题。

* 计算机的休眠（通常是 STR, Standby, Hibernate 等 suspend 操作）， 应当在什么时候，由谁触发？

对于pc，笔记本来说： 当用户在其不想使用或不再使用时

对于移动设备：逮到机会就睡，困难的点在于如何判定系统没有事情可做。

根据使用场景，低功耗状态可以是Freeze， Standby, Suspend to RAM和suspend to disk中的任意一种。 而怎么判断系统没有事情在做呢？ 依赖 wakeup events framework。 只要系统没有正在处理和新增的wakeup events， 就尝试 suspend, 如果suspend过程中有events 产生，再 resume 就是了。

由于 suspend/resume 的操作如此频繁，解决同步问题就越发重要，这也要依赖 wakeup events framework 及其 wakeup count 功能。

同样 autosleep.c 的注释可以说明 autosleep 的前身是 Opportunistic sleep。

```cpp
/*
 * kernel/power/autosleep.c
 *
 * Opportunistic sleep support.
 *
 * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>
 */
```

详细文章可见:  https://lwn.net/Articles/479841/

# 原理

1. 当系统没有任何事情做的时候，就尝试 susupend。

2. 当系统中没有 wakeup event 事件发生的时候，就可以尝试 suspend，需要 wakeup event framework 机制支持。

3. autosleep 功能需要在 kernel config 中开启 `CONFIG_PM_AUTOSLEEP=y`。

4. 通过写 "mem, disk,  standby, freeze" 到 `/sys/power/autosleep` 可以开启 autosleep。

5. 通过写 "off" 到 `/sys/power/autosleep` 就可以关闭autosleep。

# 流程分析

通过执行 "`echo mem > /sys/power/autosleep`" 此命令，系统就会在没有事情可做的时候，选择执行 suspend 的流程。

```cpp
// kernel/power/autosleep.c
// 定义, 默认是0, 即默认 PM_SUSPEND_ON
// PM_SUSPEND_ON 表明关闭 autosleep
static suspend_state_t autosleep_state;

suspend_state_t pm_autosleep_state(void)
{
	return autosleep_state;
}

// kernel/power/main.c
// kernel config 要求
#ifdef CONFIG_PM_AUTOSLEEP
static ssize_t autosleep_show(struct kobject *kobj,
			      struct kobj_attribute *attr,
			      char *buf)
{
    // 返回autosleep_state值
	suspend_state_t state = pm_autosleep_state();

    // 返回off, 表明关闭了
	if (state == PM_SUSPEND_ON)
		return sprintf(buf, "off\n");

#ifdef CONFIG_SUSPEND
    // kernel config 要求
	if (state < PM_SUSPEND_MAX)
        // 返回 s2idle/standby/mem
		return sprintf(buf, "%s\n", pm_states[state] ?
					pm_states[state] : "error");
#endif
#ifdef CONFIG_HIBERNATION
	return sprintf(buf, "disk\n");
#else
	return sprintf(buf, "error");
#endif
}
// kernel/power/power.h
#IFDEF CONFIG_PM_AUTOSLEEP
extern suspend_state_t pm_autosleep_state(void);
#ELSE /* !CONFIG_PM_AUTOSLEEP */ /* 没有配置 CONFIG_PM_AUTOSLEEP, 那么 SUSPEND 是可用的 */
static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }
#ENDIF /* !CONFIG_PM_AUTOSLEEP */
```

```cpp
// kernel/power/main.c
static ssize_t autosleep_store(struct kobject *kobj,
			       struct kobj_attribute *attr,
			       const char *buf, size_t n)
{
    // 上一节有详细分析
    // 解析传入的参数, 返回 0/1/2/3/4
	suspend_state_t state = decode_state(buf, n);
	int error;
    // ON的时候, 传入不是 off 直接返回
	if (state == PM_SUSPEND_ON
	    && strcmp(buf, "off") && strcmp(buf, "off\n"))
		return -EINVAL;

	if (state == PM_SUSPEND_MEM)
        // 上一节有详细分析
		state = mem_sleep_current;
    // 设置autosleep_state
	error = pm_autosleep_set_state(state);
	return error ? error : n;
}

power_attr(autosleep);
#endif /* CONFIG_PM_AUTOSLEEP */
```

解析传参

* 输入 `"disk"`, 返回 `PM_SUSPEND_MAX`, 4

* 输入 `"freeze"/"standby"/"mem"`, 返回 `PM_SUSPEND_TO_IDLE/PM_SUSPEND_STANDBY/PM_SUSPEND_MEM`, 1/2/3

* 否则, 直接返回 `PM_SUSPEND_ON`, 0, 即 **默认返回**

`PM_SUSPEND_ON` 但输入不是 "**off**", 直接返回; 否则调用下面

```cpp
// kernel/power/autosleep.c
int pm_autosleep_set_state(suspend_state_t state)
{
    // 第一
#ifndef CONFIG_HIBERNATION
	if (state >= PM_SUSPEND_MAX)
		return -EINVAL;
#endif
    // 第二
	__pm_stay_awake(autosleep_ws);
    // 拿锁
	mutex_lock(&autosleep_lock);
    // 第三
    // 设置 autosleep_state
	autosleep_state = state;
    // 第四
	__pm_relax(autosleep_ws);
    // 第五
	if (state > PM_SUSPEND_ON) {
        // enable
		pm_wakep_autosleep_enabled(true);
		queue_up_suspend_work();
	} else {
        // 相当于输入是 off, disable
		pm_wakep_autosleep_enabled(false);
	}

	mutex_unlock(&autosleep_lock);
	return 0;

}
```

第一. 判断参数.

第二. 上报一个wakeup events，保持系统唤醒.

第三. 设置 autosleep_state 值.

第四. 释放wakeup events，系统可以睡眠.

第五. 判断 state 的值，如果是 off，调用 pm_wakep_autosleep_enabled 函数 disable autosleep，否则调用 `pm_wakep_autosleep_enabled` 函数 enable autosleep 功能，同时提交工作队列。

```cpp
void pm_wakep_autosleep_enabled(bool set)
{
	struct wakeup_source *ws;
	ktime_t now = ktime_get();
	int srcuidx;

	srcuidx = srcu_read_lock(&wakeup_srcu);
    // 遍历所有的 wakeup source
	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {
		spin_lock_irq(&ws->lock);
		if (ws->autosleep_enabled != set) {
            // 修改 autosleep_enabled 标志
			ws->autosleep_enabled = set;
            // wakeup source 是 active 的
			if (ws->active) {
                // 设置
				if (set)
                    // 表明从现在开始就已经阻止autosleep的功能
					ws->start_prevent_time = now;
				else
                    // 说明
					update_prevent_sleep_time(ws, now);
			}
		}
		spin_unlock_irq(&ws->lock);
	}
	srcu_read_unlock(&wakeup_srcu, srcuidx);
}
```


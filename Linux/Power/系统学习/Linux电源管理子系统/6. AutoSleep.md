
起初 autosleep 是在 Android 上的一个 patch(https://lwn.net/Articles/479711/)演化而来的，当时名字叫做 "Opportunistic sleep"，翻译过来叫做"机会主义睡眠"，也就是有机会就睡。因为此名字比较有争议，最后修改为 autosleep。

autosleep 一种强大的电源管理方法，只要在系统没有什么事情可做的时候，整个系统就睡眠下去。此机制在 android 手机上非常有效，同时也能阻止不良应用程序一直保持系统唤醒，浪费电池。但是重要的是: 如何判断当前系统没有事情可做，也就是如何判断系统在空闲状态？ 

这时候 wakeup event framework 的出现就可以解决此问题，当系统中没有 wakeup event 事件的时候，就尝试系统 suspend。如果在 suspend 的过程中有 wakeup event 就接着 resume 系统即可。

同样 autosleep.c 的注释可以说明 autosleep 的前生是 Opportunistic sleep。

```cpp
/*
 * kernel/power/autosleep.c
 *
 * Opportunistic sleep support.
 *
 * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>
 */
```

详细文章可见:  https://lwn.net/Articles/479841/

# 原理

1. 当系统没有任何事情做的时候，就尝试 susupend。

2. 当系统中没有 wakeup event 事件发生的时候，就可以尝试 suspend，需要 wakeup event framework 机制支持。

3. autosleep 功能需要在 kernel config 中开启 `CONFIG_PM_AUTOSLEEP=y`。

4. 通过写 "mem, disk,  standby, freeze" 到 `/sys/power/autosleep` 可以开启 autosleep。

5. 通过写 "off" 到 `/sys/power/autosleep` 就可以关闭autosleep。

# 流程分析

通过执行 "`echo mem > /sys/power/autosleep`" 此命令，系统就会在没有事情可做的时候，选择执行 suspend 的流程。

```cpp
// kernel/power/autosleep.c
// 定义, 默认是0, 即默认 PM_SUSPEND_ON
// PM_SUSPEND_ON 表明关闭 autosleep
static suspend_state_t autosleep_state;

suspend_state_t pm_autosleep_state(void)
{
	return autosleep_state;
}

// kernel/power/main.c
// kernel config 要求
#ifdef CONFIG_PM_AUTOSLEEP
static ssize_t autosleep_show(struct kobject *kobj,
			      struct kobj_attribute *attr,
			      char *buf)
{
    // 返回autosleep_state值
	suspend_state_t state = pm_autosleep_state();

    // 返回off, 表明关闭了
	if (state == PM_SUSPEND_ON)
		return sprintf(buf, "off\n");

#ifdef CONFIG_SUSPEND
    // kernel config 要求
	if (state < PM_SUSPEND_MAX)
        // 返回 s2idle/standby/mem
		return sprintf(buf, "%s\n", pm_states[state] ?
					pm_states[state] : "error");
#endif
#ifdef CONFIG_HIBERNATION
	return sprintf(buf, "disk\n");
#else
	return sprintf(buf, "error");
#endif
}
// kernel/power/power.h
#IFDEF CONFIG_PM_AUTOSLEEP
extern suspend_state_t pm_autosleep_state(void);
#ELSE /* !CONFIG_PM_AUTOSLEEP */ /* 没有配置 CONFIG_PM_AUTOSLEEP, 那么 SUSPEND 是可用的 */
static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }
#ENDIF /* !CONFIG_PM_AUTOSLEEP */
```

```cpp
// kernel/power/main.c
static ssize_t autosleep_store(struct kobject *kobj,
			       struct kobj_attribute *attr,
			       const char *buf, size_t n)
{
    // 上一节有详细分析
    // 解析传入的参数, 返回 0/1/2/3/4
	suspend_state_t state = decode_state(buf, n);
	int error;
    // 传入 off 直接返回
    // 不设置 autosleep_state 值???
	if (state == PM_SUSPEND_ON
	    && strcmp(buf, "off") && strcmp(buf, "off\n"))
		return -EINVAL;

	if (state == PM_SUSPEND_MEM)
        // 上一节有详细分析
		state = mem_sleep_current;
    // 设置autosleep_state
	error = pm_autosleep_set_state(state);
	return error ? error : n;
}

power_attr(autosleep);
#endif /* CONFIG_PM_AUTOSLEEP */
```

解析传参

* 输入 `"disk"`, 返回 `PM_SUSPEND_MAX`, 4

* 输入 `"freeze"/"standby"/"mem"`, 返回 `PM_SUSPEND_TO_IDLE/PM_SUSPEND_STANDBY/PM_SUSPEND_MEM`, 1/2/3

* 否则, 直接返回 `PM_SUSPEND_ON`, 0, 即 **默认返回**

输入 "**off**", 直接返回; 否则调用下面

```cpp
// kernel/power/autosleep.c
int pm_autosleep_set_state(suspend_state_t state)
{
    // 第一
#ifndef CONFIG_HIBERNATION
	if (state >= PM_SUSPEND_MAX)
		return -EINVAL;
#endif
    // 第二
	__pm_stay_awake(autosleep_ws);
    // 拿锁
	mutex_lock(&autosleep_lock);
    // 第三
    // 设置 autosleep_state
	autosleep_state = state;

	__pm_relax(autosleep_ws);

	if (state > PM_SUSPEND_ON) {
		pm_wakep_autosleep_enabled(true);
		queue_up_suspend_work();
	} else {
		pm_wakep_autosleep_enabled(false);
	}

	mutex_unlock(&autosleep_lock);
	return 0;

}
```

第一. 判断参数.

第二. 上报一个wakeup events，保持系统唤醒.

第三. 设置 autosleep_state 值.


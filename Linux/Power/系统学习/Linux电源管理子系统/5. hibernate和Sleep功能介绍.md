
Hibernate和Sleep两个功能是Linux Generic PM的核心功能, 它们的目的是类似的：暂停使用——>保存上下文——>关闭系统以节电········>恢复系统——>恢复上下文——>继续使用.

本文以内核向用户空间提供的接口为突破口, 从整体上对这两个功能进行介绍, 并会在后续的文章中, 分析它们的实现逻辑和执行动作.

虽然这些机制在Linux系统中存在很久了（类似的概念也存在于Windows系统中）, 但它们被使用的频率并不是很高, 特别是在 **PC** 上, 大多数人在大多数时候选择直接关闭系统. 阴错阳差的是, 在很多**嵌入式设备**中, 设计者会利用 Sleep 机制实现**热关机**功能, 以此**减少开机的时间**.

# 相关的术语梳理

## Hibernate 和 Sleep

Hibernate（冬眠）和 Sleep（睡眠）

是Linux电源管理在用户角度的抽象, 是用户可以看到的实实在在的东西. 它们的共同点, 是保存系统运行的上下文后挂起（suspend）系统, 并在系统恢复后接着运行, 就像什么事情都没有发生一样. 它们的不同点, 是上下文保存的位置、系统恢复的触发方式以及具体的实现机制.

## Suspend

有两个层次的含义. 一是Hibernate和Sleep功能在底层实现上的统称, 都是指挂起（Suspend）系统, 根据上下文的保存位置, 可以分为Suspend to Disk（STD, 即Hibernate, 上下文保存在硬盘/磁盘中）和Suspend to RAM（STR, 为Sleep的一种, 上下文保存在RAM中）；二是Sleep功能在代码级的实现, 表现为“kernel/power/suspend.c”文件.

## Standby

是Sleep功能的一个特例, 可以翻译为“打盹”.

正常的Sleep（STR）, 会在处理完上下文后, 由arch-dependent代码将CPU置为低功耗状态（通常为Sleep）. 而现实中, 根据对功耗和睡眠唤醒时间的不同需求, CPU可能会提供多种低功耗状态, 如除Sleep之外, 会提供Standby状态, 该状态下, CPU处于浅睡眠模式, 有任何的风吹草动, 就会立即醒来.

## Wakeup

这是我们第一次正式的提出Wakeup的概念. 我们多次提到恢复系统, 其实在内核中称为Wakeup. 表面上, wakeup很简单, 无论是冬眠、睡眠还是打盹, 总得有一个刺激让我们回到正常状态. 但复杂的就是, 什么样的刺激才能让我们醒来？

动物界, 温度回升可能是唯一可以让动物从冬眠状态醒来的刺激. 而踢一脚、闹钟响等刺激, 则可以让我们从睡眠状态唤醒. 对于打盹来说, 则任何的风吹草动, 都可以唤醒.

而在计算机界, 冬眠（Hibernate）时, 会关闭整个系统的供电, 因此想醒来, 唯有Power按钮可用. 而睡眠时, 为了缩短Wakeup时间, 并不会关闭所有的供电, 另外, 为了较好的用户体验, 通常会保留某些重要设备的供电（如键盘）, 那样这些设备就可以唤醒系统.

这些刻意保留下来的、可以唤醒系统的设备, 统称为唤醒源（Wakeup source）. 而Wakeup source的选择, 则是PM设计工作（特别是Sleep、Standby等功能）的重点.

## 对应关系

用户角度（Hibernate和Sleep）对应的是底层实现上（STD、STR和Standby）.

# 软件架构

内核中该部分的软件架构大概可以分为三个层次, 如下图:

![2024-03-19-14-58-39.png](./images/2024-03-19-14-58-39.png)

1. API Layer, 描述用户空间API的一个抽象层.

这里的API有两类, 一类涉及Hibernate和Sleep两个功能（global APIs）, 包括实际功能、测试用功能、Debug用功能等, 通过sysfs和debugfs两种形式提供；另一类是Hibernate特有的（STD APIs）, 通过sysfs和字符设备两种形式提供.

2. PM Core, 电源管理的核心逻辑层, 位于kernel/power/目录下, 包括主功能（main）、STD、STR&Standby以及辅助功能（assistant）等多个子模块.

主功能, 主要负责实现global APIs相关的逻辑, 为用户空间提供相应的API；

STD, 包括hibernate、snapshot、swap、block_io等子模块, 负责实现STD功能和硬件无关的逻辑；

STR&Stanby, 包括suspend和suspend_test两个子模块, 负责实现STR、Standby等功能和硬件无关的逻辑.

3. PM Driver, 电源管理驱动层, 涉及体系结构无关驱动、体系结构有关驱动、设备模型以及各个设备驱动等多个软件模块.

# 用户空间接口

## /sys/power/state

state 是 sysfs 中一个文件, 为 Generic PM 的核心接口, 在 “`kernel/power/main.c`” 中实现, 用于将系统置于指定的 Power State（如 Hibernate、Sleep、Standby 等）. 不同的电源管理功能, 在底层的实现, 就是在不同 Power State 之间切换.

读取该文件, 返回当前系统支持的Power State, 形式为字符串. 在内核中, 有两种类型的 Power State, 一种是 Hibernate 相关的, 名称为“disk”, 除“disk”之外, 内核在 "`kernel/power/suspend.c`" 中通过数组的形式定义了另外 3 个 state, 如下：



写入特定的 Power State 字符串, 将会把系统置为该模式.

## /sys/power/pm_trace

PM Trace 用于提供电源管理过程中的 Trace 记录, 由 “`CONFIG_PM_TRACE`” 宏定义（`kernel/power/Kconfig`）控制是否编译进内核, 并由 “`/sys/power/pm_trace`” 文件在运行时控制是否使能该功能.

该功能的具体实现是 “平台相关” 的



"PM trace" 机制, 在重新启动后会在 RTC 内存中保存最后一次 suspend 或 resume 的 event point.  它有助于更有效地调试由于系统 suspend 或 resume(更常见)期间发生的设备驱动进程故障而导致的硬锁定或重新启动.

如果是 "1", 则每个 suspend/resume event point 将依次存储在 RTC 内存中(覆盖实际的 RTC 信息), 因此如果在存储后立即发生系统崩溃,它将在系统崩溃中幸存下来,并且可以在以后用于识别导致崩溃发生的驱动进程.

原理: 覆写了 rtc 寄存器(年月日时分秒), 所以 rtc suspend&resume 不能再使用

要使用此调试功能,必须打开 `CONFIG_PM_TRACE`, `CONFIG_PM_TRACE_RTC`

```
echo 1 > /sys/power/pm_trace
```

这样 `TRACE_DEVICE();`, `TRACE_SUSPEND()` 和 `TRACE_RESUME();` 便会生效.

先 suspend, 然后 reboot, 运行

```
dmesg -s 1000000 Avail grep 'hash matches'
```

注意: 此选项将导致机器的 **rtc** 在恢复后设置为无效时间.

```
# DMESG | GREP -I MAGIC -A 10
[   13.298421] PM:   Magic number: 0:636:969
[   13.299536] PM:   hash matches drivers/base/power/main.c:615
[   13.300853] hidraw hidraw0: hash matches
[   13.301786] pci 0000:00:15.0: hash matches
[   13.303180] printk: console [netcon0] enabled
[   13.304250] netconsole: network logging started
[   13.306034] ALSA device list:
[   13.306878]   No soundcards found.
[   13.379379] EXT4-fs (sda2): recovery complete
[   13.381143] EXT4-fs (sda2): mounted filesystem with ordered data mode. Opts: (null). Quota mode: none.
[   13.382491] VFS: Mounted root (ext4 filesystem) on device 8:2.
```

```cpp
// kernel/power/main.c
#IFDEF CONFIG_PM_TRACE
// 默认为 0
int pm_trace_enabled;
static ssize_t
pm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,
           const char *buf, size_t n)
{
    int val;

    if (sscanf(buf, "%d", &val) == 1) {
        pm_trace_enabled = !!val;
        if (pm_trace_enabled) {
            pr_warn("PM: Enabling pm_trace changes system date and time during resume.\n"
                "PM: Correct system time has to be restored manually after resume.\n");
        }
        return n;
    }
    return -EINVAL;
}

power_attr(pm_trace);
#ENDIF /* CONFIG_PM_TRACE */

// include/linux/pm-trace.h
extern int pm_trace_enabled;
// async 使用
static inline int pm_trace_is_enabled(void)
{
       return pm_trace_enabled;
}
```

## /sys/power/pm_test

PM test 用于对电源管理功能的测试, 由 “CONFIG_PM_DEBUG” 宏定义（`kernel/power/Kconfig`）控制是否编译进内核. 其核心思想是：

* 将电源管理过程按照先后顺序, 划分为多个步骤, 如core、platform、devices等. 这些步骤称作PM Test Level.

* 系统通过一个全局变量（pm_test_level）, 保存系统当前的PM Test Level. 该变量的值可以通过”/sys/power/pm_test“文件获取及修改.

* 在每一个电源管理步骤结束后, 插入PM test代码, 该代码以当前执行步骤为参数, 会判断当前的PM Test Level和执行步骤是否一致, 如果一致, 则说明该步骤执行成功. 出于Test考量, 执行成功后, 系统会打印Test信息, 并在等待一段时间后, 退出PM过程.

* 开发人员可以通过修改全局的Test Level, 有目的测试所关心的步骤是否执行成功.

上面已经讲了, 该文件用于获取及修改 PM Test Level, 具体的 Level 信息在 “kernel/power/main.c” 中定义, 格式如下（具体的意义, 比较简单, 对着相关的代码看, 非常清晰, 这里就不啰嗦了）：





## /sys/power/wakeup_count

该接口只和Sleep功能有关, 因此由“CONFIG_PM_SLEEP”宏定义（kernel/power/Kconfig）控制. 它的存在, 是为了解决Sleep和Wakeup之间的同步问题.

我们知道, 系统睡眠后, 可以通过保留的Wakeup source唤醒系统. 而在当今的CPU体系中, 唤醒系统就是唤醒CPU, 而唤醒CPU的唯一途径, 就是Wakeup source产生中断（内核称作Wakeup event）. 而内核要保证在多种状态下, Sleep/Wakeup的行为都能正常, 如下：

* 系统处于sleep状态时, 产生了Wakeup event. 此时应该直接唤醒系统. 这一点没有问题.

* 系统在进入sleep的过程中, 产生了Wakeup event. 此时应该放弃进入sleep.

这一点就不那么容易做到了. 例如, 当Wakeup event发生在“/sys/power/state”被写之后、内核执行freeze操作之前. 此时用户空间程序依旧可以处理Wakeup event, 或者只是部分处理. 而内核却以为该Event已经被处理, 因此并不会放弃此次sleep动作.

这就会造成, Wakeup event发生后, 用户空间程序已经后悔了, 不想睡了, 但最终还是睡下去了. 直到下一个Wakeup event到来.

为了解决上面的问题, 内核提供wkaeup_count机制, 配合 “/sys/power/state”, 以实现Sleep过程中的同步. 该机制的操作行为如下：

* wakeup_count是内核用来保存当前wakeup event发生的计数.

* 用户空间程序在写入state切换状态之前, 应先读取wakeup_count并把获得的count写回给wakeup_count.

* 内核会比对写回的count和当前的count是否一致, 如果不一致, 说明在读取/写回操作之间, 产生了新的的wakeup event, 内核就会返回错误.

* 用户空间程序检测到写入错误之后, 不能继续后的动作, 需要处理响应的event并伺机再次读取/写回wakeup_count.

* 如果内核比对一致, 会记录write wakeup_count成功时的event快照, 后面继续suspend动作时, 会检查是否和快照相符, 如果不符, 会终止suspend.

* 用户空间程序检测到写入正确后, 可以继续对state的写入, 以便发起一次状态切换. 而此时是安全的.

在后续的文章中, 详细描述该机制在内核中的实现逻辑.

## /sys/power/disk

该接口是 STD 特有的. 用于设置或获取 STD 的类型. 当前内核支持的 STD 类型包括：

```cpp
// kernel/power/hibernate.c
static const char * const hibernation_modes[] = {
	[HIBERNATION_PLATFORM]	= "platform",
	[HIBERNATION_SHUTDOWN]	= "shutdown",
	[HIBERNATION_REBOOT]	= "reboot",
#ifdef CONFIG_SUSPEND
	[HIBERNATION_SUSPEND]	= "suspend",
#endif
	[HIBERNATION_TEST_RESUME]	= "test_resume",
};
```

* platform, 表示使用平台特有的机制, 处理 STD 操作, 如使用 `hibernation_ops` 等.

* shutdown, 通过关闭系统实现 STD, 内核会调用 `kernel_power_off` 接口.

* reboot, 通过重启系统实现 STD, 内核会调用 `kernel_restart` 接口.

【注：以上两个 `kernel_xxx` 接口的实现, 可参考 “常规PM的Reboot”. 】

* suspend, 利用 STR 功能, 实现 STD. 该类型下, STD 和 STR 底层的处理逻辑类似.

## /sys/power/image_size

该接口也是 STD 特有的. 我们知道, STD 的原理是将当前的运行上下文保存在系统的 disk（如 NAND Flash, 如硬盘）, 然后选择合适的方式关闭或重启系统. 保存上下文是需要存储空间的, 不光是 disk 中的存储空间, 也包括位于内存的用于交换或缓冲的空间.

而该接口, 就是设置或者获取当前内存中需要分配多少空间, 用于缓冲需要写入到 disk 的数据. 单位为 byte.

## /sys/power/reserverd_size

`reserverd_size` 用于指示预留多少内存空间, 用于在 `->freeze()` 和  `->freeze_noirq()` 过程中保存设备驱动分配的空间. 以免在 STD 的过程中丢失.

## /sys/power/resume

该接口也是 STD 特有的. 正常情况下, 在重新开机后, 内核会在后期的初始化过程中, 读取保存在 disk 中的 image, 并恢复系统. 而该接口, 提供了一种在用户空间手动的读取 image 并恢复系统的方法.

通常情况下, 该操作出现在系统正常运行的过程中, 需要加载并执行另外的 image.

## debugfs/suspend_status

该接口是以 debugfs 的形式, 向用户空间提供 suspend 过程的统计信息, 包括：成功的次数、失败的次数、freeze 失败的次数等等.

## /dev/snapshot

该接口也是 STD 特有的. 它通过字符设备的形式, 向用户空间提供 software 的 STD 操作. 我们会在后续的文章中详细描述.

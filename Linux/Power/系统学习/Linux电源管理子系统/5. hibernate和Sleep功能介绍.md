
Hibernate和Sleep两个功能是Linux Generic PM的核心功能，它们的目的是类似的：暂停使用——>保存上下文——>关闭系统以节电········>恢复系统——>恢复上下文——>继续使用。

本文以内核向用户空间提供的接口为突破口，从整体上对这两个功能进行介绍，并会在后续的文章中，分析它们的实现逻辑和执行动作。

虽然这些机制在Linux系统中存在很久了（类似的概念也存在于Windows系统中），但它们被使用的频率并不是很高，特别是在 **PC** 上，大多数人在大多数时候选择直接关闭系统。阴错阳差的是，在很多**嵌入式设备**中，设计者会利用 Sleep 机制实现**热关机**功能，以此**减少开机的时间**。

# 相关的术语梳理

## Hibernate 和 Sleep

Hibernate（冬眠）和 Sleep（睡眠）

是Linux电源管理在用户角度的抽象，是用户可以看到的实实在在的东西。它们的共同点，是保存系统运行的上下文后挂起（suspend）系统，并在系统恢复后接着运行，就像什么事情都没有发生一样。它们的不同点，是上下文保存的位置、系统恢复的触发方式以及具体的实现机制。

## Suspend

有两个层次的含义。一是Hibernate和Sleep功能在底层实现上的统称，都是指挂起（Suspend）系统，根据上下文的保存位置，可以分为Suspend to Disk（STD，即Hibernate，上下文保存在硬盘/磁盘中）和Suspend to RAM（STR，为Sleep的一种，上下文保存在RAM中）；二是Sleep功能在代码级的实现，表现为“kernel/power/suspend.c”文件。

## Standby

是Sleep功能的一个特例，可以翻译为“打盹”。

正常的Sleep（STR），会在处理完上下文后，由arch-dependent代码将CPU置为低功耗状态（通常为Sleep）。而现实中，根据对功耗和睡眠唤醒时间的不同需求，CPU可能会提供多种低功耗状态，如除Sleep之外，会提供Standby状态，该状态下，CPU处于浅睡眠模式，有任何的风吹草动，就会立即醒来。

## Wakeup

这是我们第一次正式的提出Wakeup的概念。我们多次提到恢复系统，其实在内核中称为Wakeup。表面上，wakeup很简单，无论是冬眠、睡眠还是打盹，总得有一个刺激让我们回到正常状态。但复杂的就是，什么样的刺激才能让我们醒来？

动物界，温度回升可能是唯一可以让动物从冬眠状态醒来的刺激。而踢一脚、闹钟响等刺激，则可以让我们从睡眠状态唤醒。对于打盹来说，则任何的风吹草动，都可以唤醒。

而在计算机界，冬眠（Hibernate）时，会关闭整个系统的供电，因此想醒来，唯有Power按钮可用。而睡眠时，为了缩短Wakeup时间，并不会关闭所有的供电，另外，为了较好的用户体验，通常会保留某些重要设备的供电（如键盘），那样这些设备就可以唤醒系统。

这些刻意保留下来的、可以唤醒系统的设备，统称为唤醒源（Wakeup source）。而Wakeup source的选择，则是PM设计工作（特别是Sleep、Standby等功能）的重点。

## 对应关系

用户角度（Hibernate和Sleep）对应的是底层实现上（STD、STR和Standby）。

# 软件架构

内核中该部分的软件架构大概可以分为三个层次，如下图:

![2024-03-19-14-58-39.png](./images/2024-03-19-14-58-39.png)

1. API Layer，描述用户空间API的一个抽象层。

这里的API有两类，一类涉及Hibernate和Sleep两个功能（global APIs），包括实际功能、测试用功能、Debug用功能等，通过sysfs和debugfs两种形式提供；另一类是Hibernate特有的（STD APIs），通过sysfs和字符设备两种形式提供。

2. PM Core，电源管理的核心逻辑层，位于kernel/power/目录下，包括主功能（main）、STD、STR&Standby以及辅助功能（assistant）等多个子模块。

主功能，主要负责实现global APIs相关的逻辑，为用户空间提供相应的API；

STD，包括hibernate、snapshot、swap、block_io等子模块，负责实现STD功能和硬件无关的逻辑；

STR&Stanby，包括suspend和suspend_test两个子模块，负责实现STR、Standby等功能和硬件无关的逻辑。

3. PM Driver，电源管理驱动层，涉及体系结构无关驱动、体系结构有关驱动、设备模型以及各个设备驱动等多个软件模块。

# 用户空间接口

## /sys/power/state




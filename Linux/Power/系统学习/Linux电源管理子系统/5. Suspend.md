
Linux 电源管理存在的几种方式, 如何查看这几种方式, 以及最后的如何睡眠唤醒等. 通过 `echo mem > /sys/power/state` 就可以达到睡眠, 所以可以根据此节点的 sys 代码分析 suspend 的流程.

# suspend 代码入口

执行如下命令:

```
echo mem > /sys/power/state
```

根据 sys 节点的属性命令规则, 可以得到此节点的实现代码为:  `state_store`

## state_store 函数分析

```cpp

```

第一. `pm_autosleep_lock`

```cpp

```

获得 autosleep 锁, 锁住 autosleep 功能, 此功能在后面分析

第二. 判断当前 autosleep 的状态, 如果当前状态大于 PM_SUSPEND_ON 则, 返回退出. 关于 suspend 的状态如下：

```cpp

```

第三. 解析当前传入的 state. 如果 state 小于 PM_SUSPEND_MAX 就走 suspend 流程, 等于 PM_SUSPEND_MAX 就走 hibernate 流程. 假如我们传入的是 mem, 则就会走 suspend 流程.

## pm_suspend 函数分析

```cpp

```

第一. 依然会再次判断当前的 state 是否在 PM_SUSPEND_ON 和 PM_SUSPEND_MAX 之间

第二. pm_suspend_marker("entry")

```cpp

```

在 suspend 之间记录时间, 用于统计或者调试 suspend 花费的时间.

第三. 调用 enter_state 进入 suspend 的下一步, 如果执行 suspend 成功, 增加 suspend.success 的引用计数, 否则增加 suspend.fail 的引用计数.

## enter_state 函数分析

```cpp

```

第一. 通过 vaild_state 函数用来判断该平台是否支持该状态睡眠.

```cpp

```

第二. 调用 mutex_trylock 获得一个 mutex 锁, 防止在 suspend 的时候再次 suspend.

第三. 如果当前 state 是 PM_SUSPEND_FREEZE, 则调用 freeze_begin 做开始准备工作.

第四. 同步文件系统.

第五. 调用 suspend_prepare 做进一步 suspend 前期准备工作, 准备控制台, 冻结内核线程等.

第六. 调用 suspend_devices_and_enter 做设备以及系统相关的 susupend 操作.

第七. 调用 suspend_finish 做最后的恢复工作.

# suspend_prepare 函数分析

```cpp

```

第一. 检测该平台 suspend_ops 是否实现了 enter 函数.

```cpp

```

第二. 调用 pm_prepare_console 函数切换控制台, 重新分配一个 suspend 模式下控制台, 然后重定向 kmsg.

第三. 通过调用 pm 通知链, 发送 PM_SUSPEND_PREPARE 消息.

```cpp

```

那谁会收到这类消息呢？ 只有通过 register_pm_notifier 的设备, 子系统会在这个时候处理自己的事情.

```cpp

```

第四. 调用 suspend_freeze_processes 冻结 userhelper 进程, 已经内核线程. 如果冻结出现失败, 记录失败的引用计数.

第五. 接着会通过通知链恢复 suspend, 已经恢复控制台.

# suspend_devices_and_enter 函数分析

```cpp

```

第一. 调用 sleep_state_supported 函数判断当前平台是否实现了 suspend_ops，已经 suspend_ops->enter 函数。
第二. 如果当前状态是 freeze，就调用 freeze_ops 的 begin 函数。否则就调用平台相关的 begin 函数。这里的 begin 主要是各个平台 pm 的一些设置，每个平台的操作都不一样，这里不详细说明。
调用 suspend_console 挂起控制台，防止其它代码访问该控制台。
调用 suspend_test_start 记录当前 suspend 刚开始的时候的时间，使用 jiffies 表示。
调用 dpm_suspend_start 函数，该函数主要是调用所有设备的 prepare 和 suspend 回调函数。如果出现 suspend 失败，则会打印"fail suspend"的 log，以及调用 platform_recover 函数执行平台相关的 recover 回调。
调用 suspend_enter 使整个系统进入 suspend 

# 概述

Wakeup count 是 Wakeup events framework 的组成部分，用于解决“system suspend 和 system wakeup events 之间的同步问题”。本文将结合“Suspend”和“Wakeup events framework”两篇文章，分析wakeup count的功能、实现逻辑、背后的思考，同时也是对这两篇文章的复习和总结。

# wakeup count在电源管理中的位置

wakeup count的实现位于wakeup events framework中（`drivers/base/power/wakeup.c`），主要为两个模块提供接口: 通过 PM core 向用户空间提供 sysfs 接口；直接向 autosleep（请参考下一篇文章）提供接口。

![2024-03-19-10-33-35.png](./images/2024-03-19-10-33-35.png)

# wakeup count的功能

wakeup count 的功能是 suspend 同步，实现思路是这样的: 

1）任何想发起电源状态切换的**实体**（可以是用户空间电源管理进程，也可以是内核线程，简称C），在发起状态切换前，读取系统的 wakeup counts（该值记录了当前的 wakeup event 总数），并将读取的 counts 告知 wakeup events framework。

2）wakeup events framework 记录该counts到一个全局变量中（saved_count）。

3）随后 C 发起电源状态切换（如STR），执行 suspend 过程。

4）在suspend的过程中，wakeup events framework照旧工作（直到系统中断被关闭），上报 wakeup events，增加 wakeup events counts。

5）suspend执行的一些时间点（可参考“Linux电源管理(6)_Generic PM之Suspend功能”），会调用wakeup  events framework提供的接口（pm_wakeup_pending），检查是否有wakeup没有处理。

6）检查逻辑很简单，就是比较当前的wakeup counts和saved wakeup counts（C发起电源状态切换时的counts），如果不同，就要终止suspend过程。

# wakeup count的实现逻辑

## 一个例子

在进行代码分析之前，我们先用伪代码的形式，写出一个利用 wakeup count 进行 suspend 操作的例子，然后基于该例子，分析相关的实现。

```cpp
do {
    ret = read(&cnt, "/sys/power/wakeup_count");
    if (ret) {
        ret = write(cnt, "/sys/power/wakeup_count");
    } else {
        continue;
    }
} while (!ret);

write("mem", "/sys/power/state");

/* goto here after wakeup */
```

例子很简单: 

a）读取 wakeup count 值，如果成功，将读取的值回写。否则说明有正在处理的wakeup events，continue。

b）回写后，判断返回值是否成功，如果不成功（说明读、写的过程中产生了wakeup events），继续读、写，直到成功。成功后，可以触发电源状态切换。

## /sys/power/wakeup_count

wakeup_count 文件是在 kernel/power/main.c 中，利用 power_attr 注册的，如下（大家可以仔细研读一下那一大段注释，内核很多注释写的非常好）: 

```cpp
#ifdef CONFIG_PM_SLEEP
/*
 * The 'wakeup_count' attribute, along with the functions defined in
 * drivers/base/power/wakeup.c, provides a means by which wakeup events can be
 * handled in a non-racy way.
 *
 * If a wakeup event occurs when the system is in a sleep state, it simply is
 * woken up.  In turn, if an event that would wake the system up from a sleep
 * state occurs when it is undergoing a transition to that sleep state, the
 * transition should be aborted.  Moreover, if such an event occurs when the
 * system is in the working state, an attempt to start a transition to the
 * given sleep state should fail during certain period after the detection of
 * the event.  Using the 'state' attribute alone is not sufficient to satisfy
 * these requirements, because a wakeup event may occur exactly when 'state'
 * is being written to and may be delivered to user space right before it is
 * frozen, so the event will remain only partially processed until the system is
 * woken up by another event.  In particular, it won't cause the transition to
 * a sleep state to be aborted.
 *
 * This difficulty may be overcome if user space uses 'wakeup_count' before
 * writing to 'state'.  It first should read from 'wakeup_count' and store
 * the read value.  Then, after carrying out its own preparations for the system
 * transition to a sleep state, it should write the stored value to
 * 'wakeup_count'.  If that fails, at least one wakeup event has occurred since
 * 'wakeup_count' was read and 'state' should not be written to.  Otherwise, it
 * is allowed to write to 'state', but the transition will be aborted if there
 * are any wakeup events detected after 'wakeup_count' was written to.
 */

static ssize_t wakeup_count_show(struct kobject *kobj,
				struct kobj_attribute *attr,
				char *buf)
{
	unsigned int val;

	return pm_get_wakeup_count(&val, true) ?
		sprintf(buf, "%u\n", val) : -EINTR;
}

static ssize_t wakeup_count_store(struct kobject *kobj,
				struct kobj_attribute *attr,
				const char *buf, size_t n)
{
	unsigned int val;
	int error;

	error = pm_autosleep_lock();
	if (error)
		return error;

	if (pm_autosleep_state() > PM_SUSPEND_ON) {
		error = -EBUSY;
		goto out;
	}

	error = -EINVAL;
	if (sscanf(buf, "%u", &val) == 1) {
		if (pm_save_wakeup_count(val))
			error = n;
		else
			pm_print_active_wakeup_sources();
	}

 out:
	pm_autosleep_unlock();
	return error;
}

power_attr(wakeup_count);
```

实现很简单: read时，直接调用 `pm_get_wakeup_count`（注意第2个参数）；write 时，直接调用 `pm_save_wakeup_count`（注意用户空间的 wakeup count 功能和 auto sleep 互斥，会在下篇文章解释原因）。这两个接口均是wakeup events framework提供的接口，跟着代码往下看吧。

## pm_get_wakeup_count

该接口有两个参数，一个是保存返回的count值得指针，另一个指示是否block，具体请参考代码逻辑

```cpp
bool pm_get_wakeup_count(unsigned int *count, bool block)
{
	unsigned int cnt, inpr;

	if (block) {
		DEFINE_WAIT(wait);

		for (;;) {
			prepare_to_wait(&wakeup_count_wait_queue, &wait,
					TASK_INTERRUPTIBLE);
			split_counters(&cnt, &inpr);
			if (inpr == 0 || signal_pending(current))
				break;
			pm_print_active_wakeup_sources();
			schedule();
		}
		finish_wait(&wakeup_count_wait_queue, &wait);
	}

	split_counters(&cnt, &inpr);
	*count = cnt;
	return !inpr;
}
```

第一. 如果block为false，直接读取registered wakeup events和wakeup events in progress两个counter值，将registered wakeup events交给第一个参数，并返回wakeup events in progress的状态（若返回false，说明当前有wakeup events正在处理，不适合suspend）。

第二. 如果block为true，定义一个等待队列，等待wakeup events in progress为0，再返回counter。

注1: 由上面可知，sysfs发起的read动作，block为true，所以如果有正在处理的wakeup events，read进程会阻塞。其它模块（如auto sleep）发起的read，则可能不需要阻塞。
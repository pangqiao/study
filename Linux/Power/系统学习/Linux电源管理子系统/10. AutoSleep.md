
# 概述

autosleep 是在 Android 上的 wakelocks patchset(https://lwn.net/Articles/479711/)演化而来的，用于**取代** wakelock 中的自动休眠功能.

它基于 wakeup source 实现。从代码逻辑上讲， autosleep 是一个简单的功能，但是背后却埋藏这一个令人深思的问题。

* 计算机的休眠（通常是 STR, Standby, Hibernate 等 suspend 操作）， 应当在什么时候，由谁触发？

* 对于pc，笔记本来说： 由**用户**在其**不想使用**或**不再使用**时;

* 对于移动设备：用户随时随地都可能使用设备，上面的回答就不再成立. 这时，Android提出了"Opportunistic suspend"("机会主义睡眠"，也就是有机会就睡)的理论, 通俗来讲, 就是"逮到机会就睡". 而 autosleep 功能，无论是基于 Android **wakelocks** 的 autosleep，还是基于 **wakeup source** 的 autosleep，都是为了实现“Opportunistic suspend”。困难的点在于如何判定系统没有事情可做。

相比较“对多样的系统组件单独控制”的电源管理方案（如Linux kernel的Dynamic PM），“Opportunistic suspend”是非常简单的，只要检测到系统没有事情在做（逮到机会），就 suspend 整个系统。这对系统的开发人员（特别是 driver 开发者）来说，很容易实现，几乎不需要特别处理。

但困难的是，“**系统没有事情在做**”的判断依据是什么？能判断准确吗？会不会浪费过多的资源在"susend->resume-supsend…”的无聊动作上？如果只有一个设备在做事情，其它设备岂不是也得陪着耗电？等等…

所以，实现“Opportunistic suspend”机制的autosleep功能，是充满争议的。说实话，也是不优雅的。但它可以解燃眉之急，因而虽然受非议，却在Android设备中广泛使用。

其实Android中很多机制都是这样的（如wakelocks，如binder，等等），可以这样比方：Android是设计中的现实主义，Linux kernel是设计中的理想主义，当理想和现实冲突时，怎么调和？不只是Linux kernel，其它的诸如设计、工作和生活，都会遇到类似的冲突，怎么对待？没有答案，但有一个原则：不要偏执，不要试图追求非黑即白的真理！

因为此名字比较有争议，最后修改为 autosleep。

同样 autosleep.c 的注释可以说明 autosleep 的前身是 Opportunistic sleep。

```cpp
/*
 * kernel/power/autosleep.c
 *
 * Opportunistic sleep support.
 *
 * Copyright (C) 2012 Rafael J. Wysocki <rjw@sisk.pl>
 */
```

详细文章可见:  https://lwn.net/Articles/479841/


# 功能总结和实现原理

Autosleep的功能很已经很直白了，“系统没有事情在做”的时候，就将系统切换到低功耗状态。

根据使用场景，低功耗状态可以是 Freeze， Standby, Suspend to RAM 和 suspend to disk中的任意一种。 而怎么判断系统没有事情在做呢？ 依赖 **wakeup events framework**。 只要系统没有正在处理和新增的 wakeup events， 就尝试 suspend, 如果suspend过程中有events 产生，再 resume 就是了。

由于 suspend/resume 的操作如此频繁，解决同步问题就越发重要，这也要依赖 wakeup events framework 及其 wakeup count 功能。

1. 当系统没有任何事情做的时候，就尝试 susupend。

2. 当系统中没有 wakeup event 事件发生的时候，就可以尝试 suspend，需要 wakeup event framework 机制支持。

3. autosleep 功能需要在 kernel config 中开启 `CONFIG_PM_AUTOSLEEP=y`。

4. 通过写 "mem, disk,  standby, freeze" 到 `/sys/power/autosleep` 可以开启 autosleep。

5. 通过写 "off" 到 `/sys/power/autosleep` 就可以关闭autosleep。

# 架构

autosleep 的实现位于 `kernel/power/autosleep.c` 中，基于 wakeup count 和 suspend & hibernate 功能，并通过 PM core的 main 模块向用户空间提供 sysfs 文件（`/sys/power/autosleep`）

![2024-03-18-21-19-13.png](./images/2024-03-18-21-19-13.png)

之前讨论过 wakeup count 功能，本文的 autosleep，就是使用 wakeup count 的一个实例.

# 代码分析

## sys 节点

通过执行 "`echo mem > /sys/power/autosleep`" 此命令，系统就会在没有事情可做的时候，选择执行 suspend 的流程。

```cpp
// kernel/power/autosleep.c
// 定义, 默认是0, 即默认 PM_SUSPEND_ON
// PM_SUSPEND_ON 表明关闭 autosleep
static suspend_state_t autosleep_state;

suspend_state_t pm_autosleep_state(void)
{
	return autosleep_state;
}

// kernel/power/main.c
// kernel config 要求
#ifdef CONFIG_PM_AUTOSLEEP
static ssize_t autosleep_show(struct kobject *kobj,
			      struct kobj_attribute *attr,
			      char *buf)
{
    // 返回autosleep_state值
	suspend_state_t state = pm_autosleep_state();

    // 返回off, 表明关闭了
	if (state == PM_SUSPEND_ON)
		return sprintf(buf, "off\n");

#ifdef CONFIG_SUSPEND
    // kernel config 要求
	if (state < PM_SUSPEND_MAX)
        // 返回 s2idle/standby/mem
		return sprintf(buf, "%s\n", pm_states[state] ?
					pm_states[state] : "error");
#endif
#ifdef CONFIG_HIBERNATION
	return sprintf(buf, "disk\n");
#else
	return sprintf(buf, "error");
#endif
}
// kernel/power/power.h
#IFDEF CONFIG_PM_AUTOSLEEP
extern suspend_state_t pm_autosleep_state(void);
#ELSE /* !CONFIG_PM_AUTOSLEEP */ /* 没有配置 CONFIG_PM_AUTOSLEEP, 那么 SUSPEND 是可用的 */
static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }
#ENDIF /* !CONFIG_PM_AUTOSLEEP */
```

```cpp
// kernel/power/main.c
static ssize_t autosleep_store(struct kobject *kobj,
			       struct kobj_attribute *attr,
			       const char *buf, size_t n)
{
    // 第一
    // 参照 suspend 节
    // 解析传入的参数, 返回 0/1/2/3/4
	suspend_state_t state = decode_state(buf, n);
	int error;
    // ON的时候, 传入不是 off 直接返回
	if (state == PM_SUSPEND_ON
	    && strcmp(buf, "off") && strcmp(buf, "off\n"))
		return -EINVAL;

	if (state == PM_SUSPEND_MEM)
        // 参照 suspend 节
		state = mem_sleep_current;
    // 第二
    // 设置autosleep_state
	error = pm_autosleep_set_state(state);
	return error ? error : n;
}

power_attr(autosleep);
#endif /* CONFIG_PM_AUTOSLEEP */
```

第一. 解析传参, 只接受 ”freeze”，“standby”，“mem”，“disk”， “off” 等5个字符串中的一个

第二. `PM_SUSPEND_ON` 但输入不是 "**off**", 直接返回; 否则调用 `pm_autosleep_set_state`



```cpp
// kernel/power/autosleep.c
int pm_autosleep_set_state(suspend_state_t state)
{
    // 第一
#ifndef CONFIG_HIBERNATION
	if (state >= PM_SUSPEND_MAX)
		return -EINVAL;
#endif
    // 第二
	__pm_stay_awake(autosleep_ws);
    // 拿锁
	mutex_lock(&autosleep_lock);
    // 第三
    // 设置 autosleep_state
	autosleep_state = state;
    // 第四
	__pm_relax(autosleep_ws);
    // 第五
	if (state > PM_SUSPEND_ON) {
        // enable
		pm_wakep_autosleep_enabled(true);
		queue_up_suspend_work();
	} else {
        // 相当于输入是 off, disable
		pm_wakep_autosleep_enabled(false);
	}

	mutex_unlock(&autosleep_lock);
	return 0;

}
```

第一. 判断参数.

第二. 上报一个wakeup events，保持系统唤醒.

第三. 设置 autosleep_state 值.

第四. 释放wakeup events，系统可以睡眠.

第五. 判断 state 的值，如果是 off，调用 pm_wakep_autosleep_enabled 函数 disable autosleep，否则调用 `pm_wakep_autosleep_enabled` 函数 enable autosleep 功能，同时提交工作队列。

```cpp
void pm_wakep_autosleep_enabled(bool set)
{
	struct wakeup_source *ws;
	ktime_t now = ktime_get();
	int srcuidx;

	srcuidx = srcu_read_lock(&wakeup_srcu);
    // 遍历所有的 wakeup source
	list_for_each_entry_rcu_locked(ws, &wakeup_sources, entry) {
		spin_lock_irq(&ws->lock);
		if (ws->autosleep_enabled != set) {
            // 修改 autosleep_enabled 标志
			ws->autosleep_enabled = set;
            // wakeup source 是 active 的
			if (ws->active) {
                // 设置
				if (set)
                    // 表明从现在开始就已经阻止autosleep的功能
					ws->start_prevent_time = now;
				else
                    // 说明
					update_prevent_sleep_time(ws, now);
			}
		}
		spin_unlock_irq(&ws->lock);
	}
	srcu_read_unlock(&wakeup_srcu, srcuidx);
}
```

